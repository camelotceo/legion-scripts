<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legion's Space Fight</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; background: #1a1a2e;
            font-family: 'Segoe UI', Arial, sans-serif; overflow: hidden;
        }
        #gameContainer { position: relative; }
        #gameCanvas {
            border: 3px solid #4a4a8a; border-radius: 8px;
            box-shadow: 0 0 30px rgba(100, 100, 255, 0.3);
        }
        #ui {
            position: absolute; top: 10px; left: 10px; right: 10px;
            display: flex; justify-content: space-between; align-items: flex-start;
            color: #fff; font-size: 16px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .ui-left, .ui-right { display: flex; flex-direction: column; gap: 5px; }
        .ui-center { display: flex; flex-direction: column; align-items: center; gap: 5px; }
        #levelDisplay { color: #ffd700; font-weight: bold; }
        #difficultyDisplay { color: #ff6b6b; font-size: 12px; }
        #weaponDisplay { color: #0ff; font-size: 14px; }
        #muteButton, #quitButton {
            background: rgba(100, 100, 255, 0.3); border: 2px solid rgba(255, 255, 255, 0.5);
            color: #fff; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 14px;
        }
        #muteButton:hover, #quitButton:hover { background: rgba(100, 100, 255, 0.5); }
        #muteButton.muted { background: rgba(255, 100, 100, 0.3); border-color: rgba(255, 100, 100, 0.7); }
        #quitButton { background: rgba(255, 100, 100, 0.3); border-color: rgba(255, 100, 100, 0.7); margin-top: 5px; }
        #quitButton:hover { background: rgba(255, 100, 100, 0.5); }
        #startScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0, 0, 0, 0.9); color: #fff; border-radius: 8px;
        }
        #gameOverScreen {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0, 0, 0, 0.95); color: #fff; border-radius: 15px;
            border: 2px solid #f66; padding: 25px 40px; max-width: 350px; z-index: 200;
            box-shadow: 0 0 30px rgba(255, 100, 100, 0.4);
        }
        #startScreen h1, #gameOverScreen h1 {
            font-size: 38px; margin-bottom: 15px; color: #6af;
            text-shadow: 0 0 20px rgba(100, 170, 255, 0.8);
        }
        #gameOverScreen h1 { font-size: 28px; color: #fff; }
        #gameOverScreen h2 { font-size: 22px; margin-bottom: 10px; color: #f66; }
        .btn {
            padding: 12px 35px; font-size: 18px;
            background: linear-gradient(135deg, #4a6cf7, #6a4cf7);
            color: #fff; border: none; border-radius: 30px; cursor: pointer;
            margin: 8px; box-shadow: 0 5px 20px rgba(100, 100, 255, 0.4);
        }
        .btn:hover { transform: scale(1.05); }
        .difficulty-section { margin: 20px 0; text-align: center; }
        .difficulty-section h3 { color: #aaa; margin-bottom: 15px; font-size: 16px; }
        .difficulty-btns { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        .diff-btn {
            padding: 10px 20px; font-size: 14px; border: 2px solid; border-radius: 20px;
            cursor: pointer; background: transparent; transition: all 0.3s;
        }
        .diff-btn.easy { color: #4ade80; border-color: #4ade80; }
        .diff-btn.medium { color: #facc15; border-color: #facc15; }
        .diff-btn.hard { color: #f97316; border-color: #f97316; }
        .diff-btn.expert { color: #ef4444; border-color: #ef4444; }
        .diff-btn:hover, .diff-btn.selected { color: #fff; }
        .diff-btn.easy:hover, .diff-btn.easy.selected { background: #4ade80; }
        .diff-btn.medium:hover, .diff-btn.medium.selected { background: #facc15; color: #000; }
        .diff-btn.hard:hover, .diff-btn.hard.selected { background: #f97316; }
        .diff-btn.expert:hover, .diff-btn.expert.selected { background: #ef4444; }
        .controls { margin-top: 20px; color: #aaa; text-align: center; line-height: 1.6; font-size: 13px; }
        .color-select { margin: 15px 0; display: flex; gap: 15px; justify-content: center; }
        .color-btn {
            width: 45px; height: 45px; border-radius: 50%;
            border: 3px solid transparent; cursor: pointer;
        }
        .color-btn:hover { transform: scale(1.15); }
        .color-btn.selected { border-color: #fff; box-shadow: 0 0 15px rgba(255, 255, 255, 0.6); }
        .color-btn.blue { background: linear-gradient(135deg, #3a7bd5, #2a5aa5); }
        .color-btn.pink { background: linear-gradient(135deg, #d53a7b, #a52a5a); }
        .color-label { color: #888; font-size: 12px; }
        .hidden { display: none !important; }
        #touchControls {
            display: none; position: fixed; bottom: 0; left: 0; right: 0;
            height: 200px; pointer-events: none; z-index: 100;
        }
        #joystickArea {
            position: absolute; left: 20px; bottom: 20px; width: 130px; height: 130px;
            background: rgba(255, 255, 255, 0.1); border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%; pointer-events: auto; touch-action: none;
        }
        #joystickKnob {
            position: absolute; width: 55px; height: 55px;
            background: rgba(100, 170, 255, 0.6); border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%; left: 50%; top: 50%; transform: translate(-50%, -50%);
        }
        #fireButton {
            position: absolute; right: 20px; bottom: 40px; width: 90px; height: 90px;
            background: rgba(255, 70, 70, 0.5); border: 3px solid rgba(255, 100, 100, 0.7);
            border-radius: 50%; pointer-events: auto; touch-action: none;
            display: flex; justify-content: center; align-items: center;
            color: #fff; font-size: 14px; font-weight: bold;
        }
        #switchWeaponBtn {
            position: absolute; right: 120px; bottom: 55px; width: 55px; height: 55px;
            background: rgba(100, 200, 100, 0.5); border: 3px solid rgba(100, 255, 100, 0.7);
            border-radius: 50%; pointer-events: auto; touch-action: none;
            display: flex; justify-content: center; align-items: center;
            color: #fff; font-size: 11px; font-weight: bold;
        }
        #pauseBtn {
            position: absolute; right: 20px; bottom: 145px; width: 50px; height: 50px;
            background: rgba(255, 200, 50, 0.5); border: 3px solid rgba(255, 220, 100, 0.7);
            border-radius: 50%; pointer-events: auto; touch-action: none;
            display: flex; justify-content: center; align-items: center;
            color: #fff; font-size: 20px; font-weight: bold;
        }
        #pauseOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); display: none; justify-content: center;
            align-items: center; flex-direction: column; z-index: 200;
        }
        #pauseOverlay.show { display: flex; }
        #pauseOverlay h2 { color: #ffd700; font-size: 36px; margin-bottom: 20px; }
        .pause-btn {
            padding: 12px 30px; font-size: 16px; margin: 10px;
            background: linear-gradient(135deg, #4a6cf7, #6a4cf7);
            color: #fff; border: none; border-radius: 25px; cursor: pointer;
        }
        .pause-btn:hover { transform: scale(1.05); }
        .pause-btn.quit { background: linear-gradient(135deg, #f74a4a, #f76a4a); }
        .leaderboard { margin: 15px 0; max-height: 180px; overflow-y: auto; }
        .leaderboard h3 { color: #ffd700; margin-bottom: 10px; font-size: 16px; }
        .leaderboard-list { list-style: none; padding: 0; margin: 0; }
        .leaderboard-list li {
            display: flex; justify-content: space-between; padding: 5px 15px;
            background: rgba(255, 255, 255, 0.05); margin: 3px 0; border-radius: 5px; font-size: 13px;
        }
        .leaderboard-list li:nth-child(1) { background: rgba(255, 215, 0, 0.2); color: #ffd700; }
        .leaderboard-list li:nth-child(2) { background: rgba(192, 192, 192, 0.2); color: #c0c0c0; }
        .leaderboard-list li:nth-child(3) { background: rgba(205, 127, 50, 0.2); color: #cd7f32; }
        .leaderboard-list .rank { width: 25px; font-weight: bold; }
        .leaderboard-list .name { flex: 1; text-align: left; margin-left: 10px; }
        .leaderboard-list .score { font-weight: bold; }
                #bossHealthContainer {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            width: 300px; display: none; flex-direction: column; align-items: center;
        }
        #bossHealthContainer.show { display: flex; }
        #bossName { color: #ff4444; font-size: 14px; font-weight: bold; margin-bottom: 5px; text-shadow: 0 0 10px #ff0000; }
        #bossHealthBar {
            width: 100%; height: 20px; background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff4444; border-radius: 10px; overflow: hidden;
        }
        #bossHealthFill {
            height: 100%; background: linear-gradient(90deg, #ff0000, #ff4444, #ff6666);
            transition: width 0.2s; width: 100%;
        }
        #bossTaunt {
            position: absolute; top: 120px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8); color: #ff6666; padding: 10px 20px;
            border-radius: 10px; font-size: 16px; font-weight: bold; display: none;
            border: 2px solid #ff4444; text-align: center; max-width: 80%;
            animation: tauntPulse 0.5s ease-in-out;
        }
        #bossTaunt.show { display: block; }
        @keyframes tauntPulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
        }
        #touchControls.show { display: block; }
        /* Live Players Sidebar */
        #livePlayersSidebar {
            position: absolute; top: 60px; right: 10px; width: 180px;
            background: rgba(0, 0, 0, 0.8); border: 2px solid rgba(100, 170, 255, 0.5);
            border-radius: 10px; padding: 10px; display: none; z-index: 50;
            max-height: 400px; overflow-y: auto;
        }
        #livePlayersSidebar.show { display: block; }
        #livePlayersSidebar h4 { color: #6af; font-size: 12px; margin-bottom: 8px; text-align: center; }
        .live-player {
            display: flex; flex-direction: column; padding: 6px 8px; margin: 4px 0;
            border-radius: 6px; font-size: 11px; background: rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
        }
        .live-player.you { background: rgba(100, 170, 255, 0.2); border: 1px solid #6af; }
        .live-player.boss-defeated { background: rgba(255, 215, 0, 0.15); border: 1px solid #ffd700; }
        .live-player.action-flash { animation: actionFlash 0.4s ease-in-out 1; }
        .live-player.dying { animation: deathAnimation 3s ease-out forwards; }
        .live-player .player-row { display: flex; align-items: center; justify-content: space-between; }
        .live-player .player-info { display: flex; align-items: center; flex: 1; min-width: 0; }
        .live-player .player-name { color: #fff; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .live-player .player-score { color: #4ade80; font-weight: bold; margin-left: 5px; }
        .live-player .player-status { width: 8px; height: 8px; border-radius: 50%; margin-right: 5px; flex-shrink: 0; }
        .live-player .player-status.lobby { background: #facc15; }
        .live-player .player-status.playing { background: #4ade80; }
        .live-player .player-status.boss { background: #ef4444; animation: pulse 1s infinite; }
        .live-player .player-status.dead { background: #666; }
        .live-player .player-action { display: flex; align-items: center; margin-top: 3px; font-size: 10px; color: #aaa; }
        .live-player .action-emoji { margin-right: 4px; font-size: 12px; }
        .live-player .action-text { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .live-player .player-meta { display: flex; justify-content: space-between; margin-top: 3px; font-size: 9px; color: #888; }
        .live-player .player-timer { color: #6af; }
        .live-player .player-level { color: #facc15; }
        .live-player .watch-btn {
            background: rgba(100, 170, 255, 0.3); border: 1px solid #6af; color: #6af;
            padding: 2px 6px; border-radius: 3px; font-size: 9px; cursor: pointer; margin-top: 4px;
        }
        .live-player .watch-btn:hover { background: rgba(100, 170, 255, 0.5); }
        .live-player .spectator-count { font-size: 9px; color: #888; margin-left: auto; }
        @keyframes actionFlash { 0%, 100% { background: rgba(255, 255, 255, 0.05); } 50% { background: rgba(100, 255, 100, 0.4); } }
        @keyframes deathAnimation {
            0% { background: rgba(255, 50, 50, 0.6); opacity: 1; }
            10% { background: rgba(255, 255, 255, 0.1); }
            20% { background: rgba(255, 50, 50, 0.6); }
            30% { background: rgba(255, 255, 255, 0.1); }
            40% { background: rgba(255, 50, 50, 0.6); }
            50% { background: rgba(255, 255, 255, 0.1); opacity: 1; }
            100% { background: rgba(100, 100, 100, 0.2); opacity: 0; }
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        /* Spectator Mode Styles - Multiple resizable PiP windows */
        .spectator-window {
            display: flex; flex-direction: column; position: fixed; z-index: 500;
            background: rgba(0, 0, 0, 0.95); border: 2px solid #4a6cf7; border-radius: 10px;
            font-family: Arial, sans-serif; min-width: 200px; min-height: 180px;
            resize: both; overflow: hidden;
        }
        .spectator-window .spec-header {
            display: flex; align-items: center; justify-content: space-between; padding: 6px 10px;
            background: rgba(74, 108, 247, 0.3); border-bottom: 1px solid #4a6cf7;
            cursor: move; flex-shrink: 0; user-select: none;
        }
        .spectator-window .spec-title { color: #6af; font-weight: bold; font-size: 12px; }
        .spectator-window .spec-info { color: #aaa; font-size: 10px; margin-left: 8px; }
        .spectator-window .spec-close {
            padding: 2px 8px; font-size: 14px; background: rgba(255, 100, 100, 0.3);
            border: 1px solid #f66; border-radius: 4px; color: #f66; cursor: pointer; line-height: 1;
        }
        .spectator-window .spec-close:hover { background: rgba(255, 100, 100, 0.5); }
        .spectator-window .spec-canvas-container {
            flex: 1; display: flex; justify-content: center; align-items: center;
            background: #000; overflow: hidden;
        }
        .spectator-window .spec-canvas { width: 100%; height: 100%; background: #000; }
        .spectator-window .spec-stats {
            display: flex; justify-content: space-around; padding: 4px 8px;
            background: rgba(0, 0, 0, 0.5); border-top: 1px solid #333; font-size: 10px; flex-shrink: 0;
        }
        .spectator-window .spec-stat { color: #aaa; }
        .spectator-window .spec-stat span { color: #fff; font-weight: bold; }
        /* Container for all spectator windows */
        #spectatorContainer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 499; }
        #spectatorContainer .spectator-window { pointer-events: auto; }
        /* Modal Styles */
        .modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); display: none; justify-content: center;
            align-items: center; z-index: 300; border-radius: 8px;
        }
        .modal-overlay.show { display: flex; }
        .modal {
            background: linear-gradient(135deg, #1a1a3e, #2a2a4e); border: 2px solid #4a6cf7;
            border-radius: 15px; padding: 25px; max-width: 350px; width: 90%;
            text-align: center; box-shadow: 0 0 30px rgba(100, 100, 255, 0.4);
        }
        .modal h2 { color: #6af; margin-bottom: 20px; font-size: 22px; }
        .modal-section { margin: 15px 0; }
        .modal-section label { color: #aaa; font-size: 12px; display: block; margin-bottom: 8px; }
        #playerNameInput {
            padding: 10px 15px; font-size: 14px; border: 2px solid #4a6cf7; border-radius: 8px;
            background: rgba(0, 0, 0, 0.5); color: #fff; text-align: center; width: 100%;
        }
        #playerNameInput::placeholder { color: #666; }
        #playerNameInput:focus { outline: none; border-color: #6af; }
        .modal .color-select { margin: 10px 0; }
        .modal .difficulty-btns { flex-wrap: wrap; }
        .modal .diff-btn { margin: 3px; padding: 8px 15px; font-size: 12px; }
        .modal-btn {
            padding: 12px 30px; font-size: 16px; margin-top: 15px;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: #000; border: none; border-radius: 25px; cursor: pointer; font-weight: bold;
        }
        .modal-btn:hover { transform: scale(1.05); }
        /* Instructions Modal */
        #instructionsModal .modal { max-width: 400px; }
        #instructionsModal .instructions-content { text-align: left; color: #ccc; font-size: 13px; line-height: 1.8; }
        #instructionsModal .instructions-content p { margin: 8px 0; }
        #instructionsModal .key { background: #4a6cf7; color: #fff; padding: 2px 8px; border-radius: 4px; font-size: 11px; }
        #instructionsModal .pickup { color: #6af; }
        .close-modal {
            padding: 10px 25px; font-size: 14px; margin-top: 15px;
            background: #555; color: #fff; border: none; border-radius: 20px; cursor: pointer;
        }
        .close-modal:hover { background: #666; }
        /* Start screen buttons */
        .start-buttons { display: flex; gap: 10px; margin: 15px 0; }
        .btn-secondary {
            padding: 10px 20px; font-size: 14px; background: transparent;
            border: 2px solid #6af; color: #6af; border-radius: 25px; cursor: pointer;
        }
        .btn-secondary:hover { background: rgba(100, 170, 255, 0.2); }
        /* Lobby sidebar (same style as game sidebar) */
        #lobbySidebar {
            position: absolute; top: 60px; left: 10px; width: 160px;
            background: rgba(0, 0, 0, 0.7); border: 2px solid rgba(100, 170, 255, 0.5);
            border-radius: 10px; padding: 10px; z-index: 50;
        }
        #lobbySidebar h4 { color: #6af; font-size: 12px; margin-bottom: 8px; text-align: center; }
        #lobbySidebar .player-count { color: #4ade80; font-size: 10px; text-align: center; margin-bottom: 5px; }
        @media (max-width: 850px) {
            #gameCanvas { max-width: 100vw; max-height: 65vh; }
            #startScreen h1, #gameOverScreen h1 { font-size: 26px; }
            .diff-btn { padding: 8px 14px; font-size: 12px; }
            #livePlayersSidebar { width: 140px; top: 50px; right: 5px; padding: 6px; max-height: 300px; }
            #livePlayersSidebar h4 { font-size: 10px; }
            #lobbySidebar { width: 140px; top: 50px; left: 5px; padding: 6px; }
            #lobbySidebar h4 { font-size: 10px; }
            .live-player { font-size: 9px; padding: 4px 5px; }
            .live-player .player-action { font-size: 8px; }
            .live-player .player-meta { font-size: 8px; }
            .live-player .watch-btn { font-size: 8px; padding: 2px 4px; }
            .leaderboard { max-height: 120px; }
            .leaderboard-list li { font-size: 11px; padding: 4px 10px; }
            #bossHealthContainer { width: 200px; }
            #bossTaunt { font-size: 12px; }
            .modal { padding: 20px; max-width: 300px; }
            .modal h2 { font-size: 18px; }
            .modal .diff-btn { padding: 6px 12px; font-size: 11px; }
            .start-buttons { flex-direction: column; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">
            <div class="ui-left">
                <span>Score: <span id="score">0</span></span>
                <span id="levelDisplay">Level 1</span>
                <span id="difficultyDisplay">EASY</span>
            </div>
            <div class="ui-center">
                <button id="muteButton" onclick="toggleMute()">üîä</button>
                <button id="quitButton" onclick="quitGame()">QUIT</button>
                <span id="weaponDisplay">PISTOL [Q]</span>
            </div>
            <div class="ui-right">
                <span>Lives: <span id="lives">3</span></span>
            </div>
        </div>
        <div id="bossHealthContainer">
            <span id="bossName">BOSS NAME</span>
            <div id="bossHealthBar"><div id="bossHealthFill"></div></div>
        </div>
        <div id="bossTaunt"></div>
        <div id="livePlayersSidebar">
            <h4>üéÆ LIVE PLAYERS</h4>
            <div id="sidebarPlayersList"></div>
        </div>
        <div id="lobbySidebar">
            <h4>üéÆ PLAYERS ONLINE</h4>
            <div class="player-count" id="playerCount">0 players</div>
            <div id="lobbyPlayersList"></div>
        </div>
        <div id="startScreen">
            <h1>Legion's Space Fight</h1>
            <div class="start-buttons">
                <button class="btn" onclick="openSetupModal()">Play Game</button>
                <button class="btn-secondary" onclick="openInstructionsModal()">How to Play</button>
            </div>
            <div class="leaderboard" id="startLeaderboard">
                <h3>üèÜ High Scores</h3>
                <ul class="leaderboard-list" id="startLeaderboardList"></ul>
            </div>
        </div>
        <!-- Setup Modal -->
        <div id="setupModal" class="modal-overlay">
            <div class="modal">
                <h2>Game Setup</h2>
                <div class="modal-section">
                    <label>Your Name (or leave blank for random)</label>
                    <input type="text" id="playerNameInput" maxlength="12" placeholder="Enter name...">
                </div>
                <div class="modal-section">
                    <label>Choose Your Jet</label>
                    <div class="color-select">
                        <button class="color-btn blue selected" onclick="selectColor('blue')"></button>
                        <button class="color-btn pink" onclick="selectColor('pink')"></button>
                    </div>
                </div>
                <div class="modal-section">
                    <label>Select Difficulty</label>
                    <div class="difficulty-btns">
                        <button class="diff-btn easy selected" onclick="selectDifficulty('easy')">EASY</button>
                        <button class="diff-btn medium" onclick="selectDifficulty('medium')">MEDIUM</button>
                        <button class="diff-btn hard" onclick="selectDifficulty('hard')">HARD</button>
                        <button class="diff-btn expert" onclick="selectDifficulty('expert')">EXPERT</button>
                    </div>
                </div>
                <button class="modal-btn" onclick="startGame()">Start Game</button>
            </div>
        </div>
        <!-- Instructions Modal -->
        <div id="instructionsModal" class="modal-overlay">
            <div class="modal">
                <h2>How to Play</h2>
                <div class="instructions-content">
                    <p><span class="key">WASD</span> or <span class="key">Arrows</span> - Move your jet</p>
                    <p><span class="key">Space</span> - Shoot</p>
                    <p><span class="key">Q</span> - Swap weapon</p>
                    <p><span class="key">P</span> or <span class="key">ESC</span> - Pause</p>
                    <p style="margin-top: 15px; color: #6af;">Collect power-ups:</p>
                    <p><span class="pickup">MG</span> - Machine Gun</p>
                    <p><span class="pickup">BZ</span> - Bazooka</p>
                    <p><span class="pickup">LS</span> - Laser Beam</p>
                    <p style="margin-top: 15px; color: #ffd700;">Defeat bosses to advance levels!</p>
                </div>
                <button class="close-modal" onclick="closeInstructionsModal()">Got it!</button>
            </div>
        </div>
        <div id="gameOverScreen" class="hidden">
            <h2>Game Over</h2>
            <h1>Score: <span id="finalScore">0</span></h1>
            <p style="color: #aaa; margin-bottom: 10px;">Level <span id="finalLevel">1</span> | <span id="finalDifficulty">EASY</span></p>
            <p id="scoreSavedMsg" style="color: #4ade80; margin-bottom: 10px; display: none;"></p>
            <div class="leaderboard" id="gameOverLeaderboard">
                <h3>üèÜ High Scores</h3>
                <ul class="leaderboard-list" id="gameOverLeaderboardList"></ul>
            </div>
            <button class="btn" onclick="startGame()">Play Again</button>
            <button class="btn" style="background: #555;" onclick="backToMenu()">Menu</button>
        </div>
        <div id="pauseOverlay">
            <h2>PAUSED</h2>
            <button class="pause-btn" onclick="resumeGame()">Resume</button>
            <button class="pause-btn quit" onclick="quitFromPause()">Quit Game</button>
        </div>
    </div>
    <div id="touchControls">
        <div id="joystickArea"><div id="joystickKnob"></div></div>
        <div id="pauseBtn" onclick="togglePause()">‚è∏</div>
        <div id="switchWeaponBtn">SWAP</div>
        <div id="fireButton">FIRE</div>
    </div>

    <!-- Container for multiple spectator windows -->
    <div id="spectatorContainer"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const logicalWidth = 800;
        const logicalHeight = 600;
        const scaleFactor = Math.min(dpr, 2);
        canvas.width = logicalWidth * scaleFactor;
        canvas.height = logicalHeight * scaleFactor;
        canvas.style.width = logicalWidth + 'px';
        canvas.style.height = logicalHeight + 'px';
        ctx.scale(scaleFactor, scaleFactor);

        let lastFrameTime = performance.now();
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let backgroundMusic = null;
        let isMuted = false;

        // === LEADERBOARD SYSTEM (Server-side JSON) ===
        const API_BASE = window.location.origin;
        const MAX_LEADERBOARD_SIZE = 10;
        let cachedLeaderboard = [];

        async function fetchLeaderboard() {
            try {
                const url = `${API_BASE}/api/leaderboard`;
                const response = await fetch(url);
                if (response.ok) {
                    const text = await response.text();
                    try {
                        cachedLeaderboard = JSON.parse(text);
                    } catch (parseErr) {
                        console.error('Failed to parse leaderboard JSON:', text.substring(0, 100));
                        return cachedLeaderboard;
                    }
                    return cachedLeaderboard;
                } else {
                    console.error('Leaderboard fetch failed:', response.status, response.statusText);
                }
            } catch (e) { console.error('Failed to fetch leaderboard:', e); }
            return cachedLeaderboard;
        }

        function isHighScore(newScore) {
            if (cachedLeaderboard.length < MAX_LEADERBOARD_SIZE) return true;
            return newScore > cachedLeaderboard[cachedLeaderboard.length - 1].score;
        }

        async function addHighScore(name, newScore, difficulty, lvl, duration = 0) {
            try {
                const url = `${API_BASE}/api/leaderboard`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, score: newScore, difficulty, level: lvl, duration: duration })
                });
                if (response.ok) {
                    const text = await response.text();
                    try {
                        const data = JSON.parse(text);
                        cachedLeaderboard = data.leaderboard || [];
                        console.log('Score saved successfully:', cachedLeaderboard);
                    } catch (parseErr) {
                        console.error('Failed to parse save response:', text.substring(0, 100));
                    }
                    return cachedLeaderboard;
                } else {
                    console.error('Save score failed:', response.status, response.statusText);
                }
            } catch (e) { console.error('Failed to save score:', e); }
            return cachedLeaderboard;
        }

        function renderLeaderboardFromCache(listElementId) {
            const listEl = document.getElementById(listElementId);
            if (!listEl) {
                console.error('Leaderboard element not found:', listElementId);
                return;
            }
            if (!cachedLeaderboard || cachedLeaderboard.length === 0) {
                listEl.innerHTML = '<li style="justify-content: center; color: #666;">No scores yet</li>';
                return;
            }
            // Show top 10
            const top10 = cachedLeaderboard.slice(0, 10);
            listEl.innerHTML = top10.map((entry, i) =>
                `<li><span class="rank">${i + 1}.</span><span class="name">${entry.name}</span><span class="score">${entry.score.toLocaleString()}</span></li>`
            ).join('');
        }

        async function renderLeaderboard(listElementId) {
            await fetchLeaderboard();
            renderLeaderboardFromCache(listElementId);
        }

        // === LIVE PLAYERS SYSTEM ===
        let myPlayerId = null;
        let myPlayerName = '';
        let mySessionId = null;
        let livePlayers = [];
        let playerPollInterval = null;
        let gameStartTime = null;
        let gameDuration = 0;
        const playerActionTimes = new Map(); // Track action times for flash animation
        const playerDeathTimes = new Map(); // Track death times for delayed removal
        let mySpectatorCount = 0; // Track how many people are watching me

        // Load saved player name from localStorage
        function loadSavedPlayerName() {
            const saved = localStorage.getItem('playerName');
            if (saved) {
                myPlayerName = saved;
                const nameInput = document.getElementById('playerNameInput');
                if (nameInput) nameInput.value = saved;
            }
        }

        // Save player name to localStorage
        function savePlayerName(name) {
            if (name) {
                localStorage.setItem('playerName', name);
                myPlayerName = name;
            }
        }

        async function joinAsPlayer() {
            const nameInput = document.getElementById('playerNameInput');
            // Use entered name, or fall back to saved name
            const enteredName = nameInput ? nameInput.value.trim() : '';
            const nameToUse = enteredName || localStorage.getItem('playerName') || '';

            try {
                const response = await fetch(`${API_BASE}/api/players/join`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: nameToUse,
                        difficulty: selectedDifficulty.toUpperCase(),
                        color: selectedColor
                    })
                });
                if (response.ok) {
                    const data = await response.json();
                    myPlayerId = data.playerId;
                    myPlayerName = data.name;
                    // Save the name (especially important for random names)
                    savePlayerName(data.name);
                    livePlayers = data.players || [];
                    console.log('Joined as:', myPlayerName, 'ID:', myPlayerId);
                    return true;
                }
            } catch (e) { console.error('Failed to join as player:', e); }
            return false;
        }

        async function updatePlayerStatus(status) {
            if (!myPlayerId) return;
            // Update game duration
            if (gameStartTime) {
                gameDuration = Math.floor((Date.now() - gameStartTime) / 1000);
            }
            try {
                const response = await fetch(`${API_BASE}/api/players/update`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        playerId: myPlayerId,
                        score: score,
                        level: level,
                        status: status,
                        difficulty: selectedDifficulty.toUpperCase(),
                        gameDuration: gameDuration,
                        shieldActive: shieldActive,
                        currentWeapon: currentWeapon,
                        bossHealth: boss ? Math.floor((boss.health / boss.maxHealth) * 100) : null
                    })
                });
                if (response.ok) {
                    const data = await response.json();
                    livePlayers = data.players || [];
                    renderLivePlayers();
                }
            } catch (e) { console.error('Failed to update player status:', e); }
        }

        async function reportAction(action, details = null) {
            if (!myPlayerId) return;
            try {
                await fetch(`${API_BASE}/api/players/action`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        playerId: myPlayerId,
                        sessionId: mySessionId,
                        action: action,
                        details: details
                    })
                });
            } catch (e) { console.error('Failed to report action:', e); }
        }

        async function startGameSession() {
            try {
                const response = await fetch(`${API_BASE}/api/players/start-session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: myPlayerName,
                        difficulty: selectedDifficulty.toUpperCase()
                    })
                });
                if (response.ok) {
                    const data = await response.json();
                    mySessionId = data.sessionId;
                }
            } catch (e) { console.error('Failed to start session:', e); }
        }

        async function endGameSession(deathReason) {
            if (!mySessionId) return;
            try {
                await fetch(`${API_BASE}/api/players/end-session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: mySessionId,
                        score: score,
                        level: level,
                        duration: gameDuration,
                        deathReason: deathReason,
                        bossesDefeated: bossDefeated.length
                    })
                });
            } catch (e) { console.error('Failed to end session:', e); }
            mySessionId = null;
        }

        async function leaveAsPlayer() {
            if (!myPlayerId) return;
            try {
                await fetch(`${API_BASE}/api/players/leave`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ playerId: myPlayerId })
                });
            } catch (e) { console.error('Failed to leave:', e); }
            myPlayerId = null;
        }

        // Game state broadcasting for spectators
        let lastBroadcastTime = 0;
        const BROADCAST_INTERVAL = 150; // ms between broadcasts

        async function broadcastGameState() {
            if (!myPlayerId || mySpectatorCount === 0) return;
            if (!gameRunning || lives <= 0) return;

            const now = Date.now();
            if (now - lastBroadcastTime < BROADCAST_INTERVAL) return;
            lastBroadcastTime = now;

            const state = {
                player: { x: player.x, y: player.y, width: player.width, height: player.height },
                enemies: enemies.map(e => ({ x: e.x, y: e.y, width: e.width, height: e.height, weapon: e.weapon, color: e.color })),
                bullets: bullets.map(b => ({ x: b.x, y: b.y, isEnemy: b.isEnemy, type: b.type, color: b.color })),
                boss: boss ? { x: boss.x, y: boss.y, width: boss.width, height: boss.height, health: boss.health, maxHealth: boss.maxHealth, phase: boss.phase } : null,
                powerups: powerups.map(p => ({ x: p.x, y: p.y })),
                bombs: bombs.map(b => ({ x: b.x, y: b.y })),
                walls: walls.map(w => ({ x: w.x, y: w.y, width: w.width, height: w.height, gapY: w.gapY, gapHeight: w.gapHeight })),
                score: score,
                level: level,
                lives: lives,
                shieldActive: shieldActive,
                currentWeapon: currentWeapon,
                bossActive: bossActive,
                gameDuration: gameDuration
            };

            try {
                await fetch(`${API_BASE}/api/players/gamestate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ playerId: myPlayerId, state })
                });
            } catch (e) { /* Silently ignore broadcast errors */ }
        }

        async function fetchActivePlayers() {
            try {
                const response = await fetch(`${API_BASE}/api/players/active`);
                if (response.ok) {
                    livePlayers = await response.json();

                    // Filter out dead players after death animation completes (3 seconds)
                    const DEAD_DISPLAY_DURATION = 3000;
                    livePlayers = livePlayers.filter(p => {
                        if (p.status !== 'dead') return true;
                        const deathTime = playerDeathTimes.get(p.id);
                        if (!deathTime) return true; // First time seeing this dead player
                        return Date.now() - deathTime < DEAD_DISPLAY_DURATION;
                    });

                    // Clean up old death times
                    for (const [id, time] of playerDeathTimes) {
                        if (Date.now() - time > DEAD_DISPLAY_DURATION * 2) {
                            playerDeathTimes.delete(id);
                        }
                    }

                    // Update my spectator count for broadcasting
                    const myPlayer = livePlayers.find(p => p.id === myPlayerId);
                    mySpectatorCount = myPlayer ? (parseInt(myPlayer.spectatorCount) || 0) : 0;

                    renderLivePlayers();
                    renderLobbyPlayers();
                }
            } catch (e) { console.error('Failed to fetch active players:', e); }
        }

        function formatDuration(seconds) {
            if (!seconds || seconds < 0) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function renderLivePlayers() {
            const sidebar = document.getElementById('sidebarPlayersList');
            if (!sidebar) return;
            if (livePlayers.length === 0) {
                sidebar.innerHTML = '<div style="color: #666; font-size: 10px; text-align: center;">No players</div>';
                return;
            }
            sidebar.innerHTML = livePlayers.map(p => {
                const isYou = p.id === myPlayerId;
                const classes = ['live-player'];
                if (isYou) classes.push('you');
                if (p.defeatedBoss) classes.push('boss-defeated');

                // Action-based flash: only flash when lastActionTime changes
                const prevActionTime = playerActionTimes.get(p.id);
                const hasNewAction = prevActionTime && p.lastActionTime && p.lastActionTime !== prevActionTime;
                playerActionTimes.set(p.id, p.lastActionTime);
                if (hasNewAction) classes.push('action-flash');

                // Dead player handling: flash red then track for removal
                if (p.status === 'dead') {
                    if (!playerDeathTimes.has(p.id)) {
                        playerDeathTimes.set(p.id, Date.now());
                    }
                    classes.push('dying');
                } else {
                    playerDeathTimes.delete(p.id);
                }

                const actionText = p.lastAction ? p.lastAction.replace(/_/g, ' ') : '';
                const duration = parseInt(p.gameDuration) || 0;
                const spectatorCount = parseInt(p.spectatorCount) || 0;

                return `<div class="${classes.join(' ')}">
                    <div class="player-row">
                        <div class="player-info">
                            <span class="player-status ${p.status || 'lobby'}"></span>
                            <span class="player-name">${p.name}${isYou ? ' (you)' : ''}</span>
                        </div>
                        <span class="player-score">${(parseInt(p.score) || 0).toLocaleString()}</span>
                    </div>
                    ${p.lastActionEmoji ? `<div class="player-action">
                        <span class="action-emoji">${p.lastActionEmoji}</span>
                        <span class="action-text">${actionText}</span>
                    </div>` : ''}
                    <div class="player-meta">
                        <span class="player-level">Lv.${p.level || 1}</span>
                        <span class="player-timer">‚è±Ô∏è ${formatDuration(duration)}</span>
                    </div>
                    ${!isYou && p.status === 'playing' ? `<button class="watch-btn" onclick="spectatePlayer('${p.id}')">üëÅÔ∏è Watch${spectatorCount > 0 ? ` (${spectatorCount})` : ''}</button>` : ''}
                </div>`;
            }).join('');
        }

        function renderLobbyPlayers() {
            const lobby = document.getElementById('lobbyPlayersList');
            const countEl = document.getElementById('playerCount');
            if (!lobby || !countEl) return;

            countEl.textContent = `${livePlayers.length} player${livePlayers.length !== 1 ? 's' : ''} online`;

            if (livePlayers.length === 0) {
                lobby.innerHTML = '<div style="color: #666; font-size: 10px; text-align: center; padding: 5px;">No players online</div>';
                return;
            }
            lobby.innerHTML = livePlayers.map(p => {
                const isYou = p.id === myPlayerId;
                const classes = ['live-player'];
                if (isYou) classes.push('you');
                if (p.defeatedBoss) classes.push('boss-defeated');

                // Action-based flash: only flash when lastActionTime changes
                const prevActionTime = playerActionTimes.get(p.id);
                const hasNewAction = prevActionTime && p.lastActionTime && p.lastActionTime !== prevActionTime;
                playerActionTimes.set(p.id, p.lastActionTime);
                if (hasNewAction) classes.push('action-flash');

                // Dead player handling
                if (p.status === 'dead') {
                    if (!playerDeathTimes.has(p.id)) {
                        playerDeathTimes.set(p.id, Date.now());
                    }
                    classes.push('dying');
                } else {
                    playerDeathTimes.delete(p.id);
                }

                const spectatorCount = parseInt(p.spectatorCount) || 0;

                return `<div class="${classes.join(' ')}">
                    <div class="player-row">
                        <div class="player-info">
                            <span class="player-status ${p.status || 'lobby'}"></span>
                            <span class="player-name">${p.name}${isYou ? ' (you)' : ''}</span>
                        </div>
                        <span class="player-score">${(parseInt(p.score) || 0).toLocaleString()}</span>
                    </div>
                    ${p.lastActionEmoji ? `<div class="player-action">
                        <span class="action-emoji">${p.lastActionEmoji}</span>
                        <span class="action-text">${p.lastAction ? p.lastAction.replace(/_/g, ' ') : ''}</span>
                    </div>` : ''}
                    ${!isYou && p.status === 'playing' ? `<button class="watch-btn" onclick="spectatePlayer('${p.id}')">üëÅÔ∏è Watch${spectatorCount > 0 ? ` (${spectatorCount})` : ''}</button>` : ''}
                </div>`;
            }).join('');
        }

        function startPlayerPolling() {
            if (playerPollInterval) clearInterval(playerPollInterval);
            playerPollInterval = setInterval(() => {
                if (gameRunning && !gamePaused) {
                    updatePlayerStatus(bossActive ? 'boss' : 'playing');
                }
            }, 1500);
        }

        function stopPlayerPolling() {
            if (playerPollInterval) {
                clearInterval(playerPollInterval);
                playerPollInterval = null;
            }
        }

        // === SPECTATOR MODE - Multiple Windows ===
        const spectatorWindows = new Map(); // playerId -> window data
        let spectatorWindowCount = 0;

        function spectatePlayer(playerId) {
            // Check if already watching this player
            if (spectatorWindows.has(playerId)) {
                return; // Already watching
            }

            const player = livePlayers.find(p => p.id === playerId);
            if (!player) return;

            // Create new spectator window
            const windowId = 'spec-' + (++spectatorWindowCount);
            const windowData = createSpectatorWindow(windowId, playerId, player);
            spectatorWindows.set(playerId, windowData);

            // Start polling for this window
            startSpectatorPolling(playerId, windowData);
        }

        function createSpectatorWindow(windowId, playerId, player) {
            const container = document.getElementById('spectatorContainer');
            const offset = spectatorWindows.size * 30; // Offset each new window

            const windowEl = document.createElement('div');
            windowEl.className = 'spectator-window';
            windowEl.id = windowId;
            windowEl.style.cssText = `bottom: ${20 + offset}px; right: ${20 + offset}px; width: 320px; height: 280px;`;

            windowEl.innerHTML = `
                <div class="spec-header">
                    <div>
                        <span class="spec-title">${player.name}</span>
                        <span class="spec-info">${player.difficulty || 'EASY'} | Lv.${player.level || 1}</span>
                    </div>
                    <button class="spec-close" onclick="closeSpectatorWindow('${playerId}')">‚úï</button>
                </div>
                <div class="spec-canvas-container">
                    <canvas class="spec-canvas" width="320" height="200"></canvas>
                </div>
                <div class="spec-stats">
                    <div class="spec-stat">Score: <span class="spec-score">0</span></div>
                    <div class="spec-stat">Lv: <span class="spec-level">1</span></div>
                    <div class="spec-stat">‚ù§Ô∏è <span class="spec-lives">3</span></div>
                </div>
            `;

            container.appendChild(windowEl);

            // Make window draggable
            makeDraggable(windowEl);

            // Get canvas context
            const canvas = windowEl.querySelector('.spec-canvas');
            const ctx = canvas.getContext('2d');

            return {
                windowId,
                playerId,
                element: windowEl,
                canvas,
                ctx,
                pollInterval: null
            };
        }

        function makeDraggable(el) {
            const header = el.querySelector('.spec-header');
            let isDragging = false;
            let startX, startY, startRight, startBottom;

            header.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('spec-close')) return;
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startRight = parseInt(el.style.right) || 20;
                startBottom = parseInt(el.style.bottom) || 20;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = startX - e.clientX;
                const dy = startY - e.clientY;
                el.style.right = Math.max(0, startRight + dx) + 'px';
                el.style.bottom = Math.max(0, startBottom + dy) + 'px';
            });

            document.addEventListener('mouseup', () => { isDragging = false; });
        }

        function startSpectatorPolling(playerId, windowData) {
            const spectatorId = myPlayerId || 'spec_' + Math.random().toString(36).substr(2, 8);

            windowData.pollInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE}/api/players/spectate/${playerId}?spectatorId=${spectatorId}`);
                    if (!response.ok) {
                        if (response.status === 404) {
                            renderSpectatorWindowMessage(windowData, 'Not playing');
                        }
                        return;
                    }
                    const data = await response.json();
                    if (data.state) {
                        renderSpectatorWindowGame(windowData, data.state);
                        updateSpectatorWindowStats(windowData, data.state);
                    }
                    if (data.player) {
                        const info = windowData.element.querySelector('.spec-info');
                        if (info) info.textContent = `${data.player.difficulty || 'EASY'} | Lv.${data.player.level || 1}`;
                    }
                } catch (e) { /* ignore */ }
            }, 150);

            // Initial poll
            fetch(`${API_BASE}/api/players/spectate/${playerId}?spectatorId=${spectatorId}`).catch(() => {});
        }

        function closeSpectatorWindow(playerId) {
            const windowData = spectatorWindows.get(playerId);
            if (!windowData) return;

            // Stop polling
            if (windowData.pollInterval) clearInterval(windowData.pollInterval);

            // Tell server we stopped watching
            const spectatorId = myPlayerId || 'spec_' + Math.random().toString(36).substr(2, 8);
            fetch(`${API_BASE}/api/players/spectate/${playerId}/leave`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ spectatorId })
            }).catch(() => {});

            // Remove element
            windowData.element.remove();
            spectatorWindows.delete(playerId);
        }

        function renderSpectatorWindowGame(windowData, state) {
            const { canvas, ctx } = windowData;
            const cw = canvas.width;
            const ch = canvas.height;
            const scaleX = cw / logicalWidth;
            const scaleY = ch / logicalHeight;

            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, cw, ch);

            // Stars
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 20; i++) {
                const x = (i * 47 + Date.now() * 0.01) % cw;
                const y = (i * 31) % ch;
                ctx.fillRect(x, y, 1, 1);
            }

            // Walls
            if (state.walls) {
                state.walls.forEach(w => {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(w.x * scaleX, w.y * scaleY, w.width * scaleX, w.gapY * scaleY);
                    ctx.fillRect(w.x * scaleX, (w.gapY + w.gapHeight) * scaleY, w.width * scaleX, (logicalHeight - w.gapY - w.gapHeight) * scaleY);
                });
            }

            // Bombs
            if (state.bombs) {
                ctx.fillStyle = '#ff4444';
                state.bombs.forEach(b => {
                    ctx.beginPath();
                    ctx.arc(b.x * scaleX, b.y * scaleY, 5, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // Bullets
            if (state.bullets) {
                state.bullets.forEach(b => {
                    ctx.fillStyle = b.isEnemy ? '#ff6666' : '#6af';
                    ctx.fillRect(b.x * scaleX - 1, b.y * scaleY - 3, 3, 6);
                });
            }

            // Enemies
            if (state.enemies) {
                state.enemies.forEach(e => {
                    ctx.fillStyle = e.color || '#f55';
                    const w = (e.width || 40) * scaleX;
                    const h = (e.height || 40) * scaleY;
                    ctx.fillRect(e.x * scaleX - w/2, e.y * scaleY - h/2, w, h);
                });
            }

            // Boss
            if (state.boss && state.bossActive) {
                ctx.fillStyle = '#ff00ff';
                const bw = (state.boss.width || 100) * scaleX;
                const bh = (state.boss.height || 80) * scaleY;
                ctx.fillRect(state.boss.x * scaleX - bw/2, state.boss.y * scaleY - bh/2, bw, bh);
                if (state.boss.health && state.boss.maxHealth) {
                    const hpRatio = state.boss.health / state.boss.maxHealth;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(5, 5, cw - 10, 4);
                    ctx.fillStyle = hpRatio > 0.3 ? '#ff00ff' : '#ff0000';
                    ctx.fillRect(5, 5, (cw - 10) * hpRatio, 4);
                }
            }

            // Player
            if (state.player) {
                const px = state.player.x * scaleX;
                const py = state.player.y * scaleY;
                const pw = (state.player.width || 50) * scaleX;
                const ph = (state.player.height || 50) * scaleY;

                if (state.shieldActive) {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(px, py, pw * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.fillStyle = '#6af';
                ctx.beginPath();
                ctx.moveTo(px, py - ph/2);
                ctx.lineTo(px - pw/2, py + ph/2);
                ctx.lineTo(px + pw/2, py + ph/2);
                ctx.closePath();
                ctx.fill();
            }
        }

        function renderSpectatorWindowMessage(windowData, msg) {
            const { canvas, ctx } = windowData;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(msg, canvas.width / 2, canvas.height / 2);
        }

        function updateSpectatorWindowStats(windowData, state) {
            const el = windowData.element;
            el.querySelector('.spec-score').textContent = (state.score || 0).toLocaleString();
            el.querySelector('.spec-level').textContent = state.level || 1;
            el.querySelector('.spec-lives').textContent = state.lives || 0;
        }

        // Close all spectator windows
        function closeAllSpectatorWindows() {
            for (const playerId of spectatorWindows.keys()) {
                closeSpectatorWindow(playerId);
            }
        }


        // Initialize leaderboard on page load
        document.addEventListener('DOMContentLoaded', () => {
            renderLeaderboard('startLeaderboardList');
            // Load saved player name from localStorage
            loadSavedPlayerName();
            // Start polling for lobby players
            fetchActivePlayers();
            setInterval(fetchActivePlayers, 3000);
        });

        // Leave on page unload
        window.addEventListener('beforeunload', () => {
            if (myPlayerId) {
                navigator.sendBeacon(`${API_BASE}/api/players/leave`, JSON.stringify({ playerId: myPlayerId }));
            }
        });

        // === DIFFICULTY SETTINGS (2x speed) ===
        const DIFFICULTIES = {
            easy: { name: 'EASY', speedMult: 1.6, spawnMult: 1.0, enemyFireMult: 1.4, lives: 5, color: '#4ade80' },
            medium: { name: 'MEDIUM', speedMult: 2.0, spawnMult: 0.7, enemyFireMult: 2.0, lives: 3, color: '#facc15' },
            hard: { name: 'HARD', speedMult: 2.6, spawnMult: 0.5, enemyFireMult: 3.0, lives: 2, color: '#f97316' },
            expert: { name: 'EXPERT', speedMult: 3.2, spawnMult: 0.35, enemyFireMult: 4.0, lives: 1, color: '#ef4444' }
        };
        let selectedDifficulty = 'easy';

        // === GAME STATE ===
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let lives = 3;
        let level = 1;
        const levelUpScore = 1000;
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 850;

        // === LEVEL SPEED MULTIPLIERS (2x base) ===
        const levelSpeeds = { 1: 1.0, 2: 1.2, 3: 1.4, 4: 1.6, 5: 1.8 };

        // === BACKGROUND OBJECTS ===
        let stars = [];
        let nebulae = [];
        let spaceObjects = []; // stations, planets, asteroids

        // === SHIELD ===
        let shieldActive = false;
        let shieldHits = 0;
        const shieldDuration = 5000;
        const shieldMaxHits = 3;
        let shieldStartTime = 0;

        // === BOSS SYSTEM ===
        let boss = null;
        let bossActive = false;
        let bossDefeated = [];
        let bossTauntTimer = 0;
        let bossMusic = null;

        const BOSSES = {
            1: {
                name: 'DARK PHANTOM',
                type: 'aircraft',
                health: 20, maxHealth: 20,
                width: 120, height: 80,
                speed: 150, fireRate: 0.8,
                color: '#8B0000',
                taunts: [
                    "You dare challenge me?",
                    "Pathetic human!",
                    "I will destroy you!",
                    "Is that all you've got?",
                    "You cannot escape!"
                ],
                attackPattern: 'spread'
            },
            2: {
                name: 'CYBER KRAKEN',
                type: 'monster',
                health: 30, maxHealth: 30,
                width: 150, height: 100,
                speed: 120, fireRate: 0.6,
                color: '#4B0082',
                taunts: [
                    "The void consumes all!",
                    "Your weapons are useless!",
                    "Feel my tentacles of doom!",
                    "No one survives the Kraken!",
                    "Surrender to darkness!"
                ],
                attackPattern: 'spiral'
            },
            3: {
                name: 'INFERNO TITAN',
                type: 'monster',
                health: 40, maxHealth: 40,
                width: 180, height: 120,
                speed: 100, fireRate: 0.5,
                color: '#FF4500',
                taunts: [
                    "BURN IN FLAMES!",
                    "I am eternal fire!",
                    "Your soul will fuel my power!",
                    "Witness true destruction!",
                    "Nothing survives my inferno!"
                ],
                attackPattern: 'wave'
            },
            4: {
                name: 'QUANTUM DESTROYER',
                type: 'aircraft',
                health: 50, maxHealth: 50,
                width: 200, height: 100,
                speed: 180, fireRate: 0.4,
                color: '#00CED1',
                taunts: [
                    "I exist in all dimensions!",
                    "Time is my weapon!",
                    "You cannot hit what phases!",
                    "Reality bends to my will!",
                    "Prepare for annihilation!"
                ],
                attackPattern: 'random'
            },
            5: {
                name: 'OMEGA OVERLORD',
                type: 'monster',
                health: 75, maxHealth: 75,
                width: 220, height: 140,
                speed: 130, fireRate: 0.3,
                color: '#FFD700',
                taunts: [
                    "I AM THE FINAL BOSS!",
                    "NO ONE HAS EVER DEFEATED ME!",
                    "YOUR JOURNEY ENDS HERE!",
                    "BOW BEFORE THE OVERLORD!",
                    "THIS IS YOUR DOOM!"
                ],
                attackPattern: 'all'
            }
        };

        // === WEAPONS ===
        const WEAPONS = {
            pistol: { name: 'PISTOL', fireRate: 150, color: '#00ffff' },
            machinegun: { name: 'MACHINE GUN', fireRate: 50, color: '#ffff00' },
            bazooka: { name: 'BAZOOKA', fireRate: 500, color: '#ff6600' },
            laser: { name: 'LASER BEAM', fireRate: 30, color: '#ff00ff' }
        };
        let currentWeapon = 'pistol';
        let unlockedWeapons = ['pistol'];
        let laserActive = false;

        const jetColors = {
            blue: { body: '#3a7bd5', wings: '#2a5aa5', cockpit: '#87ceeb' },
            pink: { body: '#d53a7b', wings: '#a52a5a', cockpit: '#f0b8d0' }
        };
        let selectedColor = 'blue';

        function selectColor(color) {
            selectedColor = color;
            document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector('.color-btn.' + color).classList.add('selected');
        }

        function selectDifficulty(diff) {
            selectedDifficulty = diff;
            document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector('.diff-btn.' + diff).classList.add('selected');
        }

        // Modal functions
        function openSetupModal() {
            document.getElementById('setupModal').classList.add('show');
        }

        function closeSetupModal() {
            document.getElementById('setupModal').classList.remove('show');
        }

        function openInstructionsModal() {
            document.getElementById('instructionsModal').classList.add('show');
        }

        function closeInstructionsModal() {
            document.getElementById('instructionsModal').classList.remove('show');
        }

        const player = {
            x: logicalWidth / 2, y: logicalHeight - 80,
            width: 50, height: 50, speed: 360, dx: 0, dy: 0
        };

        let bullets = [];
        let enemies = [];
        let particles = [];
        let powerups = [];
        let bombs = [];
        let walls = [];
        let weaponPickups = [];

        const keys = {};
        let touchMove = { x: 0, y: 0 };
        let joystickActive = false;
        let autoFire = false;
        let lastFireTime = 0;

        // === SOUNDS ===
        function playSound(freq, type, duration, gain = 0.3) {
            if (isMuted) return;
            const osc = audioContext.createOscillator();
            const g = audioContext.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioContext.currentTime);
            osc.connect(g);
            g.connect(audioContext.destination);
            g.gain.setValueAtTime(gain, audioContext.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            osc.start();
            osc.stop(audioContext.currentTime + duration);
        }

        function playPlayerLaser() { playSound(800, 'square', 0.1); }
        function playMachineGun() { playSound(200, 'sawtooth', 0.05, 0.2); }
        function playBazooka() { playSound(100, 'sawtooth', 0.3, 0.4); }
        function playLaserBeam() { playSound(1200, 'sine', 0.05, 0.15); }
        function playEnemyLaser() { playSound(300, 'sawtooth', 0.15, 0.2); }
        function playEnemyMachineGun() { playSound(250, 'square', 0.08, 0.15); }
        function playEnemyBazooka() { playSound(80, 'sawtooth', 0.25, 0.3); }
        function playExplosion() {
            if (isMuted) return;
            const bufferSize = audioContext.sampleRate * 0.3;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.2));
            const source = audioContext.createBufferSource();
            const g = audioContext.createGain();
            source.buffer = buffer;
            source.connect(g);
            g.connect(audioContext.destination);
            g.gain.setValueAtTime(0.3, audioContext.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            source.start();
        }
        function playBigExplosion() {
            if (isMuted) return;
            const bufferSize = audioContext.sampleRate * 0.6;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.3));
            const source = audioContext.createBufferSource();
            const g = audioContext.createGain();
            source.buffer = buffer;
            source.connect(g);
            g.connect(audioContext.destination);
            g.gain.setValueAtTime(0.5, audioContext.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
            source.start();
        }
        function playGameStart() {
            [262, 330, 392, 523].forEach((freq, i) => setTimeout(() => playSound(freq, 'square', 0.2), i * 100));
        }
        function playGameOver() {
            [440, 392, 349, 294].forEach((freq, i) => setTimeout(() => playSound(freq, 'sine', 0.3, 0.15), i * 150));
        }
        function playPowerupCollect() {
            [523, 659, 784].forEach((freq, i) => setTimeout(() => playSound(freq, 'sine', 0.15), i * 50));
        }
        function playLevelUp() {
            [392, 523, 659, 784].forEach((freq, i) => setTimeout(() => playSound(freq, 'square', 0.15, 0.25), i * 80));
        }

        // === MUSIC ===
        async function startBackgroundMusic(powerMode = false) {
            if (isMuted) return;
            stopBackgroundMusic();
            if (audioContext.state === 'suspended') await audioContext.resume();
            backgroundMusic = { active: true, intervalId: null };

            const bassNotes = powerMode ? [165, 165, 220, 165, 196, 165, 220, 262] : [110, 110, 165, 110, 147, 110, 165, 196];
            const leadNotes = powerMode ? [659, 784, 880, 988, 880, 784] : [440, 494, 523, 587, 523, 494];
            const tempo = powerMode ? 120 : 200;
            let beatCount = 0;

            function playBeat() {
                if (!backgroundMusic || !backgroundMusic.active) return;
                const now = audioContext.currentTime;
                const bass = audioContext.createOscillator();
                const bassGain = audioContext.createGain();
                bass.type = powerMode ? 'square' : 'sawtooth';
                bass.frequency.value = bassNotes[beatCount % bassNotes.length];
                bass.connect(bassGain);
                bassGain.connect(audioContext.destination);
                bassGain.gain.setValueAtTime(powerMode ? 0.25 : 0.2, now);
                bassGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                bass.start(now);
                bass.stop(now + 0.1);

                if (beatCount % 2 === 0) {
                    const lead = audioContext.createOscillator();
                    const leadGain = audioContext.createGain();
                    lead.type = powerMode ? 'sawtooth' : 'square';
                    lead.frequency.value = leadNotes[(beatCount / 2) % leadNotes.length];
                    lead.connect(leadGain);
                    leadGain.connect(audioContext.destination);
                    leadGain.gain.setValueAtTime(powerMode ? 0.12 : 0.08, now);
                    leadGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    lead.start(now);
                    lead.stop(now + 0.15);
                }
                beatCount++;
            }
            playBeat();
            backgroundMusic.intervalId = setInterval(playBeat, tempo);
        }

        function stopBackgroundMusic() {
            if (backgroundMusic) {
                backgroundMusic.active = false;
                if (backgroundMusic.intervalId) clearInterval(backgroundMusic.intervalId);
                backgroundMusic = null;
            }
        }

        function toggleMute() {
            isMuted = !isMuted;
            const btn = document.getElementById('muteButton');
            if (isMuted) { btn.textContent = 'üîá'; btn.classList.add('muted'); stopBackgroundMusic(); stopBossMusic(); }
            else { btn.textContent = 'üîä'; btn.classList.remove('muted'); if (gameRunning) { if (bossActive) startBossMusic(); else startBackgroundMusic(shieldActive); } }
        }

        // === BOSS MUSIC ===
        function startBossMusic() {
            if (isMuted) return;
            stopBackgroundMusic();
            stopBossMusic();
            bossMusic = { active: true, intervalId: null };
            const bassNotes = [82, 82, 98, 82, 110, 82, 98, 130];
            const leadNotes = [330, 392, 440, 392, 523, 440];
            let beatCount = 0;

            function playBossBeat() {
                if (!bossMusic || !bossMusic.active) return;
                const now = audioContext.currentTime;
                // Heavy bass drum
                const bass = audioContext.createOscillator();
                const bassGain = audioContext.createGain();
                bass.type = 'sawtooth';
                bass.frequency.value = bassNotes[beatCount % bassNotes.length];
                bass.connect(bassGain);
                bassGain.connect(audioContext.destination);
                bassGain.gain.setValueAtTime(0.35, now);
                bassGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                bass.start(now);
                bass.stop(now + 0.12);

                // Aggressive lead
                if (beatCount % 2 === 0) {
                    const lead = audioContext.createOscillator();
                    const leadGain = audioContext.createGain();
                    lead.type = 'square';
                    lead.frequency.value = leadNotes[(beatCount / 2) % leadNotes.length];
                    lead.connect(leadGain);
                    leadGain.connect(audioContext.destination);
                    leadGain.gain.setValueAtTime(0.15, now);
                    leadGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    lead.start(now);
                    lead.stop(now + 0.1);
                }
                // Tension synth
                if (beatCount % 4 === 0) {
                    const synth = audioContext.createOscillator();
                    const synthGain = audioContext.createGain();
                    synth.type = 'sine';
                    synth.frequency.value = 220 + Math.sin(beatCount * 0.5) * 50;
                    synth.connect(synthGain);
                    synthGain.connect(audioContext.destination);
                    synthGain.gain.setValueAtTime(0.1, now);
                    synthGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    synth.start(now);
                    synth.stop(now + 0.3);
                }
                beatCount++;
            }
            playBossBeat();
            bossMusic.intervalId = setInterval(playBossBeat, 100);
        }

        function stopBossMusic() {
            if (bossMusic) {
                bossMusic.active = false;
                if (bossMusic.intervalId) clearInterval(bossMusic.intervalId);
                bossMusic = null;
            }
        }

        function playBossDefeat() {
            if (isMuted) return;
            // Epic victory fanfare
            [262, 330, 392, 523, 659, 784].forEach((freq, i) => {
                setTimeout(() => playSound(freq, 'square', 0.3, 0.3), i * 100);
            });
        }

        // === BOSS FUNCTIONS ===
        function spawnBoss(levelNum) {
            const bossData = BOSSES[levelNum];
            if (!bossData) return;

            // Clear regular enemies
            enemies = [];
            walls = [];
            bombs = [];

            const diff = getDiffSettings();
            boss = {
                ...bossData,
                x: logicalWidth / 2,
                y: -bossData.height,
                targetY: 100,
                health: Math.floor(bossData.health * (1 + (diff.speedMult - 1) * 0.5)),
                maxHealth: Math.floor(bossData.maxHealth * (1 + (diff.speedMult - 1) * 0.5)),
                shootTimer: 1,
                moveTimer: 0,
                moveDirX: 1,
                moveDirY: 0,
                phase: 0,
                entering: true,
                tauntIndex: 0
            };
            bossActive = true;

            // Show boss UI
            document.getElementById('bossHealthContainer').classList.add('show');
            document.getElementById('bossName').textContent = bossData.name;
            updateBossHealthBar();

            // Start boss music
            startBossMusic();

            // Initial taunt
            setTimeout(() => showBossTaunt(), 1000);

            // Report action
            reportAction('fighting_boss', { bossName: bossData.name, level: levelNum });
        }

        function updateBossHealthBar() {
            if (!boss) return;
            const percent = (boss.health / boss.maxHealth) * 100;
            document.getElementById('bossHealthFill').style.width = percent + '%';
        }

        function showBossTaunt() {
            if (!boss || !bossActive) return;
            const taunt = boss.taunts[boss.tauntIndex % boss.taunts.length];
            boss.tauntIndex++;
            const tauntEl = document.getElementById('bossTaunt');
            tauntEl.textContent = '"' + taunt + '"';
            tauntEl.classList.add('show');
            setTimeout(() => tauntEl.classList.remove('show'), 2500);
        }

        function bossAttack() {
            if (!boss) return;
            const diff = getDiffSettings();
            const bulletSpeed = -300 * diff.speedMult;

            switch (boss.attackPattern) {
                case 'spread':
                    // 5 bullets in a spread
                    for (let i = -2; i <= 2; i++) {
                        bullets.push({
                            x: boss.x + i * 20, y: boss.y + boss.height / 2,
                            speed: bulletSpeed, vx: i * 50, isEnemy: true, type: 'boss', width: 12, height: 12
                        });
                    }
                    break;
                case 'spiral':
                    // Spiral pattern
                    for (let i = 0; i < 8; i++) {
                        const angle = (boss.phase + i * 45) * Math.PI / 180;
                        bullets.push({
                            x: boss.x, y: boss.y + boss.height / 2,
                            speed: bulletSpeed * 0.8, vx: Math.cos(angle) * 150, isEnemy: true, type: 'boss', width: 10, height: 10
                        });
                    }
                    boss.phase += 15;
                    break;
                case 'wave':
                    // Wave of bullets
                    for (let i = 0; i < 10; i++) {
                        bullets.push({
                            x: boss.x - 100 + i * 25, y: boss.y + boss.height / 2,
                            speed: bulletSpeed, vx: Math.sin(i + boss.phase) * 30, isEnemy: true, type: 'boss', width: 8, height: 8
                        });
                    }
                    boss.phase += 0.5;
                    break;
                case 'random':
                    // Random burst
                    for (let i = 0; i < 6; i++) {
                        bullets.push({
                            x: boss.x + (Math.random() - 0.5) * boss.width, y: boss.y + boss.height / 2,
                            speed: bulletSpeed * (0.8 + Math.random() * 0.4), vx: (Math.random() - 0.5) * 200,
                            isEnemy: true, type: 'boss', width: 10, height: 10
                        });
                    }
                    break;
                case 'all':
                    // Final boss uses all patterns
                    const pattern = Math.floor(boss.phase / 3) % 4;
                    boss.attackPattern = ['spread', 'spiral', 'wave', 'random'][pattern];
                    bossAttack();
                    boss.attackPattern = 'all';
                    boss.phase++;
                    break;
            }
            playEnemyBazooka();
        }

        function updateBoss(dt) {
            if (!boss) return;

            const diff = getDiffSettings();

            // Entry animation
            if (boss.entering) {
                boss.y += 100 * dt;
                if (boss.y >= boss.targetY) {
                    boss.y = boss.targetY;
                    boss.entering = false;
                }
                return;
            }

            // Movement - side to side and up/down
            boss.moveTimer += dt;
            const moveSpeed = boss.speed * diff.speedMult;

            // Horizontal movement
            boss.x += boss.moveDirX * moveSpeed * dt;
            if (boss.x < boss.width / 2 + 20) { boss.x = boss.width / 2 + 20; boss.moveDirX = 1; }
            if (boss.x > logicalWidth - boss.width / 2 - 20) { boss.x = logicalWidth - boss.width / 2 - 20; boss.moveDirX = -1; }

            // Vertical movement (slight bobbing + occasional dives)
            boss.y = boss.targetY + Math.sin(boss.moveTimer * 2) * 30;
            if (boss.moveTimer > 5) {
                boss.moveDirX *= -1;
                boss.moveTimer = 0;
                showBossTaunt();
            }

            // Shooting
            boss.shootTimer -= dt;
            if (boss.shootTimer <= 0) {
                bossAttack();
                boss.shootTimer = boss.fireRate / diff.enemyFireMult;
            }

            // Taunt timer
            bossTauntTimer += dt;
            if (bossTauntTimer > 8) {
                showBossTaunt();
                bossTauntTimer = 0;
            }
        }

        function drawBoss() {
            if (!boss) return;

            ctx.save();
            ctx.translate(boss.x, boss.y);

            // Glow effect
            ctx.fillStyle = boss.color + '33';
            ctx.beginPath();
            ctx.ellipse(0, 0, boss.width / 2 + 20, boss.height / 2 + 20, 0, 0, Math.PI * 2);
            ctx.fill();

            if (boss.type === 'aircraft') {
                // Large aircraft boss
                ctx.fillStyle = boss.color;
                // Main body
                ctx.beginPath();
                ctx.moveTo(0, -boss.height / 2);
                ctx.lineTo(-boss.width / 2, boss.height / 2);
                ctx.lineTo(-boss.width / 4, boss.height / 3);
                ctx.lineTo(boss.width / 4, boss.height / 3);
                ctx.lineTo(boss.width / 2, boss.height / 2);
                ctx.closePath();
                ctx.fill();

                // Wings
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(-boss.width / 4, 0);
                ctx.lineTo(-boss.width / 2 - 30, boss.height / 4);
                ctx.lineTo(-boss.width / 4, boss.height / 4);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(boss.width / 4, 0);
                ctx.lineTo(boss.width / 2 + 30, boss.height / 4);
                ctx.lineTo(boss.width / 4, boss.height / 4);
                ctx.closePath();
                ctx.fill();

                // Cockpit
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.ellipse(0, -boss.height / 4, 15, 20, 0, 0, Math.PI * 2);
                ctx.fill();

                // Engine glow
                ctx.fillStyle = '#ff6600';
                const flicker = Math.sin(Date.now() / 50) * 5;
                ctx.beginPath();
                ctx.moveTo(-20, boss.height / 3);
                ctx.lineTo(-10, boss.height / 2 + 15 + flicker);
                ctx.lineTo(0, boss.height / 3);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(0, boss.height / 3);
                ctx.lineTo(10, boss.height / 2 + 15 + flicker);
                ctx.lineTo(20, boss.height / 3);
                ctx.closePath();
                ctx.fill();

            } else {
                // Monster boss
                ctx.fillStyle = boss.color;

                // Body
                ctx.beginPath();
                ctx.ellipse(0, 0, boss.width / 2, boss.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Tentacles/appendages
                const time = Date.now() / 200;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI + Math.PI / 2;
                    const wave = Math.sin(time + i) * 10;
                    ctx.strokeStyle = boss.color;
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * boss.width / 3, Math.sin(angle) * boss.height / 3);
                    ctx.quadraticCurveTo(
                        Math.cos(angle) * boss.width / 2 + wave,
                        Math.sin(angle) * boss.height / 2 + wave,
                        Math.cos(angle) * (boss.width / 2 + 30),
                        Math.sin(angle) * (boss.height / 2 + 20)
                    );
                    ctx.stroke();
                }

                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(-25, -15, 20, 15, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(25, -15, 20, 15, 0, 0, Math.PI * 2);
                ctx.fill();

                // Pupils (follow player)
                const dx = player.x - boss.x;
                const dy = player.y - boss.y;
                const dist = Math.hypot(dx, dy);
                const px = (dx / dist) * 8 || 0;
                const py = (dy / dist) * 5 || 0;
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.ellipse(-25 + px, -15 + py, 10, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(25 + px, -15 + py, 10, 10, 0, 0, Math.PI * 2);
                ctx.fill();

                // Mouth
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(0, 20, 30, 15, 0, 0, Math.PI);
                ctx.fill();
                // Teeth
                ctx.fillStyle = '#fff';
                for (let i = -3; i <= 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * 8 - 4, 20);
                    ctx.lineTo(i * 8, 30);
                    ctx.lineTo(i * 8 + 4, 20);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            ctx.restore();

            // Health indicator flash when hit
            if (boss.hitFlash) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.ellipse(boss.x, boss.y, boss.width / 2, boss.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                boss.hitFlash = false;
            }
        }

        let bossLowHealthReported = false;

        function damageBoss(damage) {
            if (!boss) return;
            boss.health -= damage;
            boss.hitFlash = true;
            updateBossHealthBar();
            createExplosion(boss.x + (Math.random() - 0.5) * boss.width, boss.y + (Math.random() - 0.5) * boss.height, '#ffff00', 10);

            // Report boss low health once
            const healthPercent = (boss.health / boss.maxHealth) * 100;
            if (healthPercent <= 25 && !bossLowHealthReported) {
                bossLowHealthReported = true;
                reportAction('boss_low_health', { healthPercent: Math.floor(healthPercent) });
            }

            if (boss.health <= 0) {
                bossLowHealthReported = false;
                defeatBoss();
            }
        }

        function defeatBoss() {
            if (!boss) return;

            // Epic explosion
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    if (boss) {
                        createBigExplosion(
                            boss.x + (Math.random() - 0.5) * boss.width,
                            boss.y + (Math.random() - 0.5) * boss.height
                        );
                        playBigExplosion();
                    }
                }, i * 150);
            }

            // Final explosion and cleanup
            setTimeout(() => {
                createBigExplosion(boss.x, boss.y);
                for (let i = 0; i < 100; i++) {
                    particles.push({
                        x: boss.x, y: boss.y,
                        vx: (Math.random() - 0.5) * 600,
                        vy: (Math.random() - 0.5) * 600,
                        size: Math.random() * 8 + 4,
                        color: ['#ff0000', '#ff6600', '#ffff00', '#ffffff'][Math.floor(Math.random() * 4)],
                        life: 1.5
                    });
                }

                // Award points
                score += boss.maxHealth * 50;
                document.getElementById('score').textContent = score;

                // Report boss defeat action
                const defeatedLevel = level;
                reportAction('defeated_boss', { bossLevel: defeatedLevel });

                // Mark boss as defeated and advance level
                bossDefeated.push(level);
                level++;
                if (level > 5) level = 5;
                document.getElementById('levelDisplay').textContent = 'Level ' + level;

                // Report level up action
                reportAction('level_up', { newLevel: level });

                // Cleanup
                boss = null;
                bossActive = false;
                document.getElementById('bossHealthContainer').classList.remove('show');
                document.getElementById('bossTaunt').classList.remove('show');

                // Stop boss music, play victory, resume normal music
                stopBossMusic();
                playBossDefeat();
                setTimeout(() => {
                    if (gameRunning && !bossActive) startBackgroundMusic(shieldActive);
                }, 1500);

            }, 1500);
        }

        // === BACKGROUND INITIALIZATION ===
        function initBackground() {
            stars = [];
            nebulae = [];
            spaceObjects = [];

            // Stars - 3 layers for parallax
            for (let i = 0; i < 60; i++) {
                stars.push({
                    x: Math.random() * logicalWidth, y: Math.random() * logicalHeight,
                    size: Math.random() * 1.5 + 0.5, speed: 30 + Math.random() * 30,
                    layer: 0, phase: Math.random() * Math.PI * 2
                });
            }
            for (let i = 0; i < 40; i++) {
                stars.push({
                    x: Math.random() * logicalWidth, y: Math.random() * logicalHeight,
                    size: Math.random() * 2 + 1, speed: 60 + Math.random() * 40,
                    layer: 1, phase: Math.random() * Math.PI * 2
                });
            }
            for (let i = 0; i < 20; i++) {
                stars.push({
                    x: Math.random() * logicalWidth, y: Math.random() * logicalHeight,
                    size: Math.random() * 2.5 + 1.5, speed: 100 + Math.random() * 50,
                    layer: 2, phase: Math.random() * Math.PI * 2
                });
            }

            // Nebulae (colored gas clouds)
            for (let i = 0; i < 3; i++) {
                nebulae.push({
                    x: Math.random() * logicalWidth, y: Math.random() * logicalHeight - 200,
                    width: 200 + Math.random() * 300, height: 150 + Math.random() * 200,
                    color: ['#4a0080', '#800040', '#004080', '#008040'][Math.floor(Math.random() * 4)],
                    speed: 15 + Math.random() * 10, alpha: 0.1 + Math.random() * 0.15
                });
            }
        }

        function spawnSpaceObject() {
            const types = ['station', 'planet', 'asteroid', 'satellite', 'comet'];
            // More variety at higher levels
            const availableTypes = types.slice(0, Math.min(level + 2, types.length));
            const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];

            const obj = {
                type, x: Math.random() * (logicalWidth - 100) + 50, y: -150,
                speed: 20 + Math.random() * 30, rotation: 0, rotSpeed: (Math.random() - 0.5) * 0.5
            };

            if (type === 'planet') {
                obj.radius = 40 + Math.random() * 60;
                obj.color = ['#c0a080', '#80a0c0', '#a0c080', '#c08080', '#8080c0'][Math.floor(Math.random() * 5)];
                obj.rings = Math.random() > 0.6;
            } else if (type === 'station') {
                obj.width = 80 + Math.random() * 60;
                obj.height = 40 + Math.random() * 30;
            } else if (type === 'asteroid') {
                obj.radius = 15 + Math.random() * 25;
                obj.points = [];
                for (let i = 0; i < 8; i++) {
                    obj.points.push(0.7 + Math.random() * 0.6);
                }
            } else if (type === 'satellite') {
                obj.size = 20 + Math.random() * 15;
            } else if (type === 'comet') {
                obj.radius = 8 + Math.random() * 12;
                obj.tailLength = 80 + Math.random() * 60;
            }

            spaceObjects.push(obj);
        }

        // === SPAWN FUNCTIONS ===
        function getDiffSettings() { return DIFFICULTIES[selectedDifficulty]; }
        function getSpeedMultiplier() {
            const baseSpeed = levelSpeeds[Math.min(level, 5)] || 2.0;
            return baseSpeed * getDiffSettings().speedMult;
        }

        function getEnemyWeapon() {
            // Enemies get better weapons at higher levels
            if (level >= 5 && Math.random() < 0.3) return 'bazooka';
            if (level >= 3 && Math.random() < 0.4) return 'machinegun';
            if (level >= 2 && Math.random() < 0.2) return 'machinegun';
            return 'pistol';
        }

        function spawnEnemy() {
            const mult = getSpeedMultiplier();
            const weapon = getEnemyWeapon();
            enemies.push({
                x: Math.random() * (logicalWidth - 60) + 30, y: -30,
                width: 40, height: 40, speed: (100 + Math.random() * 100) * mult,
                shootTimer: Math.random() * 0.5 + 0.5, weapon: weapon
            });
        }

        function spawnPowerup() {
            powerups.push({
                x: Math.random() * (logicalWidth - 60) + 30, y: -30,
                width: 30, height: 30, speed: 80 * getSpeedMultiplier(), rotation: 0, type: 'shield'
            });
        }

        function spawnBomb() {
            bombs.push({
                x: Math.random() * (logicalWidth - 60) + 30, y: -30,
                width: 25, height: 25, speed: 60 * getSpeedMultiplier(), rotation: 0
            });
        }

        function spawnWall() {
            const width = 80 + Math.random() * 120;
            walls.push({
                x: Math.random() * (logicalWidth - width), y: -40,
                width: width, height: 20, speed: 50 * getSpeedMultiplier()
            });
        }

        function spawnWeaponPickup() {
            const available = ['machinegun', 'bazooka', 'laser'].filter(w => !unlockedWeapons.includes(w));
            if (available.length === 0) return;
            const type = available[Math.floor(Math.random() * available.length)];
            weaponPickups.push({
                x: Math.random() * (logicalWidth - 60) + 30, y: -30,
                width: 30, height: 30, speed: 70 * getSpeedMultiplier(), rotation: 0, type: type
            });
        }

        // === BACKGROUND DRAWING ===
        function getBackgroundGradient() {
            // Background changes based on level - going deeper into space
            const gradients = [
                ['#0a0a1a', '#1a1a3e', '#2d2d5a'], // Level 1: Near Earth
                ['#0a0a20', '#151540', '#252570'], // Level 2: Deep space
                ['#100520', '#200840', '#351060'], // Level 3: Nebula region
                ['#150505', '#300a10', '#501020'], // Level 4: Red giant region
                ['#000010', '#000030', '#100050']  // Level 5: Edge of galaxy
            ];
            return gradients[Math.min(level - 1, 4)];
        }

        function drawBackground() {
            const colors = getBackgroundGradient();
            const gradient = ctx.createLinearGradient(0, 0, 0, logicalHeight);
            gradient.addColorStop(0, colors[0]);
            gradient.addColorStop(0.5, colors[1]);
            gradient.addColorStop(1, colors[2]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, logicalWidth, logicalHeight);

            // Draw nebulae
            nebulae.forEach(n => {
                const grad = ctx.createRadialGradient(n.x + n.width/2, n.y + n.height/2, 0,
                    n.x + n.width/2, n.y + n.height/2, n.width/2);
                grad.addColorStop(0, n.color + '40');
                grad.addColorStop(0.5, n.color + '20');
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.fillRect(n.x, n.y, n.width, n.height);
            });

            // Draw stars with parallax
            const time = Date.now() / 1000;
            stars.forEach(star => {
                const twinkle = 0.5 + Math.sin(time * 2 + star.phase) * 0.3;
                ctx.globalAlpha = twinkle * (0.4 + star.layer * 0.2);
                ctx.fillStyle = star.layer === 2 ? '#ffffcc' : '#ffffff';
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Draw space objects
            spaceObjects.forEach(obj => {
                ctx.save();
                ctx.translate(obj.x, obj.y);
                ctx.rotate(obj.rotation);

                if (obj.type === 'planet') {
                    // Planet with optional rings
                    ctx.fillStyle = obj.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, obj.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // Shading
                    const shadeGrad = ctx.createLinearGradient(-obj.radius, -obj.radius, obj.radius, obj.radius);
                    shadeGrad.addColorStop(0, 'rgba(255,255,255,0.2)');
                    shadeGrad.addColorStop(1, 'rgba(0,0,0,0.4)');
                    ctx.fillStyle = shadeGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, obj.radius, 0, Math.PI * 2);
                    ctx.fill();
                    if (obj.rings) {
                        ctx.strokeStyle = 'rgba(200,180,150,0.5)';
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, obj.radius * 1.8, obj.radius * 0.3, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                } else if (obj.type === 'station') {
                    // Space station
                    ctx.fillStyle = '#666';
                    ctx.fillRect(-obj.width/2, -obj.height/2, obj.width, obj.height);
                    ctx.fillStyle = '#888';
                    ctx.fillRect(-obj.width/2 + 10, -obj.height/2 - 15, 20, 15);
                    ctx.fillRect(obj.width/2 - 30, -obj.height/2 - 15, 20, 15);
                    // Solar panels
                    ctx.fillStyle = '#334';
                    ctx.fillRect(-obj.width/2 - 30, -5, 30, 10);
                    ctx.fillRect(obj.width/2, -5, 30, 10);
                    // Lights
                    ctx.fillStyle = Math.sin(Date.now() / 200) > 0 ? '#ff0000' : '#660000';
                    ctx.beginPath();
                    ctx.arc(0, -obj.height/2, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obj.type === 'asteroid') {
                    ctx.fillStyle = '#665544';
                    ctx.beginPath();
                    for (let i = 0; i < obj.points.length; i++) {
                        const angle = (i / obj.points.length) * Math.PI * 2;
                        const r = obj.radius * obj.points[i];
                        if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                        else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#554433';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else if (obj.type === 'satellite') {
                    ctx.fillStyle = '#aaa';
                    ctx.fillRect(-obj.size/4, -obj.size/4, obj.size/2, obj.size/2);
                    ctx.fillStyle = '#336';
                    ctx.fillRect(-obj.size, -obj.size/8, obj.size * 2, obj.size/4);
                } else if (obj.type === 'comet') {
                    // Comet tail
                    const tailGrad = ctx.createLinearGradient(0, 0, obj.tailLength, obj.tailLength/2);
                    tailGrad.addColorStop(0, 'rgba(150,200,255,0.8)');
                    tailGrad.addColorStop(1, 'transparent');
                    ctx.fillStyle = tailGrad;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(obj.tailLength, obj.tailLength/3);
                    ctx.lineTo(obj.tailLength, -obj.tailLength/3);
                    ctx.closePath();
                    ctx.fill();
                    // Comet head
                    ctx.fillStyle = '#aaddff';
                    ctx.beginPath();
                    ctx.arc(0, 0, obj.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            });
        }

        function updateBackground(dt) {
            // Update stars
            stars.forEach(s => {
                s.y += s.speed * dt;
                if (s.y > logicalHeight) { s.y = -5; s.x = Math.random() * logicalWidth; }
            });

            // Update nebulae
            nebulae.forEach(n => {
                n.y += n.speed * dt;
                if (n.y > logicalHeight + 100) {
                    n.y = -n.height - 100;
                    n.x = Math.random() * logicalWidth;
                    n.color = ['#4a0080', '#800040', '#004080', '#008040'][Math.floor(Math.random() * 4)];
                }
            });

            // Update space objects
            spaceObjects.forEach(obj => {
                obj.y += obj.speed * dt;
                obj.rotation += obj.rotSpeed * dt;
            });
            spaceObjects = spaceObjects.filter(obj => obj.y < logicalHeight + 200);
        }

        // === DRAWING ===
        function drawPlayer() {
            const colors = jetColors[selectedColor];
            ctx.save();
            ctx.translate(player.x, player.y);

            // Flashing shield
            if (shieldActive) {
                const flash = Math.sin(Date.now() / 80) > 0;
                const pulse = 0.4 + Math.sin(Date.now() / 100) * 0.4;
                if (flash) {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${pulse})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, 42, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.strokeStyle = `rgba(100, 255, 255, ${pulse * 0.7})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 38, 0, Math.PI * 2);
                ctx.stroke();
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse * 0.5})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(0, 0, 45, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.fillStyle = colors.body;
            ctx.beginPath();
            ctx.moveTo(0, -25); ctx.lineTo(-20, 25); ctx.lineTo(-8, 20);
            ctx.lineTo(-8, 25); ctx.lineTo(8, 25); ctx.lineTo(8, 20); ctx.lineTo(20, 25);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = colors.cockpit;
            ctx.beginPath();
            ctx.ellipse(0, -5, 6, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = colors.wings;
            ctx.beginPath();
            ctx.moveTo(-8, 5); ctx.lineTo(-30, 20); ctx.lineTo(-8, 15);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(8, 5); ctx.lineTo(30, 20); ctx.lineTo(8, 15);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#ff6b35';
            ctx.beginPath();
            ctx.moveTo(-5, 25);
            ctx.lineTo(0, 35 + Math.sin(Date.now() / 50) * 2.5 + 2.5);
            ctx.lineTo(5, 25);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawEnemy(enemy) {
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            ctx.rotate(Math.PI);

            // Color based on weapon
            const weaponColors = { pistol: '#e74c3c', machinegun: '#f1c40f', bazooka: '#e67e22' };
            ctx.fillStyle = weaponColors[enemy.weapon] || '#e74c3c';

            ctx.beginPath();
            ctx.moveTo(0, -20); ctx.lineTo(-15, 20); ctx.lineTo(-5, 15);
            ctx.lineTo(5, 15); ctx.lineTo(15, 20);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#c0392b';
            ctx.beginPath();
            ctx.moveTo(-5, 0); ctx.lineTo(-25, 15); ctx.lineTo(-5, 10);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(5, 0); ctx.lineTo(25, 15); ctx.lineTo(5, 10);
            ctx.closePath();
            ctx.fill();

            // Weapon indicator
            if (enemy.weapon === 'machinegun') {
                ctx.fillStyle = '#fff';
                ctx.fillRect(-8, 15, 4, 8);
                ctx.fillRect(4, 15, 4, 8);
            } else if (enemy.weapon === 'bazooka') {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, 18, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawBullet(bullet) {
            if (bullet.type === 'bazooka') {
                ctx.fillStyle = 'rgba(255, 100, 0, 0.4)';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffcc00';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
                ctx.fill();
            } else if (bullet.type === 'machinegun') {
                const col = bullet.isEnemy ? '#ffaa00' : '#ffff00';
                ctx.fillStyle = col + '4d';
                ctx.fillRect(bullet.x - 3, bullet.y - 6, 6, 12);
                ctx.fillStyle = col;
                ctx.fillRect(bullet.x - 2, bullet.y - 5, 4, 10);
            } else {
                const color = bullet.isEnemy ? '#ff4444' : '#00ffff';
                const glow = bullet.isEnemy ? 'rgba(255, 68, 68, 0.3)' : 'rgba(0, 255, 255, 0.3)';
                ctx.fillStyle = glow;
                ctx.fillRect(bullet.x - 4, bullet.y - 10, 8, 20);
                ctx.fillStyle = color;
                ctx.fillRect(bullet.x - 2, bullet.y - 8, 4, 16);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(bullet.x - 1, bullet.y - 6, 2, 12);
            }
        }

        function drawLaser() {
            if (!laserActive || currentWeapon !== 'laser') return;
            const gradient = ctx.createLinearGradient(player.x, 0, player.x, player.y);
            gradient.addColorStop(0, 'rgba(255, 0, 255, 0)');
            gradient.addColorStop(0.5, 'rgba(255, 0, 255, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 100, 255, 1)');
            ctx.fillStyle = 'rgba(255, 0, 255, 0.2)';
            ctx.fillRect(player.x - 15, 0, 30, player.y - 25);
            ctx.fillStyle = gradient;
            ctx.fillRect(player.x - 8, 0, 16, player.y - 25);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(player.x - 3, 0, 6, player.y - 25);
        }

        function drawBomb(bomb) {
            ctx.save();
            ctx.translate(bomb.x, bomb.y);
            ctx.rotate(bomb.rotation);
            ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(0, 0, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ff4400';
            ctx.fillRect(-3, -15, 6, 6);
            const flicker = Math.sin(Date.now() / 50) > 0;
            ctx.fillStyle = flicker ? '#ffff00' : '#ff8800';
            ctx.beginPath();
            ctx.arc(0, -18, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawWall(wall) {
            ctx.fillStyle = '#555';
            ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            ctx.fillStyle = '#ff0000';
            for (let i = 0; i < wall.width; i += 20) {
                ctx.fillRect(wall.x + i, wall.y, 10, wall.height);
            }
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            ctx.strokeRect(wall.x, wall.y, wall.width, wall.height);
        }

        function drawPowerup(powerup) {
            ctx.save();
            ctx.translate(powerup.x, powerup.y);
            ctx.rotate(powerup.rotation);
            ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
            ctx.fillRect(-8, -16, 16, 32);
            ctx.fillRect(-16, -8, 32, 16);
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(-4, -12, 8, 24);
            ctx.fillRect(-12, -4, 24, 8);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-3, -8, 6, 16);
            ctx.fillRect(-8, -3, 16, 6);
            ctx.restore();
        }

        function drawWeaponPickup(wp) {
            ctx.save();
            ctx.translate(wp.x, wp.y);
            ctx.rotate(wp.rotation);
            const colors = { machinegun: '#ffff00', bazooka: '#ff6600', laser: '#ff00ff' };
            ctx.fillStyle = colors[wp.type] + '33';
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = colors[wp.type];
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const labels = { machinegun: 'MG', bazooka: 'BZ', laser: 'LS' };
            ctx.fillText(labels[wp.type], 0, 0);
            ctx.restore();
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function createExplosion(x, y, color, count = 20) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y, vx: (Math.random() - 0.5) * 480, vy: (Math.random() - 0.5) * 480,
                    size: Math.random() * 4 + 2, color, life: 1
                });
            }
        }

        function createBigExplosion(x, y) {
            for (let i = 0; i < 50; i++) {
                const angle = (i / 50) * Math.PI * 2;
                const speed = 200 + Math.random() * 300;
                particles.push({
                    x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                    size: Math.random() * 6 + 3,
                    color: ['#ff4400', '#ffaa00', '#ffff00', '#ffffff'][Math.floor(Math.random() * 4)],
                    life: 1
                });
            }
        }

        // === SHOOTING ===
        function shoot() {
            const now = Date.now();
            const weapon = WEAPONS[currentWeapon];
            if (now - lastFireTime < weapon.fireRate) return;
            lastFireTime = now;

            const bulletMult = getSpeedMultiplier();
            if (currentWeapon === 'pistol') {
                bullets.push({ x: player.x, y: player.y - 25, speed: 600 * bulletMult, isEnemy: false, type: 'pistol', width: 10, height: 20 });
                playPlayerLaser();
            } else if (currentWeapon === 'machinegun') {
                bullets.push({ x: player.x - 8, y: player.y - 20, speed: 800 * bulletMult, isEnemy: false, type: 'machinegun', width: 8, height: 12 });
                bullets.push({ x: player.x + 8, y: player.y - 20, speed: 800 * bulletMult, isEnemy: false, type: 'machinegun', width: 8, height: 12 });
                playMachineGun();
            } else if (currentWeapon === 'bazooka') {
                bullets.push({ x: player.x, y: player.y - 25, speed: 400 * bulletMult, isEnemy: false, type: 'bazooka', width: 20, height: 20, explosive: true });
                playBazooka();
            } else if (currentWeapon === 'laser') {
                laserActive = true;
                playLaserBeam();
            }
        }

        function enemyShoot(enemy) {
            const diff = getDiffSettings();
            const speed = -200 * getSpeedMultiplier();

            if (enemy.weapon === 'machinegun') {
                bullets.push({ x: enemy.x - 6, y: enemy.y + 20, speed: speed * 1.2, isEnemy: true, type: 'machinegun', width: 8, height: 12 });
                bullets.push({ x: enemy.x + 6, y: enemy.y + 20, speed: speed * 1.2, isEnemy: true, type: 'machinegun', width: 8, height: 12 });
                playEnemyMachineGun();
            } else if (enemy.weapon === 'bazooka') {
                bullets.push({ x: enemy.x, y: enemy.y + 20, speed: speed * 0.7, isEnemy: true, type: 'bazooka', width: 20, height: 20, explosive: true });
                playEnemyBazooka();
            } else {
                bullets.push({ x: enemy.x, y: enemy.y + 20, speed: speed, isEnemy: true, type: 'pistol', width: 10, height: 20 });
                playEnemyLaser();
            }
        }

        function switchWeapon() {
            if (unlockedWeapons.length <= 1) return;
            const idx = unlockedWeapons.indexOf(currentWeapon);
            currentWeapon = unlockedWeapons[(idx + 1) % unlockedWeapons.length];
            laserActive = false;
            updateWeaponDisplay();
        }

        function updateWeaponDisplay() {
            const wpnList = unlockedWeapons.map(w => w === currentWeapon ? `[${WEAPONS[w].name}]` : WEAPONS[w].name.charAt(0)).join(' ');
            document.getElementById('weaponDisplay').textContent = wpnList + ' [Q]';
        }

        function checkCollision(a, b) {
            return Math.abs(a.x - b.x) < ((a.width || 10) + (b.width || 10)) / 2 &&
                   Math.abs(a.y - b.y) < ((a.height || 10) + (b.height || 10)) / 2;
        }

        function checkWallCollision(obj, wall) {
            return obj.x > wall.x && obj.x < wall.x + wall.width &&
                   obj.y > wall.y && obj.y < wall.y + wall.height;
        }

        // === UPDATE ===
        function updateParticles(dt) {
            particles = particles.filter(p => {
                p.x += p.vx * dt; p.y += p.vy * dt;
                p.life -= 1.5 * dt; p.size *= Math.pow(0.1, dt);
                return p.life > 0;
            });
        }

        function activateShield() {
            const wasActive = shieldActive;
            shieldActive = true;
            shieldHits = shieldMaxHits;
            shieldStartTime = Date.now();
            if (!wasActive && !isMuted) startBackgroundMusic(true);
        }

        function deactivateShield() {
            shieldActive = false;
            shieldHits = 0;
            if (!isMuted && gameRunning) startBackgroundMusic(false);
        }

        function checkLevelUp() {
            const newLevel = Math.min(5, Math.floor(score / levelUpScore) + 1);
            if (newLevel > level && !bossActive) {
                // Check if boss for current level has been defeated
                if (!bossDefeated.includes(level)) {
                    // Spawn boss for current level
                    spawnBoss(level);
                } else {
                    // Boss already defeated, advance level
                    level = newLevel;
                    document.getElementById('levelDisplay').textContent = 'Level ' + level;
                    playLevelUp();
                    createExplosion(logicalWidth / 2, logicalHeight / 2, '#ffd700', 40);
                }
            }
        }

        function update(dt) {
            if (!gameRunning || gamePaused) return;

            const diff = getDiffSettings();

            // Update boss if active
            if (bossActive && boss) {
                updateBoss(dt);
            }

            // Player movement
            let pdx = 0, pdy = 0;
            if (keys['ArrowLeft'] || keys['KeyA']) pdx = -1;
            else if (keys['ArrowRight'] || keys['KeyD']) pdx = 1;
            if (keys['ArrowUp'] || keys['KeyW']) pdy = -1;
            else if (keys['ArrowDown'] || keys['KeyS']) pdy = 1;

            if (joystickActive) { pdx = touchMove.x; pdy = touchMove.y; }

            const playerSpeedMult = getSpeedMultiplier();
            player.x += pdx * player.speed * playerSpeedMult * dt;
            // During boss fight, limit vertical movement to bottom half
            if (bossActive) {
                player.y += pdy * player.speed * playerSpeedMult * dt * 0.5; // Slower vertical
                player.y = Math.max(logicalHeight / 2 + 50, Math.min(logicalHeight - 30, player.y));
            } else {
                player.y += pdy * player.speed * playerSpeedMult * dt;
                player.y = Math.max(30, Math.min(logicalHeight - 30, player.y));
            }
            player.x = Math.max(30, Math.min(logicalWidth - 30, player.x));

            if (autoFire) shoot();

            // Laser damage
            if (laserActive && currentWeapon === 'laser') {
                // Damage enemies
                enemies = enemies.filter(enemy => {
                    if (enemy.x > player.x - 15 && enemy.x < player.x + 15 && enemy.y < player.y) {
                        score += 100;
                        document.getElementById('score').textContent = score;
                        createExplosion(enemy.x, enemy.y, '#ff00ff');
                        playExplosion();
                        checkLevelUp();
                        return false;
                    }
                    return true;
                });
                // Damage boss
                if (boss && boss.x > player.x - 15 && boss.x < player.x + 15 && boss.y < player.y) {
                    damageBoss(0.5 * dt * 60); // Continuous damage
                }
            }

            // Update bullets
            bullets = bullets.filter(b => {
                b.y -= b.speed * dt;
                if (b.vx) b.x += b.vx * dt; // Boss bullets have horizontal movement
                return b.y > -20 && b.y < logicalHeight + 20 && b.x > -20 && b.x < logicalWidth + 20;
            });

            // Update enemies
            enemies.forEach(e => {
                e.y += e.speed * dt;
                e.shootTimer -= dt;
                const fireRate = e.weapon === 'machinegun' ? 0.3 : (e.weapon === 'bazooka' ? 1.5 : 0.8);
                if (e.shootTimer <= 0) {
                    enemyShoot(e);
                    e.shootTimer = fireRate / diff.enemyFireMult + Math.random() * 0.5;
                }
            });
            enemies = enemies.filter(e => e.y < logicalHeight + 50);

            // Update walls
            walls.forEach(w => w.y += w.speed * dt);
            walls = walls.filter(w => w.y < logicalHeight + 50);

            // Update powerups
            powerups.forEach(p => { p.y += p.speed * dt; p.rotation += 3 * dt; });
            powerups = powerups.filter(p => p.y < logicalHeight + 50);

            // Update bombs
            bombs.forEach(b => { b.y += b.speed * dt; b.rotation += 2 * dt; });
            bombs = bombs.filter(b => b.y < logicalHeight + 50);

            // Update weapon pickups
            weaponPickups.forEach(w => { w.y += w.speed * dt; w.rotation += 2 * dt; });
            weaponPickups = weaponPickups.filter(w => w.y < logicalHeight + 50);

            // Bullet-enemy collisions
            bullets.forEach((bullet, bi) => {
                if (bullet.isEnemy) {
                    if (checkCollision(bullet, player)) {
                        bullets.splice(bi, 1);
                        if (bullet.explosive) {
                            createBigExplosion(bullet.x, bullet.y);
                            playBigExplosion();
                        }
                        if (shieldActive) {
                            shieldHits--; createExplosion(player.x, player.y, '#00ffff');
                            if (shieldHits <= 0) deactivateShield();
                        } else {
                            lives--;
                            document.getElementById('lives').textContent = lives;
                            createExplosion(player.x, player.y, jetColors[selectedColor].body);
                            playExplosion();
                            if (lives <= 0) {
                                const deathReason = bullet.type === 'boss' ? 'killed_by_boss' : 'killed_by_drone';
                                reportAction(deathReason);
                                gameOver(deathReason);
                            }
                        }
                    }
                } else {
                    enemies.forEach((enemy, ei) => {
                        if (checkCollision(bullet, enemy)) {
                            if (bullet.explosive) {
                                createBigExplosion(bullet.x, bullet.y);
                                playBigExplosion();
                                enemies = enemies.filter(e => {
                                    const dist = Math.hypot(e.x - bullet.x, e.y - bullet.y);
                                    if (dist < 100) { score += 100; createExplosion(e.x, e.y, '#e74c3c'); return false; }
                                    return true;
                                });
                                bullets.splice(bi, 1);
                            } else {
                                bullets.splice(bi, 1);
                                enemies.splice(ei, 1);
                                score += 100;
                                createExplosion(enemy.x, enemy.y, '#e74c3c');
                                playExplosion();
                            }
                            document.getElementById('score').textContent = score;
                            checkLevelUp();
                        }
                    });

                    bombs.forEach((bomb, bmi) => {
                        if (checkCollision(bullet, bomb)) {
                            bullets.splice(bi, 1);
                            bombs.splice(bmi, 1);
                            createBigExplosion(bomb.x, bomb.y);
                            playBigExplosion();
                            enemies = enemies.filter(e => {
                                const dist = Math.hypot(e.x - bomb.x, e.y - bomb.y);
                                if (dist < 120) { score += 100; createExplosion(e.x, e.y, '#ff6600'); return false; }
                                return true;
                            });
                            document.getElementById('score').textContent = score;
                            checkLevelUp();
                        }
                    });

                    // Boss collision
                    if (boss && !bullet.isEnemy) {
                        const bossCollision = Math.abs(bullet.x - boss.x) < boss.width / 2 &&
                                              Math.abs(bullet.y - boss.y) < boss.height / 2;
                        if (bossCollision) {
                            bullets.splice(bi, 1);
                            const damage = bullet.explosive ? 5 : (bullet.type === 'bazooka' ? 3 : 1);
                            damageBoss(damage);
                            if (bullet.explosive) {
                                createBigExplosion(bullet.x, bullet.y);
                                playBigExplosion();
                            }
                        }
                    }
                }
            });

            // Player-enemy collision
            enemies.forEach((enemy, ei) => {
                if (checkCollision(enemy, player)) {
                    enemies.splice(ei, 1);
                    createExplosion(enemy.x, enemy.y, '#e74c3c');
                    if (shieldActive) {
                        shieldHits--; createExplosion(player.x, player.y, '#00ffff');
                        if (shieldHits <= 0) deactivateShield();
                    } else {
                        lives--;
                        document.getElementById('lives').textContent = lives;
                        createExplosion(player.x, player.y, jetColors[selectedColor].body);
                        playExplosion();
                        if (lives <= 0) {
                            reportAction('killed_by_drone');
                            gameOver('killed_by_drone');
                        }
                    }
                }
            });

            // Player-wall collision
            walls.forEach(wall => {
                if (checkWallCollision(player, wall)) {
                    if (shieldActive) {
                        shieldHits--; createExplosion(player.x, player.y, '#00ffff');
                        if (shieldHits <= 0) deactivateShield();
                    } else {
                        lives--;
                        document.getElementById('lives').textContent = lives;
                        createExplosion(player.x, player.y, jetColors[selectedColor].body);
                        playExplosion();
                        if (lives <= 0) {
                            reportAction('crashed_wall');
                            gameOver('crashed_wall');
                        }
                    }
                    player.y = wall.y + wall.height + 30;
                }
            });

            // Powerup collection
            powerups.forEach((p, pi) => {
                if (checkCollision(p, player)) {
                    powerups.splice(pi, 1);
                    createExplosion(p.x, p.y, '#00ff00');
                    playPowerupCollect();
                    activateShield();
                    reportAction('got_shield');
                }
            });

            // Weapon pickup collection
            weaponPickups.forEach((w, wi) => {
                if (checkCollision(w, player)) {
                    weaponPickups.splice(wi, 1);
                    if (!unlockedWeapons.includes(w.type)) {
                        unlockedWeapons.push(w.type);
                    }
                    currentWeapon = w.type;
                    updateWeaponDisplay();
                    reportAction('got_' + w.type);
                    createExplosion(w.x, w.y, WEAPONS[w.type].color);
                    playPowerupCollect();
                }
            });

            // Shield timer
            if (shieldActive && (Date.now() - shieldStartTime) >= shieldDuration) deactivateShield();

            updateBackground(dt);
            updateParticles(dt);
        }

        function draw() {
            drawBackground();
            walls.forEach(drawWall);
            bombs.forEach(drawBomb);
            bullets.forEach(drawBullet);
            enemies.forEach(drawEnemy);
            powerups.forEach(drawPowerup);
            weaponPickups.forEach(drawWeaponPickup);
            if (bossActive) drawBoss();
            drawParticles();
            if (gameRunning && lives > 0) {
                drawLaser();
                drawPlayer();
            }
        }

        let spawnAccumulator = 0;
        let powerupAccumulator = 0;
        let bombAccumulator = 0;
        let wallAccumulator = 0;
        let weaponAccumulator = 0;
        let spaceObjAccumulator = 0;

        function gameLoop(currentTime) {
            const dt = Math.min((currentTime - lastFrameTime) / 1000, 0.1);
            lastFrameTime = currentTime;

            update(dt);
            draw();

            // Broadcast game state to spectators (throttled)
            broadcastGameState();

            if (gameRunning && !bossActive) {
                // Only spawn enemies/items when not fighting a boss
                const diff = getDiffSettings();
                // Spawn rate decreases (faster spawning) with level and difficulty
                const baseSpawnRate = Math.max(0.2, (0.8 - level * 0.1) * diff.spawnMult);
                // Spawn multiple enemies at higher difficulties
                const enemiesPerSpawn = selectedDifficulty === 'expert' ? 2 : (selectedDifficulty === 'hard' ? (Math.random() < 0.3 ? 2 : 1) : 1);

                spawnAccumulator += dt;
                if (spawnAccumulator >= baseSpawnRate) {
                    for (let i = 0; i < enemiesPerSpawn; i++) spawnEnemy();
                    spawnAccumulator = 0;
                }

                powerupAccumulator += dt;
                if (powerupAccumulator >= 6 && Math.random() < 0.4) { spawnPowerup(); powerupAccumulator = 0; }

                bombAccumulator += dt;
                if (bombAccumulator >= 5 && Math.random() < 0.35) { spawnBomb(); bombAccumulator = 0; }

                // Walls spawn more frequently at higher levels/difficulties
                const wallSpawnTime = Math.max(1.5, 4 - level * 0.5);
                const wallChance = 0.2 + level * 0.1 + (selectedDifficulty === 'hard' ? 0.15 : 0) + (selectedDifficulty === 'expert' ? 0.25 : 0);
                wallAccumulator += dt;
                if (wallAccumulator >= wallSpawnTime && level >= 2 && Math.random() < wallChance) { spawnWall(); wallAccumulator = 0; }

                weaponAccumulator += dt;
                if (weaponAccumulator >= 10 && Math.random() < 0.4) { spawnWeaponPickup(); weaponAccumulator = 0; }

                spaceObjAccumulator += dt;
                if (spaceObjAccumulator >= 6 && Math.random() < 0.5) { spawnSpaceObject(); spaceObjAccumulator = 0; }
            }

            requestAnimationFrame(gameLoop);
        }

        async function startGame() {
            if (audioContext.state === 'suspended') await audioContext.resume();
            closeSetupModal();
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('lobbySidebar').style.display = 'none';

            const diff = getDiffSettings();
            score = 0; lives = diff.lives; level = 1;
            bullets = []; enemies = []; particles = []; powerups = [];
            bombs = []; walls = []; weaponPickups = [];
            player.x = logicalWidth / 2; player.y = logicalHeight - 80;
            spawnAccumulator = 0; powerupAccumulator = 0; bombAccumulator = 0;
            wallAccumulator = 0; weaponAccumulator = 0; spaceObjAccumulator = 0;
            currentWeapon = 'pistol';
            unlockedWeapons = ['pistol'];
            laserActive = false;
            deactivateShield();
            // Reset boss state
            boss = null;
            bossActive = false;
            bossDefeated = [];
            bossTauntTimer = 0;
            bossLowHealthReported = false;
            stopBossMusic();
            document.getElementById('bossHealthContainer').classList.remove('show');
            document.getElementById('bossTaunt').classList.remove('show');
            initBackground();
            // Initialize game timer
            gameStartTime = Date.now();
            gameDuration = 0;

            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('levelDisplay').textContent = 'Level 1';
            document.getElementById('difficultyDisplay').textContent = diff.name;
            document.getElementById('difficultyDisplay').style.color = diff.color;
            updateWeaponDisplay();

            gameRunning = true;
            gamePaused = false;
            lastFrameTime = performance.now();
            playGameStart();
            startBackgroundMusic(false);
            // Show touch controls on mobile
            if (isMobile) {
                document.getElementById('touchControls').classList.add('show');
            }
            // Join as live player and show sidebar
            await joinAsPlayer();
            await startGameSession();
            document.getElementById('livePlayersSidebar').classList.add('show');
            startPlayerPolling();
            updatePlayerStatus('playing');
            reportAction('started_game');
        }

        let lastDeathReason = 'unknown';

        async function gameOver(deathReason = 'unknown') {
            gameRunning = false;
            gamePaused = false;
            laserActive = false;
            lastDeathReason = deathReason;
            // Update final game duration
            if (gameStartTime) {
                gameDuration = Math.floor((Date.now() - gameStartTime) / 1000);
            }
            // Clean up boss state
            const wasBossActive = bossActive;
            boss = null;
            bossActive = false;
            stopBossMusic();
            document.getElementById('bossHealthContainer').classList.remove('show');
            document.getElementById('bossTaunt').classList.remove('show');
            document.getElementById('touchControls').classList.remove('show');
            // Report death action
            reportAction('game_over', { deathReason, score, level, duration: gameDuration });
            // End session
            await endGameSession(deathReason);
            // Clean up live players
            stopPlayerPolling();
            document.getElementById('livePlayersSidebar').classList.remove('show');
            await leaveAsPlayer();

            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('finalDifficulty').textContent = getDiffSettings().name;

            // Auto-save high score using player's name from start
            const scoreSavedMsg = document.getElementById('scoreSavedMsg');
            await fetchLeaderboard();
            if (isHighScore(score) && score > 0) {
                const playerName = myPlayerName || 'Anonymous';
                await addHighScore(playerName, score, selectedDifficulty.toUpperCase(), level, gameDuration);
                scoreSavedMsg.textContent = `üéâ High Score saved as "${playerName}"!`;
                scoreSavedMsg.style.display = 'block';
            } else {
                scoreSavedMsg.style.display = 'none';
            }
            renderLeaderboardFromCache('gameOverLeaderboardList');
            renderLeaderboardFromCache('startLeaderboardList');

            document.getElementById('gameOverScreen').classList.remove('hidden');
            playGameOver();
            stopBackgroundMusic();
        }

        async function backToMenu() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
            document.getElementById('lobbySidebar').style.display = 'block';
            await renderLeaderboard('startLeaderboardList');
        }

        async function quitGame() {
            if (!gameRunning) return;
            gameRunning = false;
            gamePaused = false;
            laserActive = false;
            // Clean up boss state
            boss = null;
            bossActive = false;
            stopBossMusic();
            document.getElementById('bossHealthContainer').classList.remove('show');
            document.getElementById('bossTaunt').classList.remove('show');
            document.getElementById('pauseOverlay').classList.remove('show');
            document.getElementById('touchControls').classList.remove('show');
            // Clean up live players
            stopPlayerPolling();
            document.getElementById('livePlayersSidebar').classList.remove('show');
            await leaveAsPlayer();
            stopBackgroundMusic();
            document.getElementById('startScreen').classList.remove('hidden');
            document.getElementById('lobbySidebar').style.display = 'block';
            await renderLeaderboard('startLeaderboardList');
        }

        // === PAUSE FUNCTIONS ===
        function togglePause() {
            if (!gameRunning) return;
            if (gamePaused) {
                resumeGame();
            } else {
                pauseGame();
            }
        }

        function pauseGame() {
            if (!gameRunning || gamePaused) return;
            gamePaused = true;
            document.getElementById('pauseOverlay').classList.add('show');
            stopBackgroundMusic();
            stopBossMusic();
        }

        function resumeGame() {
            if (!gamePaused) return;
            gamePaused = false;
            document.getElementById('pauseOverlay').classList.remove('show');
            lastFrameTime = performance.now();
            if (bossActive) {
                startBossMusic();
            } else {
                startBackgroundMusic(shieldActive);
            }
        }

        async function quitFromPause() {
            document.getElementById('pauseOverlay').classList.remove('show');
            await quitGame();
        }

        // === CONTROLS ===
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space' && gameRunning && !gamePaused) { shoot(); e.preventDefault(); }
            if (e.code === 'KeyQ' && gameRunning && !gamePaused) { switchWeapon(); e.preventDefault(); }
            if (e.code === 'KeyP' && gameRunning) { togglePause(); e.preventDefault(); }
            if (e.code === 'Escape' && gameRunning) {
                if (gamePaused) resumeGame();
                else pauseGame();
                e.preventDefault();
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            if (e.code === 'Space') laserActive = false;
        });

        const joystickArea = document.getElementById('joystickArea');
        const joystickKnob = document.getElementById('joystickKnob');
        const fireButton = document.getElementById('fireButton');
        const switchBtn = document.getElementById('switchWeaponBtn');

        function handleJoystickMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = joystickArea.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let dx = touch.clientX - centerX, dy = touch.clientY - centerY;
            const maxRadius = rect.width / 2 - 30;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > maxRadius) { dx = (dx / dist) * maxRadius; dy = (dy / dist) * maxRadius; }
            joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            touchMove.x = dx / maxRadius; touchMove.y = dy / maxRadius;
        }

        joystickArea.addEventListener('touchstart', (e) => { e.preventDefault(); joystickActive = true; handleJoystickMove(e); });
        joystickArea.addEventListener('touchmove', handleJoystickMove);
        joystickArea.addEventListener('touchend', (e) => { e.preventDefault(); joystickActive = false; touchMove.x = 0; touchMove.y = 0; joystickKnob.style.transform = 'translate(-50%, -50%)'; });

        fireButton.addEventListener('touchstart', (e) => { e.preventDefault(); autoFire = true; if (gameRunning) shoot(); });
        fireButton.addEventListener('touchend', (e) => { e.preventDefault(); autoFire = false; laserActive = false; });

        switchBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if (gameRunning) switchWeapon(); });

        document.body.addEventListener('touchmove', (e) => {
            if (e.target.closest('#joystickArea') || e.target.closest('#fireButton') || e.target.closest('#switchWeaponBtn')) e.preventDefault();
        }, { passive: false });

        initBackground();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
