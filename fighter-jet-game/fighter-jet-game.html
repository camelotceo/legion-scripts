<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legion's Space Fight</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üöÄ</text></svg>">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; background: #1a1a2e;
            font-family: 'Segoe UI', Arial, sans-serif; overflow: hidden;
        }
        #gameWrapper {
            display: flex; flex-direction: column; align-items: center; gap: 8px;
        }
        #gameContainer { position: relative; }
        #gameCanvas {
            border: 3px solid #4a4a8a; border-radius: 8px;
            box-shadow: 0 0 30px rgba(100, 100, 255, 0.3);
        }
        #ui {
            position: absolute; top: 10px; left: 10px; right: 10px;
            display: flex; justify-content: space-between; align-items: flex-start;
            color: #fff; font-size: 16px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .ui-left, .ui-right { display: flex; flex-direction: column; gap: 5px; }
        .ui-center { display: flex; flex-direction: column; align-items: center; gap: 5px; }
        .ui-buttons-row { display: flex; gap: 5px; align-items: center; }
        #levelDisplay { color: #ffd700; font-weight: bold; }
        #difficultyDisplay { color: #ff6b6b; font-size: 12px; }
        #weaponDisplay { color: #0ff; font-size: 14px; }
        #muteButton, #swapButton, #pauseButton, #quitButton {
            background: rgba(100, 100, 255, 0.3); border: 2px solid rgba(255, 255, 255, 0.5);
            color: #fff; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 14px;
        }
        #muteButton:hover, #swapButton:hover, #pauseButton:hover, #quitButton:hover { background: rgba(100, 100, 255, 0.5); }
        #muteButton.muted { background: rgba(255, 100, 100, 0.3); border-color: rgba(255, 100, 100, 0.7); }
        #swapButton { background: rgba(100, 200, 100, 0.3); border-color: rgba(100, 255, 100, 0.7); }
        #swapButton:hover { background: rgba(100, 200, 100, 0.5); }
        #pauseButton { background: rgba(255, 200, 50, 0.3); border-color: rgba(255, 220, 100, 0.7); }
        #pauseButton:hover { background: rgba(255, 200, 50, 0.5); }
        #quitButton { background: rgba(255, 100, 100, 0.3); border-color: rgba(255, 100, 100, 0.7); }
        #quitButton:hover { background: rgba(255, 100, 100, 0.5); }
        /* Weapon Panel - Above chat bar, outside game canvas */
        #weaponPanel {
            display: flex;
            flex-direction: row;
            gap: 6px;
            justify-content: center;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(100, 170, 255, 0.3);
            border-radius: 8px;
            margin: 8px auto;
            width: fit-content;
            max-width: 95%;
        }
        .weapon-slot {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #444;
            padding: 4px 8px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            min-width: 42px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        .weapon-slot:hover {
            border-color: #00ffff;
            background: rgba(0, 50, 80, 0.7);
        }
        .weapon-slot:active {
            transform: scale(0.95);
        }
        .weapon-slot.active {
            border-color: #00ff00;
            background: rgba(0, 80, 0, 0.7);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.4);
        }
        .weapon-slot.empty {
            opacity: 0.3;
            cursor: default;
            border-color: #222;
        }
        .weapon-slot .weapon-icon {
            font-size: 16px;
            line-height: 1;
        }
        .weapon-slot .weapon-ammo {
            color: #0ff;
            font-size: 10px;
            font-weight: bold;
            margin-top: 2px;
        }
        .weapon-slot.active .weapon-ammo {
            color: #0f0;
        }
        .weapon-slot.low-ammo .weapon-ammo {
            color: #ff6600;
        }
        .weapon-slot.no-ammo .weapon-ammo {
            color: #ff0000;
        }
        /* Mobile: slightly larger touch targets */
        @media (max-width: 600px) {
            #weaponPanel {
                gap: 4px;
                padding: 5px 8px;
            }
            .weapon-slot {
                min-width: 38px;
                padding: 5px 6px;
            }
            .weapon-slot .weapon-icon {
                font-size: 18px;
            }
        }
        #startScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0, 0, 0, 0.9); color: #fff; border-radius: 8px;
        }
        #gameOverScreen {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0, 0, 0, 0.95); color: #fff; border-radius: 15px;
            border: 2px solid #f66; padding: 25px 40px; max-width: 350px; z-index: 200;
            box-shadow: 0 0 30px rgba(255, 100, 100, 0.4);
        }
        #startScreen h1, #gameOverScreen h1 {
            font-size: 38px; margin-bottom: 15px; color: #6af;
            text-shadow: 0 0 20px rgba(100, 170, 255, 0.8);
        }
        #gameOverScreen h1 { font-size: 28px; color: #fff; }
        #gameOverScreen h2 { font-size: 22px; margin-bottom: 10px; color: #f66; }
        /* Victory Screen */
        #victoryScreen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            background: linear-gradient(135deg, #0a0a2e 0%, #1a0a3e 50%, #0a1a2e 100%);
            z-index: 1000; overflow-y: auto; padding: 20px; box-sizing: border-box;
        }
        #victoryScreen.show { display: flex; }
        #victoryScreen h1 {
            font-size: 48px; color: #ffd700; text-shadow: 0 0 30px #ffd700, 0 0 60px #ff8c00;
            margin-bottom: 10px; animation: victoryPulse 1s ease-in-out infinite;
        }
        @keyframes victoryPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        #victoryScreen h2 { font-size: 24px; color: #4ade80; margin-bottom: 20px; }
        .victory-stats {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;
            background: rgba(0,0,0,0.5); padding: 20px; border-radius: 15px;
            border: 2px solid #ffd700; margin-bottom: 20px; max-width: 400px;
        }
        .victory-stat { text-align: center; }
        .victory-stat .label { color: #aaa; font-size: 12px; }
        .victory-stat .value { color: #fff; font-size: 24px; font-weight: bold; }
        .boss-gallery {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 10px;
            margin: 20px 0; max-width: 600px;
        }
        .boss-gallery .boss-card {
            background: rgba(0,0,0,0.6); border: 2px solid #666; border-radius: 10px;
            padding: 10px; text-align: center; width: 80px;
        }
        .boss-gallery .boss-card.defeated { border-color: #4ade80; }
        .boss-gallery .boss-card .boss-icon { font-size: 30px; }
        .boss-gallery .boss-card .boss-name { font-size: 8px; color: #aaa; margin-top: 5px; }
        .victory-email {
            margin: 20px 0; text-align: center;
        }
        .victory-email input {
            padding: 12px 20px; font-size: 16px; border-radius: 25px;
            border: 2px solid #ffd700; background: rgba(0,0,0,0.5);
            color: #fff; width: 280px; margin-right: 10px;
        }
        .victory-email button {
            padding: 12px 25px; font-size: 16px; border-radius: 25px;
            border: none; background: linear-gradient(135deg, #ffd700, #ff8c00);
            color: #000; font-weight: bold; cursor: pointer;
        }
        .victory-email button:hover { transform: scale(1.05); }
        .victory-email .saved { color: #4ade80; margin-top: 10px; }
        #confettiCanvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 1001;
        }
        .btn {
            padding: 12px 35px; font-size: 18px;
            background: linear-gradient(135deg, #4a6cf7, #6a4cf7);
            color: #fff; border: none; border-radius: 30px; cursor: pointer;
            margin: 8px; box-shadow: 0 5px 20px rgba(100, 100, 255, 0.4);
        }
        .btn:hover { transform: scale(1.05); }
        .difficulty-section { margin: 20px 0; text-align: center; }
        .difficulty-section h3 { color: #aaa; margin-bottom: 15px; font-size: 16px; }
        .difficulty-btns { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        .diff-btn {
            padding: 10px 20px; font-size: 14px; border: 2px solid; border-radius: 20px;
            cursor: pointer; background: transparent; transition: all 0.3s;
        }
        .diff-btn.easy { color: #4ade80; border-color: #4ade80; }
        .diff-btn.medium { color: #facc15; border-color: #facc15; }
        .diff-btn.hard { color: #f97316; border-color: #f97316; }
        .diff-btn.expert { color: #ef4444; border-color: #ef4444; }
        .diff-btn:hover, .diff-btn.selected { color: #fff; }
        .diff-btn.easy:hover, .diff-btn.easy.selected { background: #4ade80; }
        .diff-btn.medium:hover, .diff-btn.medium.selected { background: #facc15; color: #000; }
        .diff-btn.hard:hover, .diff-btn.hard.selected { background: #f97316; }
        .diff-btn.expert:hover, .diff-btn.expert.selected { background: #ef4444; }
        .controls { margin-top: 20px; color: #aaa; text-align: center; line-height: 1.6; font-size: 13px; }
        .color-select { margin: 15px 0; display: flex; gap: 15px; justify-content: center; }
        .color-btn {
            width: 45px; height: 45px; border-radius: 50%;
            border: 3px solid transparent; cursor: pointer;
        }
        .color-btn:hover { transform: scale(1.15); }
        .color-btn.selected { border-color: #fff; box-shadow: 0 0 15px rgba(255, 255, 255, 0.6); }
        .color-btn.blue { background: linear-gradient(135deg, #3a7bd5, #2a5aa5); }
        .color-btn.pink { background: linear-gradient(135deg, #d53a7b, #a52a5a); }
        .color-label { color: #888; font-size: 12px; }
        .hidden { display: none !important; }
        #touchControls {
            display: none; position: fixed; bottom: 0; left: 0; right: 0;
            height: 200px; pointer-events: none; z-index: 100;
        }
        #joystickArea {
            position: absolute; left: 20px; bottom: 20px; width: 130px; height: 130px;
            background: rgba(255, 255, 255, 0.1); border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%; pointer-events: auto; touch-action: none;
        }
        #joystickKnob {
            position: absolute; width: 55px; height: 55px;
            background: rgba(100, 170, 255, 0.6); border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%; left: 50%; top: 50%; transform: translate(-50%, -50%);
        }
        #fireButton {
            position: absolute; right: 20px; bottom: 40px; width: 90px; height: 90px;
            background: rgba(255, 70, 70, 0.5); border: 3px solid rgba(255, 100, 100, 0.7);
            border-radius: 50%; pointer-events: auto; touch-action: none;
            display: flex; justify-content: center; align-items: center;
            color: #fff; font-size: 14px; font-weight: bold;
        }
        #switchWeaponBtn {
            position: absolute; right: 120px; bottom: 55px; width: 55px; height: 55px;
            background: rgba(100, 200, 100, 0.5); border: 3px solid rgba(100, 255, 100, 0.7);
            border-radius: 50%; pointer-events: auto; touch-action: none;
            display: flex; justify-content: center; align-items: center;
            color: #fff; font-size: 11px; font-weight: bold;
        }
        #pauseBtn {
            position: absolute; right: 20px; bottom: 145px; width: 50px; height: 50px;
            background: rgba(255, 200, 50, 0.5); border: 3px solid rgba(255, 220, 100, 0.7);
            border-radius: 50%; pointer-events: auto; touch-action: none;
            display: flex; justify-content: center; align-items: center;
            color: #fff; font-size: 20px; font-weight: bold;
        }
        #pauseOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); display: none; justify-content: center;
            align-items: center; flex-direction: column; z-index: 200;
        }
        #pauseOverlay.show { display: flex; }
        #pauseOverlay h2 { color: #ffd700; font-size: 36px; margin-bottom: 20px; }
        /* Opponent Paused Overlay */
        #opponentPausedOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); display: none; justify-content: center;
            align-items: center; flex-direction: column; z-index: 250;
        }
        #opponentPausedOverlay.show { display: flex; }
        #opponentPausedOverlay h2 { color: #fbbf24; font-size: 32px; margin-bottom: 10px; }
        #opponentPausedOverlay p { color: #fff; font-size: 16px; margin-bottom: 20px; }
        .waiting-spinner {
            width: 40px; height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top-color: #fbbf24;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        /* Opponent Left Overlay */
        #opponentLeftOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); display: none; justify-content: center;
            align-items: center; flex-direction: column; z-index: 260;
        }
        #opponentLeftOverlay.show { display: flex; }
        #opponentLeftOverlay h2 { color: #ef4444; font-size: 32px; margin-bottom: 10px; }
        #opponentLeftOverlay p { color: #fff; font-size: 16px; margin-bottom: 20px; }
        .pause-btn {
            padding: 12px 30px; font-size: 16px; margin: 10px;
            background: linear-gradient(135deg, #4a6cf7, #6a4cf7);
            color: #fff; border: none; border-radius: 25px; cursor: pointer;
        }
        .pause-btn:hover { transform: scale(1.05); }
        .pause-btn.quit { background: linear-gradient(135deg, #f74a4a, #f76a4a); }
        .leaderboard { margin: 15px 0; max-height: 180px; overflow-y: auto; }
        .leaderboard h3 { color: #ffd700; margin-bottom: 10px; font-size: 16px; }
        .leaderboard-list { list-style: none; padding: 0; margin: 0; }
        .leaderboard-list li {
            display: flex; justify-content: space-between; padding: 5px 15px;
            background: rgba(255, 255, 255, 0.05); margin: 3px 0; border-radius: 5px; font-size: 13px;
        }
        .leaderboard-list li:nth-child(1) { background: rgba(255, 215, 0, 0.2); color: #ffd700; }
        .leaderboard-list li:nth-child(2) { background: rgba(192, 192, 192, 0.2); color: #c0c0c0; }
        .leaderboard-list li:nth-child(3) { background: rgba(205, 127, 50, 0.2); color: #cd7f32; }
        .leaderboard-list .rank { width: 20px; font-weight: bold; }
        .leaderboard-list .name { flex: 1; text-align: left; margin-left: 5px; }
        .leaderboard-list .score { font-weight: bold; }
        /* Multi-column leaderboard grid */
        .leaderboard-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 15px 0; }
        .leaderboard-column { background: rgba(0,0,0,0.3); border-radius: 8px; padding: 8px; min-width: 0; }
        .leaderboard-column h4 { color: #fff; font-size: 11px; margin: 0 0 8px 0; text-align: center; padding: 4px; border-radius: 4px; }
        .leaderboard-column h4.easy { background: #4ade80; color: #000; }
        .leaderboard-column h4.medium { background: #facc15; color: #000; }
        .leaderboard-column h4.hard { background: #f97316; color: #000; }
        .leaderboard-column h4.expert { background: #ef4444; color: #fff; }
        .leaderboard-column .leaderboard-list li { padding: 3px 6px; font-size: 10px; }
        .leaderboard-column .leaderboard-list .rank { width: 16px; }
        .leaderboard-column .leaderboard-list .name { margin-left: 3px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .leaderboard-column .leaderboard-list .time { display: none; }
        @media (max-width: 700px) { .leaderboard-grid { grid-template-columns: repeat(2, 1fr); } }
                #bossHealthContainer {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            width: 300px; display: none; flex-direction: column; align-items: center;
        }
        #bossHealthContainer.show { display: flex; }
        #bossName { color: #ff4444; font-size: 14px; font-weight: bold; margin-bottom: 5px; text-shadow: 0 0 10px #ff0000; }
        #bossHealthBar {
            width: 100%; height: 20px; background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff4444; border-radius: 10px; overflow: hidden;
        }
        #bossHealthFill {
            height: 100%; background: linear-gradient(90deg, #ff0000, #ff4444, #ff6666);
            transition: width 0.2s; width: 100%;
        }
        #bossTaunt {
            position: absolute; top: 120px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8); color: #ff6666; padding: 10px 20px;
            border-radius: 10px; font-size: 16px; font-weight: bold; display: none;
            border: 2px solid #ff4444; text-align: center; max-width: 80%;
            animation: tauntPulse 0.5s ease-in-out;
        }
        #bossTaunt.show { display: block; }
        @keyframes tauntPulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
        }
        #touchControls.show { display: block; }
        /* Online Players Bar (Top) */
        #onlinePlayersBar {
            display: none; width: 800px; max-width: 100vw;
            background: rgba(0, 0, 0, 0.85); border: 2px solid rgba(100, 170, 255, 0.4);
            border-radius: 8px; padding: 8px 12px;
        }
        #onlinePlayersBar.show { display: block; }
        #onlinePlayersBar .bar-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid rgba(100, 170, 255, 0.2);
        }
        #onlinePlayersBar .bar-title { color: #6af; font-size: 11px; font-weight: bold; }
        #onlinePlayersBar .player-count { color: #888; font-size: 10px; }
        #onlinePlayersList {
            display: flex; flex-wrap: wrap; gap: 6px; max-height: 80px; overflow-y: auto;
        }
        #onlinePlayersList .online-player {
            display: flex; align-items: center; gap: 6px; padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05); border-radius: 4px; font-size: 11px;
        }
        #onlinePlayersList .online-player.you { background: rgba(100, 170, 255, 0.2); border: 1px solid #6af; }
        #onlinePlayersList .online-player.boss-defeated { background: rgba(255, 215, 0, 0.15); }
        #onlinePlayersList .online-player .status-dot {
            width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0;
        }
        #onlinePlayersList .online-player .status-dot.lobby { background: #facc15; }
        #onlinePlayersList .online-player .status-dot.playing { background: #4ade80; }
        #onlinePlayersList .online-player .status-dot.boss { background: #ef4444; animation: pulse 1s infinite; }
        #onlinePlayersList .online-player .status-dot.dead { background: #666; }
        #onlinePlayersList .online-player .p-name { color: #fff; max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        #onlinePlayersList .online-player .p-score { color: #4ade80; font-weight: bold; }
        #onlinePlayersList .online-player .p-emoji { font-size: 12px; }
        #onlinePlayersList .online-player .watch-btn {
            background: rgba(100, 170, 255, 0.3); border: 1px solid #6af; color: #6af;
            padding: 1px 5px; border-radius: 3px; font-size: 9px; cursor: pointer;
        }
        #onlinePlayersList .online-player .watch-btn:hover { background: rgba(100, 170, 255, 0.5); }
        /* Legacy sidebar - hidden but kept for compatibility */
        #livePlayersSidebar { display: none !important; }
        .live-player {
            display: flex; flex-direction: column; padding: 6px 8px; margin: 4px 0;
            border-radius: 6px; font-size: 11px; background: rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
        }
        .live-player.you { background: rgba(100, 170, 255, 0.2); border: 1px solid #6af; }
        .live-player.boss-defeated { background: rgba(255, 215, 0, 0.15); border: 1px solid #ffd700; }
        .live-player.action-flash { animation: actionFlash 0.4s ease-in-out 1; }
        .live-player.dying { animation: deathAnimation 3s ease-out forwards; }
        .live-player .player-row { display: flex; align-items: center; justify-content: space-between; }
        .live-player .player-info { display: flex; align-items: center; flex: 1; min-width: 0; }
        .live-player .player-name { color: #fff; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .live-player .player-score { color: #4ade80; font-weight: bold; margin-left: 5px; }
        .live-player .player-status { width: 8px; height: 8px; border-radius: 50%; margin-right: 5px; flex-shrink: 0; }
        .live-player .player-status.lobby { background: #facc15; }
        .live-player .player-status.playing { background: #4ade80; }
        .live-player .player-status.boss { background: #ef4444; animation: pulse 1s infinite; }
        .live-player .player-status.dead { background: #666; }
        .live-player .player-action { display: flex; align-items: center; margin-top: 3px; font-size: 10px; color: #aaa; }
        .live-player .action-emoji { margin-right: 4px; font-size: 12px; }
        .live-player .action-text { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .live-player .player-meta { display: flex; justify-content: space-between; margin-top: 3px; font-size: 9px; color: #888; }
        .live-player .player-timer { color: #6af; }
        .live-player .player-level { color: #facc15; }
        .live-player .watch-btn {
            background: rgba(100, 170, 255, 0.3); border: 1px solid #6af; color: #6af;
            padding: 2px 6px; border-radius: 3px; font-size: 9px; cursor: pointer; margin-top: 4px;
        }
        .live-player .watch-btn:hover { background: rgba(100, 170, 255, 0.5); }
        .live-player .spectator-count { font-size: 9px; color: #888; margin-left: auto; }
        @keyframes actionFlash { 0%, 100% { background: rgba(255, 255, 255, 0.05); } 50% { background: rgba(100, 255, 100, 0.4); } }
        @keyframes deathAnimation {
            0% { background: rgba(255, 50, 50, 0.6); opacity: 1; }
            10% { background: rgba(255, 255, 255, 0.1); }
            20% { background: rgba(255, 50, 50, 0.6); }
            30% { background: rgba(255, 255, 255, 0.1); }
            40% { background: rgba(255, 50, 50, 0.6); }
            50% { background: rgba(255, 255, 255, 0.1); opacity: 1; }
            100% { background: rgba(100, 100, 100, 0.2); opacity: 0; }
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        /* Spectator Mode Styles - Multiple resizable PiP windows */
        .spectator-window {
            display: flex; flex-direction: column; position: fixed; z-index: 500;
            background: rgba(0, 0, 0, 0.95); border: 2px solid #4a6cf7; border-radius: 10px;
            font-family: Arial, sans-serif; min-width: 200px; min-height: 180px;
            resize: both; overflow: hidden;
        }
        .spectator-window .spec-header {
            display: flex; align-items: center; justify-content: space-between; padding: 6px 10px;
            background: rgba(74, 108, 247, 0.3); border-bottom: 1px solid #4a6cf7;
            cursor: move; flex-shrink: 0; user-select: none;
        }
        .spectator-window .spec-title { color: #6af; font-weight: bold; font-size: 12px; }
        .spectator-window .spec-info { color: #aaa; font-size: 10px; margin-left: 8px; }
        .spectator-window .spec-close {
            padding: 2px 8px; font-size: 14px; background: rgba(255, 100, 100, 0.3);
            border: 1px solid #f66; border-radius: 4px; color: #f66; cursor: pointer; line-height: 1;
        }
        .spectator-window .spec-close:hover { background: rgba(255, 100, 100, 0.5); }
        .spectator-window .spec-canvas-container {
            flex: 1; display: flex; justify-content: center; align-items: center;
            background: #000; overflow: hidden;
        }
        .spectator-window .spec-canvas { width: 100%; height: 100%; background: #000; }
        .spectator-window .spec-stats {
            display: flex; justify-content: space-around; padding: 4px 8px;
            background: rgba(0, 0, 0, 0.5); border-top: 1px solid #333; font-size: 10px; flex-shrink: 0;
        }
        .spectator-window .spec-stat { color: #aaa; }
        .spectator-window .spec-stat span { color: #fff; font-weight: bold; }
        /* Container for all spectator windows */
        #spectatorContainer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 499; }
        #spectatorContainer .spectator-window { pointer-events: auto; }
        /* Modal Styles */
        .modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); display: none; justify-content: center;
            align-items: center; z-index: 300; border-radius: 8px;
        }
        .modal-overlay.show { display: flex; }
        .modal {
            background: linear-gradient(135deg, #1a1a3e, #2a2a4e); border: 2px solid #4a6cf7;
            border-radius: 15px; padding: 25px; max-width: 350px; width: 90%;
            text-align: center; box-shadow: 0 0 30px rgba(100, 100, 255, 0.4);
        }
        .modal h2 { color: #6af; margin-bottom: 20px; font-size: 22px; }
        .modal-section { margin: 15px 0; }
        .modal-section label { color: #aaa; font-size: 12px; display: block; margin-bottom: 8px; }
        #playerNameInput {
            padding: 10px 15px; font-size: 14px; border: 2px solid #4a6cf7; border-radius: 8px;
            background: rgba(0, 0, 0, 0.5); color: #fff; text-align: center; width: 100%;
        }
        #playerNameInput::placeholder { color: #666; }
        #playerNameInput:focus { outline: none; border-color: #6af; }
        .modal .color-select { margin: 10px 0; }
        .modal .difficulty-btns { flex-wrap: wrap; }
        .modal .diff-btn { margin: 3px; padding: 8px 15px; font-size: 12px; }
        .modal-btn {
            padding: 12px 30px; font-size: 16px; margin-top: 15px;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: #000; border: none; border-radius: 25px; cursor: pointer; font-weight: bold;
        }
        .modal-btn:hover { transform: scale(1.05); }
        /* Instructions Modal */
        #instructionsModal .modal { max-width: 480px; }
        #instructionsModal .instructions-content { text-align: left; color: #ccc; font-size: 12px; line-height: 1.7; }
        #instructionsModal .instructions-content p { margin: 6px 0; }
        #instructionsModal .key { background: #4a6cf7; color: #fff; padding: 2px 8px; border-radius: 4px; font-size: 11px; }
        #instructionsModal .pickup { color: #6af; }
        #instructionsModal .pickup-green { color: #4ade80; }
        #instructionsModal .pickup-red { color: #ff6b6b; }
        #instructionsModal .pickup-blue { color: #60a5fa; }
        #instructionsModal .pickup-gold { color: #ffd700; }
        #instructionsModal .danger { color: #ff4444; }
        #instructionsModal .section-title { color: #6af; margin-top: 12px !important; font-weight: bold; }
        .close-modal {
            padding: 10px 25px; font-size: 14px; margin-top: 15px;
            background: #555; color: #fff; border: none; border-radius: 20px; cursor: pointer;
        }
        .close-modal:hover { background: #666; }
        /* Respawn Modal */
        #respawnModal .modal { max-width: 420px; text-align: center; }
        #respawnModal h2 { color: #ffd700; margin-bottom: 10px; }
        #respawnModal .respawn-info { color: #aaa; font-size: 14px; margin: 10px 0; }
        #respawnModal .respawn-level { color: #4ade80; font-size: 20px; font-weight: bold; }
        #respawnModal .respawn-lives { display: flex; justify-content: center; gap: 5px; margin: 15px 0; }
        #respawnModal .respawn-lives .life { width: 20px; height: 20px; background: #4ade80; border-radius: 50%; }
        #respawnModal .respawn-lives .life.used { background: #333; }
        #respawnModal .email-section { margin: 20px 0; }
        #respawnModal .email-input { width: 100%; padding: 12px; font-size: 14px; border: 2px solid #444; background: #2a2a4e; color: #fff; border-radius: 8px; margin: 10px 0; }
        #respawnModal .email-input:focus { border-color: #4ade80; outline: none; }
        #respawnModal .key-display { background: #1a3a1a; border: 2px solid #4ade80; padding: 15px; border-radius: 10px; margin: 15px 0; }
        #respawnModal .key-code { font-size: 28px; font-weight: bold; letter-spacing: 3px; color: #4ade80; font-family: monospace; }
        #respawnModal .key-input { width: 100%; padding: 12px; font-size: 18px; text-align: center; border: 2px solid #444; background: #2a2a4e; color: #4ade80; border-radius: 8px; margin: 10px 0; font-family: monospace; letter-spacing: 2px; }
        #respawnModal .btn-respawn { padding: 12px 30px; font-size: 16px; background: linear-gradient(135deg, #4ade80, #22c55e); color: #000; border: none; border-radius: 25px; cursor: pointer; font-weight: bold; margin: 5px; }
        #respawnModal .btn-respawn:hover { transform: scale(1.05); }
        #respawnModal .btn-respawn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        #respawnModal .btn-quit { padding: 10px 20px; font-size: 14px; background: #555; color: #fff; border: none; border-radius: 20px; cursor: pointer; margin: 5px; }
        #respawnModal .status-msg { color: #888; font-size: 12px; margin-top: 10px; }
        #respawnModal .error-msg { color: #ff6b6b; font-size: 12px; margin-top: 10px; }
        /* Auth Modals (Login, Register, Verify, Profile) */
        .auth-modal .modal { max-width: 400px; text-align: center; }
        .auth-modal h2 { color: #ffd700; margin-bottom: 15px; }
        .auth-modal p { color: #aaa; font-size: 14px; margin: 10px 0; }
        .auth-modal .form-group { margin: 15px 0; text-align: left; }
        .auth-modal .form-group label { display: block; color: #888; font-size: 12px; margin-bottom: 5px; }
        .auth-modal .form-input { width: 100%; padding: 12px; font-size: 14px; border: 2px solid #444; background: #2a2a4e; color: #fff; border-radius: 8px; box-sizing: border-box; }
        .auth-modal .form-input:focus { border-color: #4ade80; outline: none; }
        .auth-modal .btn-primary { width: 100%; padding: 14px; font-size: 16px; background: linear-gradient(135deg, #4ade80, #22c55e); color: #000; border: none; border-radius: 25px; cursor: pointer; font-weight: bold; margin-top: 15px; }
        .auth-modal .btn-primary:hover { transform: scale(1.02); }
        .auth-modal .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .auth-modal .btn-secondary { width: 100%; padding: 12px; font-size: 14px; background: #555; color: #fff; border: none; border-radius: 20px; cursor: pointer; margin-top: 10px; }
        .auth-modal .btn-secondary:hover { background: #666; }
        .auth-modal .error-msg { color: #ff6b6b; font-size: 12px; margin-top: 10px; }
        .auth-modal .link-text { color: #6af; cursor: pointer; font-size: 13px; margin-top: 15px; display: inline-block; }
        .auth-modal .link-text:hover { text-decoration: underline; }
        .auth-modal .verify-code-input { font-size: 24px; text-align: center; letter-spacing: 8px; font-family: monospace; }
        /* Profile Modal */
        #profileModal .modal { max-width: 500px; }
        #profileModal .profile-header { display: flex; align-items: center; gap: 15px; margin-bottom: 20px; }
        #profileModal .profile-avatar { width: 60px; height: 60px; background: linear-gradient(135deg, #4ade80, #22c55e); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 28px; }
        #profileModal .profile-info { text-align: left; }
        #profileModal .profile-info .username { color: #fff; font-size: 20px; font-weight: bold; }
        #profileModal .profile-info .email { color: #888; font-size: 12px; }
        #profileModal .token-balance { background: linear-gradient(135deg, #1a3a1a, #0a1f0a); border: 2px solid #4ade80; padding: 15px; border-radius: 10px; margin: 15px 0; text-align: center; }
        #profileModal .token-balance .label { color: #888; font-size: 12px; }
        #profileModal .token-balance .value { color: #4ade80; font-size: 36px; font-weight: bold; }
        #profileModal .stats-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 15px 0; }
        #profileModal .stat-item { background: #2a2a4e; padding: 10px; border-radius: 8px; text-align: center; }
        #profileModal .stat-item .label { color: #888; font-size: 10px; }
        #profileModal .stat-item .value { color: #fff; font-size: 18px; font-weight: bold; }
        #profileModal .history-section { margin-top: 15px; text-align: left; }
        #profileModal .history-section h4 { color: #ffd700; font-size: 14px; margin-bottom: 10px; }
        #profileModal .history-item { display: flex; justify-content: space-between; padding: 8px; background: #1a1a2e; border-radius: 5px; margin-bottom: 5px; font-size: 12px; }
        #profileModal .history-item span { color: #aaa; }
        /* Token Display in Header */
        #tokenDisplay { display: none; align-items: center; gap: 5px; padding: 8px 15px; background: rgba(74, 222, 128, 0.1); border: 1px solid #4ade80; border-radius: 20px; margin-right: 10px; }
        #tokenDisplay .token-icon { font-size: 16px; }
        #tokenDisplay .token-count { color: #4ade80; font-weight: bold; font-size: 14px; }
        /* Auth Buttons in Header */
        #authButtons { display: flex; gap: 10px; align-items: center; position: absolute; top: 15px; right: 15px; z-index: 100; }
        #loginBtn, #profileBtn { padding: 8px 20px; font-size: 13px; background: linear-gradient(135deg, #6af, #48f); color: #fff; border: none; border-radius: 20px; cursor: pointer; }
        #loginBtn:hover, #profileBtn:hover { transform: scale(1.05); }
        #profileBtn { display: none; background: linear-gradient(135deg, #4ade80, #22c55e); color: #000; }
        /* Continue Game Button */
        #continueGameBtn { display: none; margin-top: 10px; padding: 12px 30px; font-size: 16px; background: linear-gradient(135deg, #ffd700, #ffb700); color: #000; border: none; border-radius: 25px; cursor: pointer; font-weight: bold; }
        #continueGameBtn:hover { transform: scale(1.05); }
        /* Start screen buttons */
        .start-buttons { display: flex; gap: 10px; margin: 15px 0; }
        .btn-secondary {
            padding: 10px 20px; font-size: 14px; background: transparent;
            border: 2px solid #6af; color: #6af; border-radius: 25px; cursor: pointer;
        }
        .btn-secondary:hover { background: rgba(100, 170, 255, 0.2); }
        /* Lobby sidebar - positioned at bottom of start screen */
        #lobbySidebar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 700px;
            background: rgba(0, 0, 0, 0.85); border: 2px solid rgba(100, 170, 255, 0.5);
            border-radius: 10px; padding: 12px 15px; z-index: 50;
        }
        #lobbySidebar h4 { color: #6af; font-size: 14px; margin-bottom: 6px; text-align: center; }
        #lobbySidebar .player-count { color: #4ade80; font-size: 11px; text-align: center; margin-bottom: 8px; }
        #lobbyPlayersList {
            display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;
            max-height: 150px; overflow-y: auto;
        }
        #lobbyPlayersList .live-player {
            flex: 0 1 auto; min-width: 140px; max-width: 200px;
        }
        @media (max-width: 850px) {
            #gameCanvas { max-width: 100vw; max-height: 65vh; }
            #startScreen h1, #gameOverScreen h1 { font-size: 26px; }
            .diff-btn { padding: 8px 14px; font-size: 12px; }
            #livePlayersSidebar { width: 140px; top: 50px; right: 5px; padding: 6px; max-height: 300px; }
            #livePlayersSidebar h4 { font-size: 10px; }
            #lobbySidebar { width: 95%; bottom: 10px; padding: 8px; }
            #lobbySidebar h4 { font-size: 11px; }
            #lobbyPlayersList { max-height: 100px; }
            .live-player { font-size: 9px; padding: 4px 5px; }
            .live-player .player-action { font-size: 8px; }
            .live-player .player-meta { font-size: 8px; }
            .live-player .watch-btn { font-size: 8px; padding: 2px 4px; }
            .leaderboard { max-height: 120px; }
            .leaderboard-list li { font-size: 11px; padding: 4px 10px; }
            #bossHealthContainer { width: 200px; }
            #bossTaunt { font-size: 12px; }
            .modal { padding: 20px; max-width: 300px; }
            .modal h2 { font-size: 18px; }
            .modal .diff-btn { padding: 6px 12px; font-size: 11px; }
            .start-buttons { flex-direction: column; }
        }
    </style>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
    <div id="gameWrapper">
        <!-- Online Players Bar (Top) -->
        <div id="onlinePlayersBar">
            <div class="bar-header">
                <span class="bar-title">üéÆ PLAYERS ONLINE</span>
                <span class="player-count" id="onlineCount">0 players</span>
            </div>
            <div id="onlinePlayersList"></div>
        </div>

        <div id="gameContainer">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">
            <div class="ui-left">
                <span>Score: <span id="score">0</span></span>
                <span id="levelDisplay">Level 1</span>
                <span id="difficultyDisplay">EASY</span>
            </div>
            <div class="ui-center">
                <div class="ui-buttons-row">
                    <button id="muteButton" onclick="toggleMute()">üîä</button>
                    <button id="swapButton" onclick="switchWeapon()">SWAP</button>
                    <button id="pauseButton" onclick="togglePause()">‚è∏</button>
                    <button id="quitButton" onclick="quitGame()">QUIT</button>
                </div>
                <span id="weaponDisplay">PISTOL [Q]</span>
            </div>
            <div class="ui-right">
                <span>Lives: <span id="lives">3</span></span>
            </div>
        </div>
        <!-- Coop Mode HUD -->
        <div id="coopHud" style="display:none; position:absolute; top:10px; left:10px; right:10px; color:#fff; font-size:14px; text-shadow:2px 2px 4px rgba(0,0,0,0.5);">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <div id="coopP1Stats" style="background:rgba(58,123,213,0.3); padding:8px 12px; border-radius:8px; border:2px solid #3a7bd5;">
                    <div style="font-weight:bold; color:#3a7bd5;">P1 (YOU)</div>
                    <div>Lives: <span id="coopP1Lives">1</span> | Respawns: <span id="coopP1Respawns">3</span></div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:18px; font-weight:bold; color:#ffd700;">SCORE: <span id="coopScore">0</span></div>
                    <div id="coopLevelDisplay" style="color:#ffd700;">Level 1</div>
                </div>
                <div id="coopP2Stats" style="background:rgba(34,197,94,0.3); padding:8px 12px; border-radius:8px; border:2px solid #22c55e;">
                    <div style="font-weight:bold; color:#22c55e;">P2 (<span id="coopP2Name">Partner</span>)</div>
                    <div>Lives: <span id="coopP2Lives">1</span> | Respawns: <span id="coopP2Respawns">3</span></div>
                </div>
            </div>
        </div>
        <!-- Versus Mode HUD (True PvP) -->
        <div id="versusHud" style="display:none; position:absolute; top:0; left:0; right:0; bottom:0; pointer-events:none;">
            <!-- Top bar: Health Bars -->
            <div style="position:absolute; top:10px; left:10px; right:10px; display:flex; justify-content:space-between; align-items:flex-start; gap:20px;">
                <!-- My Health -->
                <div style="flex:1; max-width:300px;">
                    <div style="display:flex; align-items:center; gap:10px; margin-bottom:5px;">
                        <span style="color:#3b82f6; font-weight:bold; font-size:14px; text-shadow:2px 2px 4px rgba(0,0,0,0.8);">YOU</span>
                        <span id="versusP1HealthText" style="color:#fff; font-size:12px; text-shadow:2px 2px 4px rgba(0,0,0,0.8);">100</span>
                    </div>
                    <div style="background:rgba(0,0,0,0.6); border:2px solid #3b82f6; border-radius:10px; height:20px; overflow:hidden;">
                        <div id="versusP1HealthBar" style="background:linear-gradient(90deg, #3b82f6, #60a5fa); height:100%; width:100%; transition:width 0.3s ease;"></div>
                    </div>
                </div>
                <!-- Round Info -->
                <div style="text-align:center; min-width:120px;">
                    <div id="versusRoundInfo" style="font-size:18px; font-weight:bold; color:#ffd700; text-shadow:2px 2px 4px rgba(0,0,0,0.8);">Round 1</div>
                    <div style="display:flex; justify-content:center; gap:10px; margin-top:5px;">
                        <span id="versusP1Wins" style="font-size:20px;">‚óã‚óã</span>
                        <span style="font-size:16px; color:#ffd700;">VS</span>
                        <span id="versusP2Wins" style="font-size:20px;">‚óã‚óã</span>
                    </div>
                </div>
                <!-- Opponent Health -->
                <div style="flex:1; max-width:300px; text-align:right;">
                    <div style="display:flex; align-items:center; justify-content:flex-end; gap:10px; margin-bottom:5px;">
                        <span id="versusP2HealthText" style="color:#fff; font-size:12px; text-shadow:2px 2px 4px rgba(0,0,0,0.8);">100</span>
                        <span id="versusP2Name" style="color:#ef4444; font-weight:bold; font-size:14px; text-shadow:2px 2px 4px rgba(0,0,0,0.8);">Opponent</span>
                    </div>
                    <div style="background:rgba(0,0,0,0.6); border:2px solid #ef4444; border-radius:10px; height:20px; overflow:hidden;">
                        <div id="versusP2HealthBar" style="background:linear-gradient(90deg, #f87171, #ef4444); height:100%; width:100%; transition:width 0.3s ease;"></div>
                    </div>
                </div>
            </div>
            <!-- PvP Round Countdown Overlay -->
            <div id="pvpCountdown" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:80px; font-weight:bold; color:#ffd700; text-shadow:0 0 30px #ffd700, 0 0 60px #ff8c00; z-index:100;"></div>
        </div>
        <div id="bossHealthContainer">
            <span id="bossName">BOSS NAME</span>
            <div id="bossHealthBar"><div id="bossHealthFill"></div></div>
        </div>
        <div id="bossTaunt"></div>
        <div id="livePlayersSidebar">
            <h4>üéÆ LIVE PLAYERS</h4>
            <div id="sidebarPlayersList"></div>
        </div>
        <div id="lobbySidebar">
            <h4>üéÆ PLAYERS ONLINE</h4>
            <div class="player-count" id="playerCount">0 players</div>
            <div id="lobbyPlayersList"></div>
        </div>
        <div id="startScreen">
            <!-- Auth Buttons -->
            <div id="authButtons">
                <div id="tokenDisplay">
                    <span class="token-icon">ü™ô</span>
                    <span class="token-count" id="tokenCount">0</span>
                </div>
                <button id="loginBtn" onclick="showLoginModal()">Login</button>
                <button id="profileBtn" onclick="showProfileModal()">Profile</button>
            </div>
            <h1>Legion's Space Fight</h1>
            <div class="start-buttons">
                <button class="btn" onclick="openModeSelectModal()">New Game</button>
                <button class="btn-secondary" onclick="openInstructionsModal()">How to Play</button>
            </div>
            <button id="continueGameBtn" onclick="continueSavedGame()">Continue Saved Game</button>
            <div id="startLeaderboard">
                <h3 style="color: #ffd700; margin-bottom: 10px; font-size: 16px;">üèÜ High Scores</h3>
                <div class="leaderboard-grid" id="leaderboardGrid">
                    <div class="leaderboard-column">
                        <h4 class="easy">EASY</h4>
                        <ul class="leaderboard-list" id="leaderboardEasy"></ul>
                    </div>
                    <div class="leaderboard-column">
                        <h4 class="medium">MEDIUM</h4>
                        <ul class="leaderboard-list" id="leaderboardMedium"></ul>
                    </div>
                    <div class="leaderboard-column">
                        <h4 class="hard">HARD</h4>
                        <ul class="leaderboard-list" id="leaderboardHard"></ul>
                    </div>
                    <div class="leaderboard-column">
                        <h4 class="expert">EXPERT</h4>
                        <ul class="leaderboard-list" id="leaderboardExpert"></ul>
                    </div>
                </div>
            </div>
        </div>
        <!-- Setup Modal -->
        <!-- Continue Game Modal -->
        <div id="continueModal" class="modal-overlay">
            <div class="modal">
                <h2>Continue Game</h2>
                <div id="continueKeySection">
                    <div class="modal-section">
                        <label>Enter Your Continue Key</label>
                        <input type="text" id="continueKeyInput" maxlength="12" placeholder="FJ-XXXXXXXXX" style="text-transform: uppercase; font-family: monospace; letter-spacing: 2px; text-align: center; font-size: 18px;">
                        <p id="continueKeyError" style="color: #ff6b6b; font-size: 12px; margin-top: 8px; display: none;"></p>
                    </div>
                    <button class="modal-btn" id="validateKeyBtn" onclick="validateContinueKey()">Validate Key</button>
                    <button class="btn-secondary" style="margin-top: 10px;" onclick="closeContinueModal()">Back</button>
                </div>
                <div id="continueDataSection" style="display: none;">
                    <div style="background: #1a3a1a; border: 2px solid #4ade80; border-radius: 10px; padding: 20px; margin: 15px 0;">
                        <p style="color: #4ade80; font-size: 14px; margin-bottom: 10px;">Welcome back!</p>
                        <p style="color: #fff; font-size: 24px; font-weight: bold;" id="continuePlayerName">PlayerName</p>
                        <div style="display: flex; justify-content: center; gap: 20px; margin-top: 15px;">
                            <div style="text-align: center;">
                                <p style="color: #888; font-size: 11px;">LEVEL</p>
                                <p style="color: #ffd700; font-size: 20px; font-weight: bold;" id="continueLevel">1</p>
                            </div>
                            <div style="text-align: center;">
                                <p style="color: #888; font-size: 11px;">SCORE</p>
                                <p style="color: #4ade80; font-size: 20px; font-weight: bold;" id="continueScore">0</p>
                            </div>
                            <div style="text-align: center;">
                                <p style="color: #888; font-size: 11px;">DIFFICULTY</p>
                                <p style="font-size: 20px; font-weight: bold;" id="continueDifficulty">EASY</p>
                            </div>
                        </div>
                    </div>
                    <button class="modal-btn" id="startContinueBtn" onclick="startContinuedGame()">Continue Game</button>
                    <button class="btn-secondary" style="margin-top: 10px;" onclick="closeContinueModal()">Back</button>
                </div>
            </div>
        </div>
        <!-- Mode Selection Modal -->
        <div id="modeSelectModal" class="modal-overlay">
            <div class="modal" style="max-width: 400px;">
                <h2>Select Game Mode</h2>
                <div class="mode-buttons" style="display: flex; flex-direction: column; gap: 12px; margin: 20px 0;">
                    <button class="mode-btn" onclick="selectGameMode('solo')" style="padding: 15px; background: linear-gradient(135deg, #3b82f6, #1d4ed8); border: none; border-radius: 10px; color: #fff; cursor: pointer; text-align: left; display: flex; align-items: center; gap: 15px;">
                        <span style="font-size: 28px; width: 40px; text-align: center;">1</span>
                        <div>
                            <div style="font-size: 16px; font-weight: bold;">Solo</div>
                            <div style="font-size: 11px; color: #93c5fd;">Classic single player</div>
                        </div>
                    </button>
                    <button class="mode-btn" onclick="selectGameMode('coop')" style="padding: 15px; background: linear-gradient(135deg, #22c55e, #15803d); border: none; border-radius: 10px; color: #fff; cursor: pointer; text-align: left; display: flex; align-items: center; gap: 15px;">
                        <span style="font-size: 28px; width: 40px; text-align: center;">2+</span>
                        <div>
                            <div style="font-size: 16px; font-weight: bold;">Tag Team</div>
                            <div style="font-size: 11px; color: #86efac;">2 players vs enemies</div>
                        </div>
                    </button>
                    <button class="mode-btn" onclick="selectGameMode('versus')" style="padding: 15px; background: linear-gradient(135deg, #ef4444, #b91c1c); border: none; border-radius: 10px; color: #fff; cursor: pointer; text-align: left; display: flex; align-items: center; gap: 15px;">
                        <span style="font-size: 28px; width: 40px; text-align: center;">VS</span>
                        <div>
                            <div style="font-size: 16px; font-weight: bold;">1v1</div>
                            <div style="font-size: 11px; color: #fca5a5;">Battle your friend</div>
                        </div>
                    </button>
                </div>
                <button class="btn-secondary" onclick="closeModeSelectModal()">Back</button>
            </div>
        </div>
        <!-- Multiplayer Lobby Modal -->
        <div id="lobbyModal" class="modal-overlay">
            <div class="modal" style="max-width: 420px;">
                <h2 id="lobbyTitle">MULTIPLAYER LOBBY</h2>
                <!-- Room Options (shown initially) -->
                <div id="roomOptions">
                    <div style="margin-bottom: 15px;">
                        <label style="color: #888; font-size: 12px; display: block; margin-bottom: 5px;">Your Name</label>
                        <input type="text" id="mpPlayerNameInput" maxlength="12" placeholder="Enter name..." style="width: 100%; padding: 10px; font-size: 14px;">
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 10px; margin: 15px 0;">
                        <button class="modal-btn" onclick="createRoom()" style="background: linear-gradient(135deg, #4ade80, #22c55e);">Create Room</button>
                        <div style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
                            <div style="flex: 1; height: 1px; background: #444;"></div>
                            <span style="color: #666; font-size: 12px;">OR</span>
                            <div style="flex: 1; height: 1px; background: #444;"></div>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="roomCodeInput" maxlength="6" placeholder="ROOM CODE" style="flex: 1; text-transform: uppercase; font-family: monospace; letter-spacing: 3px; text-align: center; font-size: 16px; padding: 12px;">
                            <button class="modal-btn" onclick="joinRoom()" style="margin-top: 0; padding: 12px 20px;">Join</button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
                            <div style="flex: 1; height: 1px; background: #444;"></div>
                            <span style="color: #666; font-size: 12px;">OR</span>
                            <div style="flex: 1; height: 1px; background: #444;"></div>
                        </div>
                        <button class="modal-btn" onclick="quickMatch()" style="background: linear-gradient(135deg, #a855f7, #7c3aed);">Quick Match</button>
                    </div>
                    <p id="lobbyError" style="color: #ff6b6b; font-size: 12px; display: none;"></p>
                    <button class="btn-secondary" style="margin-top: 10px;" onclick="closeLobbyModal()">Back</button>
                </div>
                <!-- Waiting Room (shown after creating/joining) -->
                <div id="waitingRoom" style="display: none;">
                    <div style="background: #1a2a3a; border: 2px solid #4a6cf7; border-radius: 10px; padding: 15px; margin: 15px 0;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <span style="color: #888; font-size: 12px;">Room Code:</span>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span id="displayRoomCode" style="font-family: monospace; font-size: 24px; color: #4ade80; letter-spacing: 3px;">ABC123</span>
                                <button onclick="copyRoomCode()" style="background: #333; border: none; color: #fff; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 11px;">Copy</button>
                            </div>
                        </div>
                        <div id="playerSlots" style="display: flex; flex-direction: column; gap: 10px;">
                            <div class="player-slot" id="slot1" style="background: #2a3a4a; border-radius: 8px; padding: 12px; display: flex; align-items: center; gap: 12px;">
                                <span style="background: #3b82f6; color: #fff; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold;">P1</span>
                                <span class="slot-name" style="flex: 1; color: #fff;">Waiting...</span>
                                <span class="ready-status" style="color: #888; font-size: 12px;"></span>
                            </div>
                            <div class="player-slot" id="slot2" style="background: #2a3a4a; border-radius: 8px; padding: 12px; display: flex; align-items: center; gap: 12px;">
                                <span style="background: #22c55e; color: #fff; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold;">P2</span>
                                <span class="slot-name" style="flex: 1; color: #666;">Waiting for player...</span>
                                <span class="ready-status" style="color: #888; font-size: 12px;"></span>
                            </div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button id="readyBtn" class="modal-btn" onclick="toggleReady()" style="background: linear-gradient(135deg, #fbbf24, #d97706); flex: 1;">Ready</button>
                        <button id="startBtn" class="modal-btn" onclick="startMultiplayerGame()" style="background: linear-gradient(135deg, #4ade80, #22c55e); flex: 1; display: none;">Start</button>
                    </div>
                    <button class="btn-secondary" style="margin-top: 10px;" onclick="leaveRoom()">Leave Room</button>
                </div>
                <!-- Matchmaking Queue (shown during quick match) -->
                <div id="matchmakingQueue" style="display: none;">
                    <div style="text-align: center; padding: 30px;">
                        <div style="font-size: 40px; margin-bottom: 15px;">üîç</div>
                        <p style="color: #fff; font-size: 16px;">Finding opponent...</p>
                        <p id="queuePosition" style="color: #888; font-size: 12px; margin-top: 10px;">Position in queue: 1</p>
                        <div class="spinner" style="margin: 20px auto; width: 40px; height: 40px; border: 3px solid #333; border-top-color: #4ade80; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                    </div>
                    <button class="btn-secondary" onclick="cancelMatchmaking()">Cancel</button>
                </div>
            </div>
        </div>
        <style>
            @keyframes spin { to { transform: rotate(360deg); } }
            @keyframes floatUp {
                0% { opacity: 1; transform: translateX(-50%) translateY(0); }
                100% { opacity: 0; transform: translateX(-50%) translateY(-50px); }
            }
            .mode-btn:hover { transform: scale(1.02); transition: transform 0.2s; }
            .player-slot.ready { border: 2px solid #4ade80; }
            .player-slot .ready-status.is-ready { color: #4ade80 !important; }
        </style>
        <div id="setupModal" class="modal-overlay">
            <div class="modal">
                <h2>New Game</h2>
                <div class="modal-section">
                    <label>Your Name (or leave blank for random)</label>
                    <input type="text" id="playerNameInput" maxlength="12" placeholder="Enter name...">
                </div>
                <div class="modal-section">
                    <label>Choose Your Jet</label>
                    <div class="color-select">
                        <button class="color-btn blue selected" onclick="selectColor('blue')"></button>
                        <button class="color-btn pink" onclick="selectColor('pink')"></button>
                    </div>
                </div>
                <div class="modal-section">
                    <label>Select Difficulty</label>
                    <div class="difficulty-btns">
                        <button class="diff-btn easy selected" onclick="selectDifficulty('easy')">EASY</button>
                        <button class="diff-btn medium" onclick="selectDifficulty('medium')">MEDIUM</button>
                        <button class="diff-btn hard" onclick="selectDifficulty('hard')">HARD</button>
                        <button class="diff-btn expert" onclick="selectDifficulty('expert')">EXPERT</button>
                    </div>
                </div>
                <button class="modal-btn" onclick="startGame()">Start Game</button>
                <button class="btn-secondary" style="margin-top: 10px;" onclick="closeSetupModal()">Back</button>
            </div>
        </div>
        <!-- Instructions Modal -->
        <div id="instructionsModal" class="modal-overlay">
            <div class="modal">
                <h2>How to Play</h2>
                <div class="instructions-content">
                    <p class="section-title">Controls:</p>
                    <p><span class="key">WASD</span> or <span class="key">Arrows</span> - Move your jet</p>
                    <p><span class="key">Space</span> - Shoot</p>
                    <p><span class="key">Q</span> - Swap weapon</p>
                    <p><span class="key">P</span> or <span class="key">ESC</span> - Pause</p>

                    <p class="section-title">Weapons (collect to unlock):</p>
                    <p><span class="pickup">MG</span> - Machine Gun (rapid fire)</p>
                    <p><span class="pickup">BZ</span> - Bazooka (explosive)</p>
                    <p><span class="pickup">LS</span> - Laser Beam (continuous)</p>

                    <p class="section-title">Power-ups:</p>
                    <p><span class="pickup-green">Shield</span> - Temporary invincibility</p>
                    <p><span class="pickup-red">MAX Heart</span> - Restores ALL lives</p>
                    <p><span class="pickup-gold">+1 / +2 / +3 UP</span> - Adds extra lives</p>
                    <p><span class="pickup-blue">Ghost</span> - 5 sec invisible (can't shoot, can collect)</p>
                    <p><span class="pickup">Bomb</span> - Clears enemies on screen</p>

                    <p class="section-title">Hazards (avoid!):</p>
                    <p><span class="danger">Mines</span> - Floating explosives (-1 life)</p>
                    <p><span class="danger">Walls</span> - Block bullets, instant death on touch</p>
                    <p style="color: #888; font-size: 11px;">(Tip: Hide behind walls to block enemy fire!)</p>

                    <p style="margin-top: 12px; color: #ffd700;">Defeat 6 bosses to win the game!</p>
                </div>
                <button class="close-modal" onclick="closeInstructionsModal()">Got it!</button>
            </div>
        </div>
        <!-- Respawn Modal -->
        <div id="respawnModal" class="modal-overlay">
            <div class="modal">
                <h2>üíÄ You Died!</h2>
                <p class="respawn-level">Level <span id="respawnLevel">1</span></p>
                <p class="respawn-info">Score: <span id="respawnScore">0</span></p>
                <div class="respawn-lives" id="respawnLives">
                    <!-- Lives indicators will be added dynamically -->
                </div>
                <p class="respawn-info" id="respawnMessage">Respawning...</p>

                <!-- Free respawn section (unauthenticated players) -->
                <div id="freeRespawnSection">
                    <button class="btn-respawn" onclick="doFreeRespawn()">Continue (Free)</button>
                    <p class="status-msg"><span id="respawnsRemaining">3</span> free continues remaining</p>
                </div>

                <!-- Email required section (hidden initially) -->
                <div id="emailSection" style="display: none;">
                    <p class="respawn-info">You've used all free respawns for this level.</p>
                    <p class="respawn-info">Enter your email to get a continue key:</p>
                    <div class="email-section">
                        <input type="email" class="email-input" id="respawnEmail" placeholder="your@email.com">
                        <button class="btn-respawn" id="sendKeyBtn" onclick="requestContinueKey()">Get Key</button>
                    </div>
                    <p id="emailError" class="error-msg" style="display: none;"></p>
                </div>

                <!-- Key received section (hidden initially) -->
                <div id="keyReceivedSection" style="display: none;">
                    <p class="respawn-info">Your continue key (also sent to email):</p>
                    <div class="key-display">
                        <span class="key-code" id="displayedKey" style="font-size: 24px;">FJ-XXXXXXXXX</span>
                    </div>
                    <p style="color: #888; font-size: 11px; margin: 8px 0;">Key is saved for this session. Click Continue to respawn.</p>
                    <input type="text" class="key-input" id="respawnKeyInput" placeholder="FJ-XXXXXXXXX" maxlength="15" style="display: none;">
                    <button class="btn-respawn" onclick="validateAndContinue()">Continue</button>
                </div>

                <!-- Returning player section (hidden initially) -->
                <div id="returningPlayerSection" style="display: none;">
                    <p class="respawn-info">Welcome back! Enter your key to continue:</p>
                    <input type="text" class="key-input" id="returningKeyInput" placeholder="FJ-XXXXXXXXX" maxlength="12">
                    <button class="btn-respawn" onclick="validateReturningPlayer()">Resume Game</button>
                    <p id="keyError" class="error-msg" style="display: none;"></p>
                </div>

                <div style="margin-top: 15px;">
                    <button class="btn-quit" onclick="quitFromRespawn()">Quit to Menu</button>
                </div>
            </div>
        </div>

        <!-- Username Taken Modal -->
        <div id="usernameTakenModal" class="modal-overlay auth-modal">
            <div class="modal">
                <h2>Username Taken</h2>
                <p>The username "<span id="takenUsername"></span>" is already in use.</p>
                <p style="margin-top: 10px; color: #aaa;">If this is your account, you can login. Otherwise, please choose a different name.</p>
                <button class="btn-primary" onclick="hideUsernameTakenModal(); showLoginModal();">Login to My Account</button>
                <button class="btn-secondary" onclick="hideUsernameTakenModal();">Choose Different Name</button>
            </div>
        </div>

        <!-- Login Modal -->
        <div id="loginModal" class="modal-overlay auth-modal">
            <div class="modal">
                <h2>Login</h2>
                <p>Sign in to continue your game</p>
                <div class="form-group">
                    <label>Email or Username</label>
                    <input type="text" id="loginEmailOrUsername" class="form-input" placeholder="email@example.com">
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" id="loginPassword" class="form-input" placeholder="Enter password" onkeypress="if(event.key==='Enter')loginWithPassword()">
                </div>
                <p id="loginError" class="error-msg" style="display: none;"></p>
                <button id="loginBtn2" class="btn-primary" onclick="loginWithPassword()">Login</button>
                <p class="link-text" onclick="hideLoginModal(); showRegisterModal();">Don't have an account? Create one</p>
                <button class="btn-secondary" onclick="hideLoginModal()">Cancel</button>
            </div>
        </div>

        <!-- Registration Modal -->
        <div id="registerModal" class="modal-overlay auth-modal">
            <div class="modal">
                <h2>Create Account</h2>
                <p id="registerPrompt">Create an account to save your progress and continue from where you left off!</p>
                <input type="hidden" id="registerFromDeath" value="">
                <div class="form-group">
                    <label>Username</label>
                    <input type="text" id="registerUsername" class="form-input" placeholder="Choose a username" maxlength="12">
                </div>
                <div class="form-group">
                    <label>Email</label>
                    <input type="email" id="registerEmail" class="form-input" placeholder="email@example.com">
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" id="registerPassword" class="form-input" placeholder="At least 6 characters">
                </div>
                <div class="form-group">
                    <label>Confirm Password</label>
                    <input type="password" id="registerConfirmPassword" class="form-input" placeholder="Confirm password" onkeypress="if(event.key==='Enter')registerWithPassword()">
                </div>
                <p id="registerError" class="error-msg" style="display: none;"></p>
                <button id="registerBtn" class="btn-primary" onclick="registerWithPassword()">Create Account</button>
                <p class="link-text" onclick="hideRegisterModal(); showLoginModal();">Already have an account? Login</p>
                <button class="btn-secondary" id="registerCancelBtn" onclick="hideRegisterModal(); handleRegisterCancel();">No thanks, restart game</button>
            </div>
        </div>

        <!-- Email Verification Modal -->
        <div id="verifyModal" class="modal-overlay auth-modal">
            <div class="modal">
                <h2>Verify Email</h2>
                <p>Enter the 6-digit code sent to your email</p>
                <input type="hidden" id="verifyEmail" value="">
                <div class="form-group">
                    <label>Verification Code</label>
                    <input type="text" id="verifyCode" class="form-input verify-code-input" placeholder="000000" maxlength="6" onkeypress="if(event.key==='Enter')verifyEmailCode()">
                </div>
                <p id="verifyError" class="error-msg" style="display: none;"></p>
                <button id="verifyBtn" class="btn-primary" onclick="verifyEmailCode()">Verify</button>
                <p class="link-text" onclick="resendVerificationCode()">Didn't receive code? Resend</p>
                <button class="btn-secondary" onclick="hideVerifyModal()">Cancel</button>
            </div>
        </div>

        <!-- Profile Modal -->
        <div id="profileModal" class="modal-overlay auth-modal">
            <div class="modal">
                <div class="profile-header">
                    <div class="profile-avatar">üë§</div>
                    <div class="profile-info">
                        <div class="username" id="profileUsername">Player</div>
                        <div class="email" id="profileEmail">email@example.com</div>
                    </div>
                </div>
                <div class="token-balance">
                    <div class="label">TOKENS</div>
                    <div class="value" id="profileTokens">0</div>
                </div>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="label">GAMES</div>
                        <div class="value" id="statGames">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="label">BEST SCORE</div>
                        <div class="value" id="statBestScore">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="label">BEST LEVEL</div>
                        <div class="value" id="statBestLevel">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="label">VICTORIES</div>
                        <div class="value" id="statVictories">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="label">PLAYTIME</div>
                        <div class="value" id="statPlaytime">0m</div>
                    </div>
                </div>
                <div class="history-section">
                    <h4>Recent Games</h4>
                    <div id="profileHistory"></div>
                </div>
                <button class="btn-secondary" onclick="logout()">Logout</button>
                <button class="btn-secondary" onclick="hideProfileModal()">Close</button>
            </div>
        </div>

        <div id="gameOverScreen" class="hidden">
            <h2>Game Over</h2>
            <h1>Score: <span id="finalScore">0</span></h1>
            <p style="color: #aaa; margin-bottom: 10px;">Level <span id="finalLevel">1</span> | <span id="finalDifficulty">EASY</span></p>
            <p id="scoreSavedMsg" style="color: #4ade80; margin-bottom: 10px; display: none;"></p>
            <div id="gameOverLeaderboard">
                <h3 style="color: #ffd700; margin-bottom: 10px; font-size: 16px;">üèÜ High Scores</h3>
                <div class="leaderboard-grid" id="gameOverLeaderboardGrid">
                    <div class="leaderboard-column">
                        <h4 class="easy">EASY</h4>
                        <ul class="leaderboard-list" id="gameOverLeaderboardEasy"></ul>
                    </div>
                    <div class="leaderboard-column">
                        <h4 class="medium">MEDIUM</h4>
                        <ul class="leaderboard-list" id="gameOverLeaderboardMedium"></ul>
                    </div>
                    <div class="leaderboard-column">
                        <h4 class="hard">HARD</h4>
                        <ul class="leaderboard-list" id="gameOverLeaderboardHard"></ul>
                    </div>
                    <div class="leaderboard-column">
                        <h4 class="expert">EXPERT</h4>
                        <ul class="leaderboard-list" id="gameOverLeaderboardExpert"></ul>
                    </div>
                </div>
            </div>
            <button class="btn" onclick="startGame()">Play Again</button>
            <button class="btn" style="background: #555;" onclick="backToMenu()">Menu</button>
        </div>

        <!-- Victory Screen -->
        <div id="victoryScreen">
            <canvas id="confettiCanvas"></canvas>
            <h1>üèÜ VICTORY! üèÜ</h1>
            <h2>You have conquered Legion Supreme!</h2>

            <div class="victory-stats">
                <div class="victory-stat">
                    <div class="label">FINAL SCORE</div>
                    <div class="value" id="victoryScore">0</div>
                </div>
                <div class="victory-stat">
                    <div class="label">TIME PLAYED</div>
                    <div class="value" id="victoryTime">0:00</div>
                </div>
                <div class="victory-stat">
                    <div class="label">ENEMIES DESTROYED</div>
                    <div class="value" id="victoryEnemies">0</div>
                </div>
                <div class="victory-stat">
                    <div class="label">BOSSES DEFEATED</div>
                    <div class="value" id="victoryBosses">6</div>
                </div>
            </div>

            <h3 style="color: #ffd700; margin-bottom: 10px;">‚öîÔ∏è Bosses Vanquished ‚öîÔ∏è</h3>
            <div class="boss-gallery" id="bossGallery"></div>

            <div class="victory-email">
                <p style="color: #aaa; margin-bottom: 10px;">Enter your email to save your legendary victory!</p>
                <input type="email" id="victoryEmail" placeholder="your@email.com">
                <button onclick="saveVictoryEmail()">Save</button>
                <p class="saved" id="emailSavedMsg" style="display: none;">‚úì Victory saved!</p>
            </div>

            <button class="btn" style="margin-top: 20px;" onclick="closeVictoryScreen()">Play Again</button>
        </div>

        <div id="pauseOverlay">
            <h2>PAUSED</h2>
            <button class="pause-btn" onclick="resumeGame()">Resume</button>
            <button class="pause-btn quit" onclick="quitFromPause()">Quit Game</button>
        </div>

        <!-- Opponent Paused Overlay -->
        <div id="opponentPausedOverlay">
            <h2>WAITING</h2>
            <p id="opponentPausedMessage">Opponent paused the game</p>
            <div class="waiting-spinner"></div>
        </div>

        <!-- Opponent Left Overlay -->
        <div id="opponentLeftOverlay">
            <h2>OPPONENT LEFT</h2>
            <p id="opponentLeftMessage">Your opponent has left the game</p>
            <button class="pause-btn" onclick="quitFromOpponentLeft()">Return to Menu</button>
        </div>
    </div>

        <!-- Weapon Panel (Above chat bar) -->
        <div id="weaponPanel"></div>

    </div><!-- End gameWrapper -->

    <div id="touchControls">
        <div id="joystickArea"><div id="joystickKnob"></div></div>
        <div id="pauseBtn" onclick="togglePause()">‚è∏</div>
        <div id="switchWeaponBtn">SWAP</div>
        <div id="fireButton">FIRE</div>
    </div>

    <!-- Container for multiple spectator windows -->
    <div id="spectatorContainer"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const logicalWidth = 800;
        const logicalHeight = 600;
        const scaleFactor = Math.min(dpr, 2);
        canvas.width = logicalWidth * scaleFactor;
        canvas.height = logicalHeight * scaleFactor;
        canvas.style.width = logicalWidth + 'px';
        canvas.style.height = logicalHeight + 'px';
        ctx.scale(scaleFactor, scaleFactor);

        let lastFrameTime = performance.now();
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let backgroundMusic = null;
        let isMuted = false;

        // === SESSION & AUTH MANAGEMENT ===
        const API_BASE = window.location.origin;

        // Debug logging to server for PvP troubleshooting
        function serverLog(message, details = {}, type = 'info') {
            // Also log to console
            console.log(`[SERVER-LOG] ${message}`, details);

            // Send to server (fire and forget)
            fetch(`${API_BASE}/api/debug/log`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    playerId: typeof myPlayerId !== 'undefined' ? myPlayerId : 'unknown',
                    roomCode: typeof currentRoomCode !== 'undefined' ? currentRoomCode : 'none',
                    type: type,
                    message: message,
                    details: details
                })
            }).catch(() => {}); // Silently ignore errors
        }

        let sessionToken = localStorage.getItem('sessionToken');
        let deviceFingerprint = localStorage.getItem('deviceFingerprint');
        let currentGameSessionId = null;
        let gameEventQueue = [];
        let lastEventTime = 0;

        // Generate device fingerprint if not exists
        function generateDeviceFingerprint() {
            if (deviceFingerprint) return deviceFingerprint;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('fingerprint', 2, 2);
            const canvasData = canvas.toDataURL();
            const data = [
                navigator.userAgent,
                navigator.language,
                screen.width + 'x' + screen.height,
                new Date().getTimezoneOffset(),
                canvasData.substring(0, 50)
            ].join('|');
            // Simple hash
            let hash = 0;
            for (let i = 0; i < data.length; i++) {
                const char = data.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            deviceFingerprint = Math.abs(hash).toString(36) + Date.now().toString(36);
            localStorage.setItem('deviceFingerprint', deviceFingerprint);
            return deviceFingerprint;
        }
        generateDeviceFingerprint();

        // Authenticated fetch wrapper
        async function authFetch(url, options = {}) {
            const headers = {
                'Content-Type': 'application/json',
                ...(options.headers || {})
            };
            if (sessionToken) {
                headers['Authorization'] = `Bearer ${sessionToken}`;
            }
            if (deviceFingerprint) {
                headers['X-Device-Fingerprint'] = deviceFingerprint;
            }
            return fetch(url, { ...options, headers });
        }

        // Game event reporting (batched)
        function reportGameEvent(eventType, details = {}) {
            if (!currentGameSessionId) return;
            const now = Date.now();
            gameEventQueue.push({
                gameSessionId: currentGameSessionId,
                type: eventType,
                timestamp: now - (gameStartTime || now),
                level: level,
                x: player ? player.x : 0,
                y: player ? player.y : 0,
                details
            });
            // Send batch every 500ms
            if (now - lastEventTime > 500 && gameEventQueue.length > 0) {
                sendEventBatch();
                lastEventTime = now;
            }
        }

        async function sendEventBatch() {
            if (gameEventQueue.length === 0) return;
            const events = [...gameEventQueue];
            gameEventQueue = [];
            for (const event of events) {
                try {
                    await authFetch(`${API_BASE}/api/game/event`, {
                        method: 'POST',
                        body: JSON.stringify(event)
                    });
                } catch (e) {
                    console.error('Failed to send game event:', e);
                }
            }
        }

        // Start game session with server
        async function startServerGameSession() {
            if (!sessionToken) return null;
            try {
                const response = await authFetch(`${API_BASE}/api/game/start`, {
                    method: 'POST',
                    body: JSON.stringify({
                        difficulty: selectedDifficulty.toUpperCase(),
                        mode: isMultiplayer ? selectedGameMode : 'single',
                        roomCode: currentRoomCode || null
                    })
                });
                if (response.ok) {
                    const data = await response.json();
                    currentGameSessionId = data.gameSessionId;
                    return currentGameSessionId;
                }
            } catch (e) {
                console.error('Failed to start server game session:', e);
            }
            return null;
        }

        // End game session with server
        async function endServerGameSession(deathReason = 'unknown', isVictory = false) {
            if (!currentGameSessionId || !sessionToken) return;
            // Flush remaining events
            await sendEventBatch();
            try {
                await authFetch(`${API_BASE}/api/game/end`, {
                    method: 'POST',
                    body: JSON.stringify({
                        gameSessionId: currentGameSessionId,
                        score: score,
                        level: level,
                        duration: gameDuration,
                        deathReason: deathReason,
                        bossesDefeated: bossDefeated ? bossDefeated.length : 0,
                        enemiesKilled: totalEnemiesKilled || 0,
                        isVictory: isVictory
                    })
                });
            } catch (e) {
                console.error('Failed to end server game session:', e);
            }
            currentGameSessionId = null;
        }

        // === LEADERBOARD SYSTEM (Server-side JSON) ===
        const MAX_LEADERBOARD_SIZE = 10;
        let cachedLeaderboard = [];
        let allLeaderboards = { EASY: [], MEDIUM: [], HARD: [], EXPERT: [] };

        async function fetchAllLeaderboards() {
            try {
                const url = `${API_BASE}/api/leaderboard/all`;
                const response = await fetch(url);
                if (response.ok) {
                    const data = await response.json();
                    allLeaderboards = data;
                    return allLeaderboards;
                }
            } catch (e) { console.error('Failed to fetch all leaderboards:', e); }
            return allLeaderboards;
        }

        async function fetchLeaderboard(difficulty = null) {
            try {
                const diff = difficulty || selectedDifficulty.toUpperCase();
                const url = `${API_BASE}/api/leaderboard?difficulty=${diff}`;
                const response = await fetch(url);
                if (response.ok) {
                    const text = await response.text();
                    try {
                        cachedLeaderboard = JSON.parse(text);
                    } catch (parseErr) {
                        console.error('Failed to parse leaderboard JSON:', text.substring(0, 100));
                        return cachedLeaderboard;
                    }
                    return cachedLeaderboard;
                } else {
                    console.error('Leaderboard fetch failed:', response.status, response.statusText);
                }
            } catch (e) { console.error('Failed to fetch leaderboard:', e); }
            return cachedLeaderboard;
        }

        function isHighScore(newScore) {
            const currentDiffScores = allLeaderboards[selectedDifficulty.toUpperCase()] || [];
            if (currentDiffScores.length < MAX_LEADERBOARD_SIZE) return true;
            return newScore > currentDiffScores[currentDiffScores.length - 1].score;
        }

        async function addHighScore(name, newScore, difficulty, lvl, duration = 0) {
            try {
                const url = `${API_BASE}/api/leaderboard`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, score: newScore, difficulty, level: lvl, duration: duration })
                });
                if (response.ok) {
                    const text = await response.text();
                    try {
                        const data = JSON.parse(text);
                        cachedLeaderboard = data.leaderboard || [];
                        // Update allLeaderboards for this difficulty
                        allLeaderboards[difficulty.toUpperCase()] = cachedLeaderboard;
                        console.log('Score saved successfully:', cachedLeaderboard);
                    } catch (parseErr) {
                        console.error('Failed to parse save response:', text.substring(0, 100));
                    }
                    // Refresh all leaderboards display
                    await fetchAllLeaderboards();
                    renderAllLeaderboards();
                    return cachedLeaderboard;
                } else {
                    console.error('Save score failed:', response.status, response.statusText);
                }
            } catch (e) { console.error('Failed to save score:', e); }
            return cachedLeaderboard;
        }

        function formatDuration(seconds) {
            if (!seconds || seconds <= 0) return '';
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            if (mins > 0) {
                return `${mins}m${secs > 0 ? secs + 's' : ''}`;
            }
            return `${secs}s`;
        }

        function renderLeaderboardColumn(scores, listElementId) {
            const listEl = document.getElementById(listElementId);
            if (!listEl) return;
            if (!scores || scores.length === 0) {
                listEl.innerHTML = '<li style="justify-content: center; color: #666; font-size: 9px;">No scores</li>';
                return;
            }
            const top5 = scores.slice(0, 5);
            listEl.innerHTML = top5.map((entry, i) => {
                const timeStr = entry.duration ? `<span class="time" style="color:#888;font-size:9px;margin-left:4px;">${formatDuration(entry.duration)}</span>` : '';
                return `<li><span class="rank">${i + 1}.</span><span class="name">${entry.name}</span>${timeStr}<span class="score">${entry.score.toLocaleString()}</span></li>`;
            }).join('');
        }

        function renderAllLeaderboards() {
            // Start screen leaderboards
            renderLeaderboardColumn(allLeaderboards.EASY, 'leaderboardEasy');
            renderLeaderboardColumn(allLeaderboards.MEDIUM, 'leaderboardMedium');
            renderLeaderboardColumn(allLeaderboards.HARD, 'leaderboardHard');
            renderLeaderboardColumn(allLeaderboards.EXPERT, 'leaderboardExpert');
            // Game over screen leaderboards
            renderLeaderboardColumn(allLeaderboards.EASY, 'gameOverLeaderboardEasy');
            renderLeaderboardColumn(allLeaderboards.MEDIUM, 'gameOverLeaderboardMedium');
            renderLeaderboardColumn(allLeaderboards.HARD, 'gameOverLeaderboardHard');
            renderLeaderboardColumn(allLeaderboards.EXPERT, 'gameOverLeaderboardExpert');
        }

        function renderLeaderboardFromCache(listElementId) {
            const listEl = document.getElementById(listElementId);
            if (!listEl) {
                console.error('Leaderboard element not found:', listElementId);
                return;
            }
            if (!cachedLeaderboard || cachedLeaderboard.length === 0) {
                listEl.innerHTML = '<li style="justify-content: center; color: #666;">No scores yet</li>';
                return;
            }
            const top10 = cachedLeaderboard.slice(0, 10);
            listEl.innerHTML = top10.map((entry, i) => {
                const timeStr = entry.duration ? `<span class="time" style="color:#888;font-size:11px;margin-left:8px;">${formatDuration(entry.duration)}</span>` : '';
                return `<li><span class="rank">${i + 1}.</span><span class="name">${entry.name}</span>${timeStr}<span class="score">${entry.score.toLocaleString()}</span></li>`;
            }).join('');
        }

        async function renderLeaderboard(listElementId) {
            await fetchAllLeaderboards();
            renderAllLeaderboards();
        }

        // === LIVE PLAYERS SYSTEM ===
        let myPlayerId = null;      // Database player ID (UUID)
        let livePlayerId = null;    // Redis live player ID (8-char)
        let myPlayerName = '';
        let mySessionId = null;
        let livePlayers = [];
        let playerPollInterval = null;
        let gameStartTime = null;
        let gameDuration = 0;
        const playerActionTimes = new Map(); // Track action times for flash animation
        const playerDeathTimes = new Map(); // Track death times for delayed removal
        let mySpectatorCount = 0; // Track how many people are watching me

        // Load saved player name from localStorage
        function loadSavedPlayerName() {
            const saved = localStorage.getItem('playerName');
            if (saved) {
                myPlayerName = saved;
                const nameInput = document.getElementById('playerNameInput');
                if (nameInput) nameInput.value = saved;
            }
        }

        // Save player name to localStorage
        function savePlayerName(name) {
            if (name) {
                localStorage.setItem('playerName', name);
                myPlayerName = name;
            }
        }

        async function joinAsPlayer() {
            const nameInput = document.getElementById('playerNameInput');
            // Use entered name, or fall back to saved name
            const enteredName = nameInput ? nameInput.value.trim() : '';
            const savedName = localStorage.getItem('playerName') || '';
            const nameToUse = enteredName || savedName;

            // If user entered a different name than saved, clear old session
            if (enteredName && enteredName !== savedName) {
                console.log('New name entered, clearing old session');
                sessionToken = null;
                localStorage.removeItem('sessionToken');
                myPlayerId = null;
                myPlayerName = '';
                // Also clear auth state
                isAuthenticated = false;
                currentPlayer = null;
                sessionStorage.removeItem('authToken');
                sessionStorage.removeItem('currentPlayer');
            }

            // Try to authenticate/register with new auth system
            try {
                // First try to login with existing token (only if name matches)
                if (sessionToken && (!enteredName || enteredName === savedName)) {
                    const loginResponse = await authFetch(`${API_BASE}/api/auth/login`, {
                        method: 'POST',
                        body: JSON.stringify({ token: sessionToken })
                    });
                    if (loginResponse.ok) {
                        const data = await loginResponse.json();
                        if (data.success) {
                            myPlayerId = data.playerId;
                            myPlayerName = data.username;
                            savePlayerName(data.username);
                            console.log('Logged in as:', myPlayerName);
                        }
                    }
                }

                // If no session yet, register new player
                if (!myPlayerId && nameToUse) {
                    const regResponse = await authFetch(`${API_BASE}/api/auth/register`, {
                        method: 'POST',
                        body: JSON.stringify({
                            username: nameToUse,
                            displayName: nameToUse
                        })
                    });
                    if (regResponse.ok) {
                        const data = await regResponse.json();
                        if (data.success) {
                            sessionToken = data.token;
                            localStorage.setItem('sessionToken', sessionToken);
                            myPlayerId = data.playerId;
                            myPlayerName = data.username;
                            savePlayerName(data.username);
                            console.log('Registered as:', myPlayerName, 'ID:', myPlayerId);
                        }
                    } else if (regResponse.status === 409) {
                        // Username taken - show modal
                        const data = await regResponse.json();
                        console.warn('Username taken:', data.error);
                        showUsernameTakenModal(nameToUse);
                        return false; // Don't continue - user must login or pick new name
                    }
                }
            } catch (e) {
                console.error('Auth error:', e);
            }

            // Only register with live players if we have a valid player
            if (!myPlayerId) {
                console.warn('No player ID, cannot join live system');
                return false;
            }

            // Also register with live players system (for spectating)
            try {
                const response = await fetch(`${API_BASE}/api/players/join`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: myPlayerName || nameToUse,
                        difficulty: selectedDifficulty.toUpperCase(),
                        color: selectedColor
                    })
                });
                if (response.ok) {
                    const data = await response.json();
                    livePlayerId = data.playerId; // Always use Redis player ID for live system
                    if (!myPlayerId) myPlayerId = data.playerId;
                    if (!myPlayerName) {
                        myPlayerName = data.name;
                        savePlayerName(data.name);
                    }
                    livePlayers = data.players || [];
                    console.log('Joined as:', myPlayerName, 'LiveID:', livePlayerId);
                    return true;
                }
            } catch (e) { console.error('Failed to join as player:', e); }
            return !!myPlayerId;
        }

        async function updatePlayerStatus(status) {
            if (!livePlayerId) return;
            // Update game duration
            if (gameStartTime) {
                gameDuration = Math.floor((Date.now() - gameStartTime) / 1000);
            }
            try {
                const response = await fetch(`${API_BASE}/api/players/update`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        playerId: livePlayerId,
                        score: score,
                        level: level,
                        status: status,
                        difficulty: selectedDifficulty.toUpperCase(),
                        gameDuration: gameDuration,
                        shieldActive: shieldActive,
                        currentWeapon: currentWeapon,
                        bossHealth: boss ? Math.floor((boss.health / boss.maxHealth) * 100) : null
                    })
                });
                if (response.ok) {
                    const data = await response.json();
                    livePlayers = data.players || [];
                    renderLivePlayers();
                } else if (response.status === 404) {
                    // Player session expired in Redis, rejoin silently
                    await joinAsPlayer();
                }
            } catch (e) { /* Silently ignore network errors */ }
        }

        async function reportAction(action, details = null) {
            if (!livePlayerId) return;
            try {
                await fetch(`${API_BASE}/api/players/action`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        playerId: livePlayerId,
                        sessionId: mySessionId,
                        action: action,
                        details: details
                    })
                });
            } catch (e) { /* Silently ignore */ }
        }

        async function startGameSession() {
            try {
                const response = await fetch(`${API_BASE}/api/players/start-session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: myPlayerName,
                        difficulty: selectedDifficulty.toUpperCase()
                    })
                });
                if (response.ok) {
                    const data = await response.json();
                    mySessionId = data.sessionId;
                }
            } catch (e) { console.error('Failed to start session:', e); }
        }

        async function endGameSession(deathReason) {
            if (!mySessionId) return;
            try {
                await fetch(`${API_BASE}/api/players/end-session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: mySessionId,
                        score: score,
                        level: level,
                        duration: gameDuration,
                        deathReason: deathReason,
                        bossesDefeated: bossDefeated.length
                    })
                });
            } catch (e) { console.error('Failed to end session:', e); }
            mySessionId = null;
        }

        async function leaveAsPlayer() {
            if (!livePlayerId) return;
            try {
                await fetch(`${API_BASE}/api/players/leave`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ playerId: livePlayerId })
                });
            } catch (e) { /* Silently ignore */ }
            livePlayerId = null;
        }

        // Game state broadcasting for spectators
        let lastBroadcastTime = 0;
        const BROADCAST_INTERVAL = 150; // ms between broadcasts

        async function broadcastGameState() {
            if (!livePlayerId || mySpectatorCount === 0) return;
            if (!gameRunning || lives <= 0) return;

            const now = Date.now();
            if (now - lastBroadcastTime < BROADCAST_INTERVAL) return;
            lastBroadcastTime = now;

            const state = {
                player: { x: player.x, y: player.y, width: player.width, height: player.height },
                enemies: enemies.map(e => ({ x: e.x, y: e.y, width: e.width, height: e.height, weapon: e.weapon, color: e.color })),
                bullets: bullets.map(b => ({ x: b.x, y: b.y, isEnemy: b.isEnemy, type: b.type, color: b.color })),
                boss: boss ? { x: boss.x, y: boss.y, width: boss.width, height: boss.height, health: boss.health, maxHealth: boss.maxHealth, phase: boss.phase } : null,
                powerups: powerups.map(p => ({ x: p.x, y: p.y, type: p.type })),
                bombs: bombs.map(b => ({ x: b.x, y: b.y })),
                walls: walls.map(w => ({ x: w.x, y: w.y, width: w.width, height: w.height, gapY: w.gapY, gapHeight: w.gapHeight })),
                weaponPickups: weaponPickups.map(w => ({ x: w.x, y: w.y, weapon: w.weapon })),
                spaceObjects: spaceObjects.map(s => ({ x: s.x, y: s.y, type: s.type, size: s.size })),
                score: score,
                level: level,
                lives: lives,
                shieldActive: shieldActive,
                currentWeapon: currentWeapon,
                bossActive: bossActive,
                gameDuration: gameDuration
            };

            try {
                await fetch(`${API_BASE}/api/players/gamestate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ playerId: livePlayerId, state })
                });
            } catch (e) { /* Silently ignore broadcast errors */ }
        }

        async function fetchActivePlayers() {
            try {
                const response = await fetch(`${API_BASE}/api/players/active`);
                if (response.ok) {
                    livePlayers = await response.json();

                    // Filter out dead players after death animation completes (3 seconds)
                    const DEAD_DISPLAY_DURATION = 3000;
                    livePlayers = livePlayers.filter(p => {
                        if (p.status !== 'dead') return true;
                        const deathTime = playerDeathTimes.get(p.id);
                        if (!deathTime) return true; // First time seeing this dead player
                        return Date.now() - deathTime < DEAD_DISPLAY_DURATION;
                    });

                    // Clean up old death times
                    for (const [id, time] of playerDeathTimes) {
                        if (Date.now() - time > DEAD_DISPLAY_DURATION * 2) {
                            playerDeathTimes.delete(id);
                        }
                    }

                    // Update my spectator count for broadcasting
                    const myPlayer = livePlayers.find(p => p.id === myPlayerId);
                    mySpectatorCount = myPlayer ? (parseInt(myPlayer.spectatorCount) || 0) : 0;

                    renderLivePlayers();
                    renderLobbyPlayers();
                }
            } catch (e) { console.error('Failed to fetch active players:', e); }
        }

        function formatDuration(seconds) {
            if (!seconds || seconds < 0) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function renderLivePlayers() {
            // Render to the new horizontal online players bar
            const bar = document.getElementById('onlinePlayersList');
            const countEl = document.getElementById('onlineCount');
            if (!bar) return;

            if (countEl) {
                countEl.textContent = `${livePlayers.length} player${livePlayers.length !== 1 ? 's' : ''}`;
            }

            if (livePlayers.length === 0) {
                bar.innerHTML = '<div style="color: #666; font-size: 10px;">No players online</div>';
                return;
            }

            bar.innerHTML = livePlayers.map(p => {
                const isYou = p.id === myPlayerId;
                const playerName = p.name || 'Unknown';
                const classes = ['online-player'];
                if (isYou) classes.push('you');
                if (p.defeatedBoss) classes.push('boss-defeated');

                const spectatorCount = parseInt(p.spectatorCount) || 0;
                const showWatch = !isYou && p.status === 'playing';

                return `<div class="${classes.join(' ')}">
                    <span class="status-dot ${p.status || 'lobby'}"></span>
                    <span class="p-name">${playerName}${isYou ? ' (you)' : ''}</span>
                    <span class="p-score">${(parseInt(p.score) || 0).toLocaleString()}</span>
                    ${p.lastActionEmoji ? `<span class="p-emoji">${p.lastActionEmoji}</span>` : ''}
                    ${showWatch ? `<button class="watch-btn" onclick="spectatePlayer('${p.id}')">üëÅÔ∏è${spectatorCount > 0 ? spectatorCount : ''}</button>` : ''}
                </div>`;
            }).join('');

            // Also update legacy sidebar for compatibility
            const sidebar = document.getElementById('sidebarPlayersList');
            if (!sidebar) return;
            if (livePlayers.length === 0) {
                sidebar.innerHTML = '<div style="color: #666; font-size: 10px; text-align: center;">No players</div>';
                return;
            }
            sidebar.innerHTML = livePlayers.map(p => {
                const isYou = p.id === myPlayerId;
                const playerName = p.name || 'Unknown';
                const classes = ['live-player'];
                if (isYou) classes.push('you');
                if (p.defeatedBoss) classes.push('boss-defeated');

                // Action-based flash: only flash when lastActionTime changes
                const prevActionTime = playerActionTimes.get(p.id);
                const hasNewAction = prevActionTime && p.lastActionTime && p.lastActionTime !== prevActionTime;
                playerActionTimes.set(p.id, p.lastActionTime);
                if (hasNewAction) classes.push('action-flash');

                // Dead player handling: flash red then track for removal
                if (p.status === 'dead') {
                    if (!playerDeathTimes.has(p.id)) {
                        playerDeathTimes.set(p.id, Date.now());
                    }
                    classes.push('dying');
                } else {
                    playerDeathTimes.delete(p.id);
                }

                const actionText = p.lastAction ? p.lastAction.replace(/_/g, ' ') : '';
                const duration = parseInt(p.gameDuration) || 0;
                const spectatorCount = parseInt(p.spectatorCount) || 0;

                return `<div class="${classes.join(' ')}">
                    <div class="player-row">
                        <div class="player-info">
                            <span class="player-status ${p.status || 'lobby'}"></span>
                            <span class="player-name">${playerName}${isYou ? ' (you)' : ''}</span>
                        </div>
                        <span class="player-score">${(parseInt(p.score) || 0).toLocaleString()}</span>
                    </div>
                    ${p.lastActionEmoji ? `<div class="player-action">
                        <span class="action-emoji">${p.lastActionEmoji}</span>
                        <span class="action-text">${actionText}</span>
                    </div>` : ''}
                    <div class="player-meta">
                        <span class="player-level">Lv.${p.level || 1}</span>
                        <span class="player-timer">‚è±Ô∏è ${formatDuration(duration)}</span>
                    </div>
                    ${!isYou && p.status === 'playing' ? `<button class="watch-btn" onclick="spectatePlayer('${p.id}')">üëÅÔ∏è Watch${spectatorCount > 0 ? ` (${spectatorCount})` : ''}</button>` : ''}
                </div>`;
            }).join('');
        }

        function renderLobbyPlayers() {
            const lobby = document.getElementById('lobbyPlayersList');
            const countEl = document.getElementById('playerCount');
            if (!lobby || !countEl) return;

            countEl.textContent = `${livePlayers.length} player${livePlayers.length !== 1 ? 's' : ''} online`;

            if (livePlayers.length === 0) {
                lobby.innerHTML = '<div style="color: #666; font-size: 10px; text-align: center; padding: 5px;">No players online</div>';
                return;
            }
            lobby.innerHTML = livePlayers.map(p => {
                const isYou = p.id === myPlayerId;
                const playerName = p.name || 'Unknown';
                const classes = ['live-player'];
                if (isYou) classes.push('you');
                if (p.defeatedBoss) classes.push('boss-defeated');

                // Action-based flash: only flash when lastActionTime changes
                const prevActionTime = playerActionTimes.get(p.id);
                const hasNewAction = prevActionTime && p.lastActionTime && p.lastActionTime !== prevActionTime;
                playerActionTimes.set(p.id, p.lastActionTime);
                if (hasNewAction) classes.push('action-flash');

                // Dead player handling
                if (p.status === 'dead') {
                    if (!playerDeathTimes.has(p.id)) {
                        playerDeathTimes.set(p.id, Date.now());
                    }
                    classes.push('dying');
                } else {
                    playerDeathTimes.delete(p.id);
                }

                const spectatorCount = parseInt(p.spectatorCount) || 0;

                return `<div class="${classes.join(' ')}">
                    <div class="player-row">
                        <div class="player-info">
                            <span class="player-status ${p.status || 'lobby'}"></span>
                            <span class="player-name">${playerName}${isYou ? ' (you)' : ''}</span>
                        </div>
                        <span class="player-score">${(parseInt(p.score) || 0).toLocaleString()}</span>
                    </div>
                    ${p.lastActionEmoji ? `<div class="player-action">
                        <span class="action-emoji">${p.lastActionEmoji}</span>
                        <span class="action-text">${p.lastAction ? p.lastAction.replace(/_/g, ' ') : ''}</span>
                    </div>` : ''}
                    ${!isYou && p.status === 'playing' ? `<button class="watch-btn" onclick="spectatePlayer('${p.id}')">üëÅÔ∏è Watch${spectatorCount > 0 ? ` (${spectatorCount})` : ''}</button>` : ''}
                </div>`;
            }).join('');
        }

        function startPlayerPolling() {
            if (playerPollInterval) clearInterval(playerPollInterval);
            playerPollInterval = setInterval(() => {
                if (gameRunning && !gamePaused) {
                    updatePlayerStatus(bossActive ? 'boss' : 'playing');
                }
            }, 1500);
        }

        function stopPlayerPolling() {
            if (playerPollInterval) {
                clearInterval(playerPollInterval);
                playerPollInterval = null;
            }
        }

        // === SPECTATOR MODE - Multiple Windows ===
        const spectatorWindows = new Map(); // playerId -> window data
        let spectatorWindowCount = 0;

        function spectatePlayer(playerId) {
            // Check if already watching this player
            if (spectatorWindows.has(playerId)) {
                return; // Already watching
            }

            const player = livePlayers.find(p => p.id === playerId);
            if (!player) return;

            // Create new spectator window
            const windowId = 'spec-' + (++spectatorWindowCount);
            const windowData = createSpectatorWindow(windowId, playerId, player);
            spectatorWindows.set(playerId, windowData);

            // Start polling for this window
            startSpectatorPolling(playerId, windowData);
        }

        function createSpectatorWindow(windowId, playerId, player) {
            const container = document.getElementById('spectatorContainer');
            const offset = spectatorWindows.size * 30; // Offset each new window

            const windowEl = document.createElement('div');
            windowEl.className = 'spectator-window';
            windowEl.id = windowId;
            windowEl.style.cssText = `bottom: ${20 + offset}px; right: ${20 + offset}px; width: 320px; height: 280px;`;

            windowEl.innerHTML = `
                <div class="spec-header">
                    <div>
                        <span class="spec-title">${player.name || 'Unknown'}</span>
                        <span class="spec-info">${player.difficulty || 'EASY'} | Lv.${player.level || 1}</span>
                    </div>
                    <button class="spec-close" onclick="closeSpectatorWindow('${playerId}')">‚úï</button>
                </div>
                <div class="spec-canvas-container">
                    <canvas class="spec-canvas" width="320" height="160"></canvas>
                </div>
                <div class="spec-stats">
                    <div class="spec-stat">Score: <span class="spec-score">0</span></div>
                    <div class="spec-stat">Lv: <span class="spec-level">1</span></div>
                    <div class="spec-stat">‚ù§Ô∏è <span class="spec-lives">3</span></div>
                    <div class="spec-stat">üî´ <span class="spec-weapon">pistol</span></div>
                </div>
            `;

            container.appendChild(windowEl);

            // Make window draggable
            makeDraggable(windowEl);

            // Get canvas context
            const canvas = windowEl.querySelector('.spec-canvas');
            const ctx = canvas.getContext('2d');

            return {
                windowId,
                playerId,
                playerName: player.name || 'Unknown',
                element: windowEl,
                canvas,
                ctx,
                pollInterval: null
            };
        }

        function makeDraggable(el) {
            const header = el.querySelector('.spec-header');
            let isDragging = false;
            let startX, startY, startRight, startBottom;

            header.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('spec-close')) return;
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startRight = parseInt(el.style.right) || 20;
                startBottom = parseInt(el.style.bottom) || 20;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = startX - e.clientX;
                const dy = startY - e.clientY;
                el.style.right = Math.max(0, startRight + dx) + 'px';
                el.style.bottom = Math.max(0, startBottom + dy) + 'px';
            });

            document.addEventListener('mouseup', () => { isDragging = false; });
        }

        function startSpectatorPolling(playerId, windowData) {
            const spectatorId = myPlayerId || 'spec_' + Math.random().toString(36).substr(2, 8);

            windowData.pollInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE}/api/players/spectate/${playerId}?spectatorId=${spectatorId}`);
                    if (!response.ok) {
                        if (response.status === 404) {
                            // Player left or restarted - look for them by name
                            const playerName = windowData.playerName;
                            if (playerName) {
                                const newPlayer = livePlayers.find(p => p.name === playerName && p.id !== playerId && p.status === 'playing');
                                if (newPlayer) {
                                    // Found player with new ID - switch to watching them
                                    closeSpectatorWindow(playerId);
                                    spectatePlayer(newPlayer.id);
                                    return;
                                }
                            }
                            renderSpectatorWindowMessage(windowData, 'Waiting for player...');
                        }
                        return;
                    }
                    const data = await response.json();
                    // Track player status for auto-reconnect
                    if (data.player) {
                        windowData.lastStatus = data.player.status;
                    }
                    if (data.state) {
                        renderSpectatorWindowGame(windowData, data.state);
                        updateSpectatorWindowStats(windowData, data.state);
                    }
                    if (data.player) {
                        const info = windowData.element.querySelector('.spec-info');
                        if (info) info.textContent = `${data.player.difficulty || 'EASY'} | Lv.${data.player.level || 1}`;
                    }
                } catch (e) { /* ignore */ }
            }, 150);

            // Initial spectate registration
            fetch(`${API_BASE}/api/players/spectate/${playerId}?spectatorId=${spectatorId}`).catch(() => {});
        }

        function closeSpectatorWindow(playerId) {
            const windowData = spectatorWindows.get(playerId);
            if (!windowData) return;

            // Stop polling
            if (windowData.pollInterval) clearInterval(windowData.pollInterval);

            // Tell server we stopped watching
            const spectatorId = myPlayerId || 'spec_' + Math.random().toString(36).substr(2, 8);
            fetch(`${API_BASE}/api/players/spectate/${playerId}/leave`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ spectatorId })
            }).catch(() => {});

            // Remove element
            windowData.element.remove();
            spectatorWindows.delete(playerId);
        }

        function renderSpectatorWindowGame(windowData, state) {
            const { canvas, ctx } = windowData;
            const cw = canvas.width;
            const ch = canvas.height;
            const scaleX = cw / logicalWidth;
            const scaleY = ch / logicalHeight;

            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, cw, ch);

            // Stars
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 20; i++) {
                const x = (i * 47 + Date.now() * 0.01) % cw;
                const y = (i * 31) % ch;
                ctx.fillRect(x, y, 1, 1);
            }

            // Walls
            if (state.walls) {
                state.walls.forEach(w => {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(w.x * scaleX, w.y * scaleY, w.width * scaleX, w.gapY * scaleY);
                    ctx.fillRect(w.x * scaleX, (w.gapY + w.gapHeight) * scaleY, w.width * scaleX, (logicalHeight - w.gapY - w.gapHeight) * scaleY);
                });
            }

            // Bombs
            if (state.bombs) {
                ctx.fillStyle = '#ff4444';
                state.bombs.forEach(b => {
                    ctx.beginPath();
                    ctx.arc(b.x * scaleX, b.y * scaleY, 5, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // Powerups (shield, health, etc.)
            if (state.powerups) {
                state.powerups.forEach(p => {
                    ctx.fillStyle = p.type === 'shield' ? '#00ffff' : '#4ade80';
                    ctx.beginPath();
                    ctx.arc(p.x * scaleX, p.y * scaleY, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
            }

            // Weapon pickups
            if (state.weaponPickups) {
                state.weaponPickups.forEach(w => {
                    ctx.fillStyle = w.weapon === 'laser' ? '#ff0' : w.weapon === 'spread' ? '#f80' : '#0ff';
                    ctx.fillRect(w.x * scaleX - 5, w.y * scaleY - 5, 10, 10);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(w.x * scaleX - 5, w.y * scaleY - 5, 10, 10);
                });
            }

            // Space objects (asteroids, etc.)
            if (state.spaceObjects) {
                state.spaceObjects.forEach(s => {
                    ctx.fillStyle = '#666';
                    const size = (s.size || 20) * scaleX;
                    ctx.beginPath();
                    ctx.arc(s.x * scaleX, s.y * scaleY, size / 2, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // Bullets
            if (state.bullets) {
                state.bullets.forEach(b => {
                    ctx.fillStyle = b.isEnemy ? '#ff6666' : '#6af';
                    ctx.fillRect(b.x * scaleX - 1, b.y * scaleY - 3, 3, 6);
                });
            }

            // Enemies
            if (state.enemies) {
                state.enemies.forEach(e => {
                    ctx.fillStyle = e.color || '#f55';
                    const w = (e.width || 40) * scaleX;
                    const h = (e.height || 40) * scaleY;
                    ctx.fillRect(e.x * scaleX - w/2, e.y * scaleY - h/2, w, h);
                });
            }

            // Boss
            if (state.boss && state.bossActive) {
                ctx.fillStyle = '#ff00ff';
                const bw = (state.boss.width || 100) * scaleX;
                const bh = (state.boss.height || 80) * scaleY;
                ctx.fillRect(state.boss.x * scaleX - bw/2, state.boss.y * scaleY - bh/2, bw, bh);
                if (state.boss.health && state.boss.maxHealth) {
                    const hpRatio = state.boss.health / state.boss.maxHealth;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(5, 5, cw - 10, 4);
                    ctx.fillStyle = hpRatio > 0.3 ? '#ff00ff' : '#ff0000';
                    ctx.fillRect(5, 5, (cw - 10) * hpRatio, 4);
                }
            }

            // Player
            if (state.player) {
                const px = state.player.x * scaleX;
                const py = state.player.y * scaleY;
                const pw = (state.player.width || 50) * scaleX;
                const ph = (state.player.height || 50) * scaleY;

                if (state.shieldActive) {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(px, py, pw * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.fillStyle = '#6af';
                ctx.beginPath();
                ctx.moveTo(px, py - ph/2);
                ctx.lineTo(px - pw/2, py + ph/2);
                ctx.lineTo(px + pw/2, py + ph/2);
                ctx.closePath();
                ctx.fill();
            }
        }

        function renderSpectatorWindowMessage(windowData, msg) {
            const { canvas, ctx } = windowData;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(msg, canvas.width / 2, canvas.height / 2);
        }

        function updateSpectatorWindowStats(windowData, state) {
            const el = windowData.element;
            el.querySelector('.spec-score').textContent = (state.score || 0).toLocaleString();
            el.querySelector('.spec-level').textContent = state.level || 1;
            el.querySelector('.spec-lives').textContent = state.lives || 0;
            const weaponEl = el.querySelector('.spec-weapon');
            if (weaponEl) weaponEl.textContent = state.currentWeapon || 'pistol';
        }

        // Close all spectator windows
        function closeAllSpectatorWindows() {
            for (const playerId of spectatorWindows.keys()) {
                closeSpectatorWindow(playerId);
            }
        }


        // Handle email login link
        async function handleLoginToken() {
            const params = new URLSearchParams(window.location.search);
            const loginToken = params.get('login_token');

            if (!loginToken) return false;

            // Clear token from URL (without reload)
            window.history.replaceState({}, document.title, window.location.pathname);

            try {
                const response = await authFetch(`${API_BASE}/api/auth/verify-login-link`, {
                    method: 'POST',
                    body: JSON.stringify({ token: loginToken })
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        sessionToken = data.token;
                        localStorage.setItem('sessionToken', sessionToken);
                        myPlayerId = data.playerId;
                        myPlayerName = data.username;
                        savePlayerName(data.username);

                        // Update name input
                        const nameInput = document.getElementById('playerNameInput');
                        if (nameInput) nameInput.value = data.username;

                        alert(`Welcome back, ${data.username}! You are now logged in on this device.`);
                        return true;
                    }
                } else {
                    const err = await response.json();
                    alert('Login link expired or invalid. Please request a new one.');
                }
            } catch (e) {
                console.error('Login link verification failed:', e);
            }
            return false;
        }

        // Initialize leaderboard on page load
        document.addEventListener('DOMContentLoaded', async () => {
            // Load auth state first
            loadAuthState();

            // Check for login token in URL first
            await handleLoginToken();

            renderLeaderboard('startLeaderboardList');
            // Load saved player name from localStorage
            loadSavedPlayerName();
            // Start polling for lobby players
            fetchActivePlayers();
            setInterval(fetchActivePlayers, 3000);
        });

        // Leave on page unload
        window.addEventListener('beforeunload', () => {
            if (livePlayerId) {
                navigator.sendBeacon(`${API_BASE}/api/players/leave`, JSON.stringify({ playerId: livePlayerId }));
            }
        });

        // === DIFFICULTY SETTINGS (2x speed) ===
        const DIFFICULTIES = {
            easy: { name: 'EASY', speedMult: 1.6, spawnMult: 1.0, enemyFireMult: 1.4, lives: 5, color: '#4ade80' },
            medium: { name: 'MEDIUM', speedMult: 2.0, spawnMult: 0.7, enemyFireMult: 2.0, lives: 5, color: '#facc15' },
            hard: { name: 'HARD', speedMult: 2.6, spawnMult: 0.5, enemyFireMult: 3.0, lives: 5, color: '#f97316' },
            expert: { name: 'EXPERT', speedMult: 3.2, spawnMult: 0.35, enemyFireMult: 4.0, lives: 5, color: '#ef4444' }
        };
        let selectedDifficulty = 'easy';

        // === GAME STATE ===
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let lives = 3;
        let level = 1;
        // Boss spawns after 25 kills per level
        const KILLS_FOR_BOSS = 25;
        let killsThisLevel = 0; // Track kills for current level
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 850;
        let isInvincible = false; // Debug mode for unlimited lives
        let totalEnemiesKilled = 0; // Track for ending stats
        let playerHitFlash = 0; // Flash timer when player takes damage (ms)

        // === RESPAWN SYSTEM ===
        const MAX_CONTINUES_PER_LEVEL = 3;
        let continuesUsedThisLevel = 0;
        let respawnsUsedThisLevel = 0; // Legacy - keep for compatibility
        let playerHasKey = false;
        let currentContinueKey = null;
        let savedLevelScore = 0; // Score at start of current level

        // Load stored continue key from localStorage (persists across page reloads within session)
        function loadStoredContinueKey() {
            try {
                const stored = sessionStorage.getItem('continueKey');
                if (stored) {
                    currentContinueKey = stored;
                    playerHasKey = true;
                    return true;
                }
            } catch (e) {}
            return false;
        }

        function storeCurrentContinueKey(key) {
            try {
                sessionStorage.setItem('continueKey', key);
                currentContinueKey = key;
                playerHasKey = true;
            } catch (e) {}
        }

        function clearStoredContinueKey() {
            try {
                sessionStorage.removeItem('continueKey');
            } catch (e) {}
            currentContinueKey = null;
            playerHasKey = false;
        }

        // === AUTHENTICATION & TOKEN SYSTEM ===
        let isAuthenticated = false;
        let currentPlayer = null;  // { id, username, email, tokens, savedLevel, savedScore, savedDifficulty, continuesThisLevel }
        const FREE_CONTINUES = 3;  // Free continues for unauthenticated players
        let freeUsedContinues = 0; // Track free continues used (unauthenticated)

        // Load auth state from sessionStorage
        function loadAuthState() {
            try {
                const token = sessionStorage.getItem('authToken');
                const player = sessionStorage.getItem('currentPlayer');
                if (token && player) {
                    sessionToken = token;
                    currentPlayer = JSON.parse(player);
                    isAuthenticated = true;
                    updateAuthUI();
                    return true;
                }
            } catch (e) {
                console.error('Error loading auth state:', e);
            }
            return false;
        }

        // Save auth state to sessionStorage
        function saveAuthState(token, player) {
            try {
                sessionStorage.setItem('authToken', token);
                sessionStorage.setItem('currentPlayer', JSON.stringify(player));
                sessionToken = token;
                currentPlayer = player;
                isAuthenticated = true;
                updateAuthUI();
            } catch (e) {
                console.error('Error saving auth state:', e);
            }
        }

        // Clear auth state - clears ALL session data
        function clearAuthState() {
            try {
                // Clear sessionStorage
                sessionStorage.removeItem('authToken');
                sessionStorage.removeItem('currentPlayer');
                // Clear localStorage
                localStorage.removeItem('sessionToken');
                localStorage.removeItem('playerName');
            } catch (e) {}
            sessionToken = null;
            currentPlayer = null;
            isAuthenticated = false;
            myPlayerId = null;
            myPlayerName = '';
            updateAuthUI();
        }

        // Update UI based on auth state
        function updateAuthUI() {
            const loginBtn = document.getElementById('loginBtn');
            const profileBtn = document.getElementById('profileBtn');
            const tokenDisplay = document.getElementById('tokenDisplay');
            const continueGameBtn = document.getElementById('continueGameBtn');

            if (isAuthenticated && currentPlayer) {
                if (loginBtn) loginBtn.style.display = 'none';
                if (profileBtn) {
                    profileBtn.style.display = 'inline-block';
                    profileBtn.textContent = currentPlayer.username;
                }
                if (tokenDisplay) {
                    tokenDisplay.style.display = 'flex';
                    document.getElementById('tokenCount').textContent = currentPlayer.tokens || 0;
                }
                if (continueGameBtn && currentPlayer.savedLevel > 1) {
                    continueGameBtn.style.display = 'block';
                }
            } else {
                if (loginBtn) loginBtn.style.display = 'inline-block';
                if (profileBtn) profileBtn.style.display = 'none';
                if (tokenDisplay) tokenDisplay.style.display = 'none';
                if (continueGameBtn) continueGameBtn.style.display = 'none';
            }
        }

        // Show login modal
        function showLoginModal() {
            document.getElementById('loginModal').classList.add('show');
            document.getElementById('loginError').style.display = 'none';
        }

        function hideLoginModal() {
            document.getElementById('loginModal').classList.remove('show');
        }

        // Username taken modal
        function showUsernameTakenModal(username) {
            document.getElementById('takenUsername').textContent = username;
            document.getElementById('loginEmailOrUsername').value = username; // Pre-fill login
            document.getElementById('usernameTakenModal').classList.add('show');
        }

        function hideUsernameTakenModal() {
            document.getElementById('usernameTakenModal').classList.remove('show');
        }

        // Show registration modal
        function showRegisterModal(fromDeath = false) {
            document.getElementById('registerModal').classList.add('show');
            document.getElementById('registerError').style.display = 'none';
            document.getElementById('registerFromDeath').value = fromDeath ? '1' : '';
            if (myPlayerName) {
                document.getElementById('registerUsername').value = myPlayerName;
            }
        }

        function hideRegisterModal() {
            document.getElementById('registerModal').classList.remove('show');
        }

        // Show verification modal
        function showVerifyModal(email) {
            document.getElementById('verifyModal').classList.add('show');
            document.getElementById('verifyEmail').value = email;
            document.getElementById('verifyError').style.display = 'none';
        }

        function hideVerifyModal() {
            document.getElementById('verifyModal').classList.remove('show');
        }

        // Show profile modal
        function showProfileModal() {
            document.getElementById('profileModal').classList.add('show');
            loadProfileData();
        }

        function hideProfileModal() {
            document.getElementById('profileModal').classList.remove('show');
        }

        // Login with password
        async function loginWithPassword() {
            const emailOrUsername = document.getElementById('loginEmailOrUsername').value.trim();
            const password = document.getElementById('loginPassword').value;

            if (!emailOrUsername || !password) {
                showLoginError('Please enter email/username and password');
                return;
            }

            document.getElementById('loginBtn2').disabled = true;
            document.getElementById('loginBtn2').textContent = 'Logging in...';

            try {
                const response = await authFetch(`${API_BASE}/api/auth/login-password`, {
                    method: 'POST',
                    body: JSON.stringify({ emailOrUsername, password })
                });
                const data = await response.json();

                if (data.success) {
                    saveAuthState(data.token, {
                        id: data.playerId,
                        username: data.username,
                        email: data.email,
                        tokens: data.tokens,
                        savedLevel: data.savedLevel || 1,
                        savedScore: data.savedScore || 0,
                        savedDifficulty: data.savedDifficulty || 'EASY',
                        continuesThisLevel: data.continuesThisLevel || 0
                    });
                    hideLoginModal();
                    showNotification(`Welcome back, ${data.username}!`);
                } else {
                    if (data.needsVerification) {
                        hideLoginModal();
                        showVerifyModal(emailOrUsername);
                    } else {
                        showLoginError(data.error || 'Login failed');
                    }
                }
            } catch (e) {
                showLoginError('Network error. Please try again.');
                console.error('Login error:', e);
            }

            document.getElementById('loginBtn2').disabled = false;
            document.getElementById('loginBtn2').textContent = 'Login';
        }

        function showLoginError(msg) {
            document.getElementById('loginError').textContent = msg;
            document.getElementById('loginError').style.display = 'block';
        }

        // Register with password
        async function registerWithPassword() {
            const username = document.getElementById('registerUsername').value.trim();
            const email = document.getElementById('registerEmail').value.trim();
            const password = document.getElementById('registerPassword').value;
            const confirmPassword = document.getElementById('registerConfirmPassword').value;
            const fromDeath = document.getElementById('registerFromDeath').value === '1';

            if (!username || !email || !password) {
                showRegisterError('Please fill in all fields');
                return;
            }
            if (password !== confirmPassword) {
                showRegisterError('Passwords do not match');
                return;
            }
            if (password.length < 6) {
                showRegisterError('Password must be at least 6 characters');
                return;
            }

            document.getElementById('registerBtn').disabled = true;
            document.getElementById('registerBtn').textContent = 'Creating account...';

            try {
                const response = await authFetch(`${API_BASE}/api/auth/register-password`, {
                    method: 'POST',
                    body: JSON.stringify({ username, email, password })
                });
                const data = await response.json();

                if (data.success) {
                    hideRegisterModal();
                    showVerifyModal(email);
                    // Store that we came from death for post-verification
                    sessionStorage.setItem('registerFromDeath', fromDeath ? '1' : '');
                } else {
                    showRegisterError(data.error || 'Registration failed');
                }
            } catch (e) {
                showRegisterError('Network error. Please try again.');
                console.error('Register error:', e);
            }

            document.getElementById('registerBtn').disabled = false;
            document.getElementById('registerBtn').textContent = 'Create Account';
        }

        function showRegisterError(msg) {
            document.getElementById('registerError').textContent = msg;
            document.getElementById('registerError').style.display = 'block';
        }

        // Verify email with code
        async function verifyEmailCode() {
            const email = document.getElementById('verifyEmail').value.trim();
            const code = document.getElementById('verifyCode').value.trim();

            if (!code || code.length !== 6) {
                showVerifyError('Please enter the 6-digit code');
                return;
            }

            document.getElementById('verifyBtn').disabled = true;
            document.getElementById('verifyBtn').textContent = 'Verifying...';

            try {
                const response = await authFetch(`${API_BASE}/api/auth/verify-code`, {
                    method: 'POST',
                    body: JSON.stringify({ email, code })
                });
                const data = await response.json();

                if (data.success) {
                    saveAuthState(data.token, {
                        id: data.playerId,
                        username: data.username,
                        email: data.email,
                        tokens: data.tokens,
                        savedLevel: 1,
                        savedScore: 0,
                        savedDifficulty: 'EASY',
                        continuesThisLevel: 0
                    });
                    hideVerifyModal();
                    showNotification(`Welcome, ${data.username}! You have ${data.tokens} tokens.`);

                    // If registered from death, continue game
                    const fromDeath = sessionStorage.getItem('registerFromDeath') === '1';
                    sessionStorage.removeItem('registerFromDeath');
                    if (fromDeath) {
                        freeUsedContinues = 0; // Reset free continues
                        respawnPlayer();
                    }
                } else {
                    showVerifyError(data.error || 'Verification failed');
                }
            } catch (e) {
                showVerifyError('Network error. Please try again.');
                console.error('Verify error:', e);
            }

            document.getElementById('verifyBtn').disabled = false;
            document.getElementById('verifyBtn').textContent = 'Verify';
        }

        function showVerifyError(msg) {
            document.getElementById('verifyError').textContent = msg;
            document.getElementById('verifyError').style.display = 'block';
        }

        // Resend verification code
        async function resendVerificationCode() {
            const email = document.getElementById('verifyEmail').value.trim();
            if (!email) return;

            try {
                const response = await authFetch(`${API_BASE}/api/auth/resend-code`, {
                    method: 'POST',
                    body: JSON.stringify({ email })
                });
                const data = await response.json();

                if (data.success) {
                    document.getElementById('verifyError').textContent = 'New code sent!';
                    document.getElementById('verifyError').style.display = 'block';
                    document.getElementById('verifyError').style.color = '#4ade80';
                } else {
                    showVerifyError(data.error || 'Failed to resend code');
                }
            } catch (e) {
                showVerifyError('Network error');
            }
        }

        // Logout
        async function logout() {
            try {
                await authFetch(`${API_BASE}/api/auth/logout`, { method: 'POST' });
            } catch (e) {}
            clearAuthState();
            hideProfileModal();
            showNotification('Logged out');
        }

        // Use token for continue
        async function useTokenForContinue() {
            if (!isAuthenticated || !currentPlayer) return false;
            if (currentPlayer.tokens <= 0) return false;

            try {
                const response = await authFetch(`${API_BASE}/api/player/use-token`, {
                    method: 'POST'
                });
                const data = await response.json();

                if (data.success) {
                    currentPlayer.tokens = data.tokens;
                    currentPlayer.continuesThisLevel = data.continuesThisLevel;
                    sessionStorage.setItem('currentPlayer', JSON.stringify(currentPlayer));
                    updateAuthUI();
                    return true;
                }
            } catch (e) {
                console.error('Error using token:', e);
            }
            return false;
        }

        // Save progress on level advance
        async function saveGameProgress() {
            if (!isAuthenticated) return;

            try {
                const response = await authFetch(`${API_BASE}/api/player/save-game-progress`, {
                    method: 'POST',
                    body: JSON.stringify({
                        level: level,
                        score: score,
                        difficulty: selectedDifficulty.toUpperCase()
                    })
                });
                const data = await response.json();

                if (data.success) {
                    currentPlayer.savedLevel = data.savedLevel;
                    currentPlayer.savedScore = data.savedScore;
                    currentPlayer.savedDifficulty = data.savedDifficulty;
                    currentPlayer.tokens = data.tokens;
                    currentPlayer.continuesThisLevel = 0;
                    sessionStorage.setItem('currentPlayer', JSON.stringify(currentPlayer));
                }
            } catch (e) {
                console.error('Error saving progress:', e);
            }
        }

        // Reset level continues (when restarting at level beginning)
        async function resetLevelContinues() {
            if (!isAuthenticated) return;

            try {
                const response = await authFetch(`${API_BASE}/api/player/reset-level-continues`, {
                    method: 'POST'
                });
                const data = await response.json();

                if (data.success) {
                    currentPlayer.continuesThisLevel = 0;
                    sessionStorage.setItem('currentPlayer', JSON.stringify(currentPlayer));
                }
            } catch (e) {
                console.error('Error resetting continues:', e);
            }
        }

        // Load profile data
        async function loadProfileData() {
            if (!isAuthenticated) return;

            try {
                const response = await authFetch(`${API_BASE}/api/player/profile`);
                const data = await response.json();

                if (data.player) {
                    // Update local state
                    currentPlayer.tokens = data.player.tokens;
                    sessionStorage.setItem('currentPlayer', JSON.stringify(currentPlayer));

                    // Update profile display
                    document.getElementById('profileUsername').textContent = data.player.username;
                    document.getElementById('profileEmail').textContent = data.player.email;
                    document.getElementById('profileTokens').textContent = data.player.tokens;
                    document.getElementById('tokenCount').textContent = data.player.tokens;

                    // Stats
                    document.getElementById('statGames').textContent = data.stats.total_games || 0;
                    document.getElementById('statBestScore').textContent = (data.stats.best_score || 0).toLocaleString();
                    document.getElementById('statBestLevel').textContent = data.stats.best_level || 0;
                    document.getElementById('statVictories').textContent = data.stats.victories || 0;
                    document.getElementById('statPlaytime').textContent = formatPlaytime(data.stats.total_playtime || 0);

                    // Game history
                    const historyEl = document.getElementById('profileHistory');
                    historyEl.innerHTML = '';
                    if (data.games && data.games.length > 0) {
                        data.games.slice(0, 10).forEach(game => {
                            const div = document.createElement('div');
                            div.className = 'history-item';
                            div.innerHTML = `
                                <span>Level ${game.level}</span>
                                <span>${(game.score || 0).toLocaleString()}</span>
                                <span>${game.difficulty || 'EASY'}</span>
                                <span>${game.is_victory ? 'üèÜ' : ''}</span>
                            `;
                            historyEl.appendChild(div);
                        });
                    } else {
                        historyEl.innerHTML = '<p style="color: #888;">No games yet</p>';
                    }
                }
            } catch (e) {
                console.error('Error loading profile:', e);
            }
        }

        function formatPlaytime(seconds) {
            if (seconds < 60) return `${seconds}s`;
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
            return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}m`;
        }

        // === LEVEL SPEED MULTIPLIERS ===
        const levelSpeeds = { 1: 1.0, 2: 1.2, 3: 1.4, 4: 1.6, 5: 1.8, 6: 2.2 };

        // === BACKGROUND OBJECTS ===
        let stars = [];
        let nebulae = [];
        let spaceObjects = []; // stations, planets, asteroids

        // === SHIELD ===
        let shieldActive = false;
        let shieldHits = 0;
        const shieldDuration = 5000;
        const shieldMaxHits = 3;
        let shieldStartTime = 0;

        // === ELECTRIC FENCES ===
        let electricFences = [];
        let fenceSpawnAccumulator = 0;

        // === PLAYER BOMBS ===
        let playerBombs = 3; // Start with 3 bombs
        let lastPlayerBombTime = 0;
        const PLAYER_BOMB_COOLDOWN = 2000; // 2 second cooldown

        // === NEW BOSS WEAPONS ===
        let horizonBeams = []; // Full-width beams with gaps
        let magneticMines = []; // Mines that are attracted to player
        let mirrorDrones = []; // Drones that mirror player movement

        // === BOSS SYSTEM ===
        let boss = null;
        let bossActive = false;
        let bossDefeated = [];
        let bossTauntTimer = 0;
        let bossMusic = null;

        const BOSSES = {
            1: {
                name: 'DARK PHANTOM',
                type: 'aircraft',
                health: 20, maxHealth: 20,
                width: 120, height: 80,
                speed: 150, fireRate: 0.8,
                color: '#8B0000',
                taunts: [
                    "You dare challenge me?",
                    "Pathetic human!",
                    "I will destroy you!",
                    "Is that all you've got?",
                    "You cannot escape!"
                ],
                attackPattern: 'spread',
                laughFreq: 180,
                laughType: 'dark'
            },
            2: {
                name: 'CYBER KRAKEN',
                type: 'monster',
                health: 30, maxHealth: 30,
                width: 150, height: 100,
                speed: 120, fireRate: 0.6,
                color: '#4B0082',
                taunts: [
                    "The void consumes all!",
                    "Your weapons are useless!",
                    "Feel my tentacles of doom!",
                    "No one survives the Kraken!",
                    "Surrender to darkness!"
                ],
                attackPattern: 'spiral',
                laughFreq: 120,
                laughType: 'gurgle'
            },
            3: {
                name: 'INFERNO TITAN',
                type: 'monster',
                health: 45, maxHealth: 45,
                width: 180, height: 120,
                speed: 100, fireRate: 0.5,
                color: '#FF4500',
                taunts: [
                    "BURN IN FLAMES!",
                    "I am eternal fire!",
                    "Your soul will fuel my power!",
                    "Witness true destruction!",
                    "Nothing survives my inferno!"
                ],
                attackPattern: 'wave',
                laughFreq: 100,
                laughType: 'roar'
            },
            4: {
                name: 'QUANTUM DESTROYER',
                type: 'aircraft',
                health: 68, maxHealth: 68,
                width: 200, height: 100,
                speed: 180, fireRate: 0.4,
                color: '#00CED1',
                taunts: [
                    "I exist in all dimensions!",
                    "Time is my weapon!",
                    "You cannot hit what phases!",
                    "Reality bends to my will!",
                    "Prepare for annihilation!"
                ],
                attackPattern: 'random',
                laughFreq: 200,
                laughType: 'glitch'
            },
            5: {
                name: 'OMEGA OVERLORD',
                type: 'monster',
                health: 102, maxHealth: 102,
                width: 220, height: 140,
                speed: 130, fireRate: 0.3,
                color: '#FFD700',
                taunts: [
                    "I AM THE FINAL BOSS!",
                    "NO ONE HAS EVER DEFEATED ME!",
                    "YOUR JOURNEY ENDS HERE!",
                    "BOW BEFORE THE OVERLORD!",
                    "THIS IS YOUR DOOM!"
                ],
                attackPattern: 'all',
                laughFreq: 80,
                laughType: 'boom'
            },
            6: {
                name: 'LEGION SUPREME',
                type: 'ultimate',
                health: 153, maxHealth: 153,
                width: 280, height: 180,
                speed: 250, fireRate: 0.2,
                color: '#FF0080',
                taunts: [
                    "I AM LEGION! THE ULTIMATE DESTROYER!",
                    "ALL WHO CAME BEFORE ME WERE NOTHING!",
                    "YOU HAVE SEALED YOUR FATE!",
                    "WITNESS THE POWER OF A GOD!",
                    "THIS UNIVERSE BELONGS TO ME!",
                    "YOUR VICTORY ENDS NOW!",
                    "I HAVE WAITED EONS FOR THIS!",
                    "TREMBLE BEFORE LEGION SUPREME!"
                ],
                attackPattern: 'ultimate',
                isSuper: true,
                laughFreq: 60,
                laughType: 'demonic'
            }
        };

        // === WEAPONS ===
        const WEAPONS = {
            pistol: { name: 'PISTOL', fireRate: 150, color: '#00ffff' },
            machinegun: { name: 'MACHINE GUN', fireRate: 50, color: '#ffff00' },
            bazooka: { name: 'BAZOOKA', fireRate: 500, color: '#ff6600' },
            laser: { name: 'LASER BEAM', fireRate: 30, color: '#ff00ff' },
            flak: { name: 'FLAK CANNON', fireRate: 600, color: '#ff8800' },
            disc: { name: 'DISC LAUNCHER', fireRate: 400, color: '#00ff88' },
            swarm: { name: 'SWARM MISSILES', fireRate: 800, color: '#ff00ff' }
        };
        let currentWeapon = 'pistol';
        let unlockedWeapons = ['pistol'];
        let laserActive = false;

        // Ammo system - pistol has infinite, others have limited ammo
        const AMMO_PER_PICKUP = 30;
        let weaponAmmo = {
            pistol: Infinity,
            machinegun: 0,
            bazooka: 0,
            laser: 0,
            flak: 0,
            disc: 0,
            swarm: 0
        };
        let laserAmmoTimer = 0; // For tracking laser ammo consumption (1 per second)

        const jetColors = {
            blue: { body: '#3a7bd5', wings: '#2a5aa5', cockpit: '#87ceeb' },
            pink: { body: '#d53a7b', wings: '#a52a5a', cockpit: '#f0b8d0' },
            green: { body: '#22c55e', wings: '#15803d', cockpit: '#86efac' },  // P2 coop color
            orange: { body: '#f97316', wings: '#c2410c', cockpit: '#fed7aa' }  // Alt P2 color
        };
        let selectedColor = 'blue';

        function selectColor(color) {
            selectedColor = color;
            document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector('.color-btn.' + color).classList.add('selected');
        }

        function selectDifficulty(diff) {
            selectedDifficulty = diff;
            document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector('.diff-btn.' + diff).classList.add('selected');
        }

        // Modal functions
        function openSetupModal() {
            document.getElementById('setupModal').classList.add('show');
        }

        function closeSetupModal() {
            document.getElementById('setupModal').classList.remove('show');
            openModeSelectModal();
        }

        // === MULTIPLAYER STATE ===
        let selectedGameMode = 'solo';  // 'solo', 'coop', 'versus'
        let currentRoomCode = null;
        let isRoomHost = false;
        let isPlayerReady = false;
        let roomPollInterval = null;
        let matchmakingPollInterval = null;
        let mpSocket = null;  // WebSocket connection

        // Mode Selection Modal
        function openModeSelectModal() {
            document.getElementById('modeSelectModal').classList.add('show');
        }

        function closeModeSelectModal() {
            document.getElementById('modeSelectModal').classList.remove('show');
        }

        function selectGameMode(mode) {
            selectedGameMode = mode;
            closeModeSelectModal();

            if (mode === 'solo') {
                // Go directly to setup modal for solo play
                openSetupModal();
            } else {
                // Open multiplayer lobby for coop or versus
                openLobbyModal(mode);
            }
        }

        // Lobby Modal
        function openLobbyModal(mode) {
            const title = mode === 'coop' ? 'TAG TEAM LOBBY' : '1v1 LOBBY';
            document.getElementById('lobbyTitle').textContent = title;
            document.getElementById('lobbyTitle').style.color = mode === 'coop' ? '#4ade80' : '#ef4444';
            document.getElementById('roomOptions').style.display = 'block';
            document.getElementById('waitingRoom').style.display = 'none';
            document.getElementById('matchmakingQueue').style.display = 'none';
            document.getElementById('lobbyError').style.display = 'none';
            document.getElementById('roomCodeInput').value = '';
            document.getElementById('lobbyModal').classList.add('show');
        }

        function closeLobbyModal() {
            document.getElementById('lobbyModal').classList.remove('show');
            if (roomPollInterval) {
                clearInterval(roomPollInterval);
                roomPollInterval = null;
            }
            openModeSelectModal();
        }

        function showLobbyError(message) {
            const errorEl = document.getElementById('lobbyError');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => { errorEl.style.display = 'none'; }, 3000);
        }

        // Helper to ensure player is registered before multiplayer
        async function ensurePlayerRegistered(playerName) {
            // If already logged in with this name, we're good
            if (myPlayerId && myPlayerName === playerName) {
                return true;
            }

            // Clear old session if name changed
            if (playerName !== localStorage.getItem('playerName')) {
                sessionToken = null;
                localStorage.removeItem('sessionToken');
                myPlayerId = null;
                myPlayerName = '';
            }

            // Try to register with this name
            try {
                const regResponse = await authFetch(`${API_BASE}/api/auth/register`, {
                    method: 'POST',
                    body: JSON.stringify({
                        username: playerName,
                        displayName: playerName
                    })
                });

                if (regResponse.ok) {
                    const data = await regResponse.json();
                    if (data.success) {
                        sessionToken = data.token;
                        localStorage.setItem('sessionToken', sessionToken);
                        myPlayerId = data.playerId;
                        myPlayerName = data.username;
                        savePlayerName(data.username);
                        return true;
                    }
                } else if (regResponse.status === 409) {
                    // Username taken
                    showUsernameTakenModal(playerName);
                    return false;
                }
            } catch (e) {
                console.error('Registration error:', e);
            }
            return false;
        }

        // Room Functions
        async function createRoom() {
            let playerName = document.getElementById('mpPlayerNameInput').value.trim();
            if (!playerName) {
                playerName = 'Guest' + Math.floor(Math.random() * 10000);
            }

            // Ensure player is registered first
            const registered = await ensurePlayerRegistered(playerName);
            if (!registered) {
                return; // Modal shown, user must login or pick new name
            }

            try {
                const response = await fetch(`${API_BASE}/api/rooms/create`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        playerId: myPlayerId,
                        playerName: myPlayerName,
                        mode: selectedGameMode,
                        difficulty: selectedDifficulty.toUpperCase()
                    })
                });

                const data = await response.json();
                if (data.success) {
                    currentRoomCode = data.roomCode;
                    isRoomHost = true;
                    isPlayerReady = false;
                    showWaitingRoom(data.room);
                    startRoomPolling();
                    connectWebSocket();
                } else {
                    showLobbyError(data.error || 'Failed to create room');
                }
            } catch (err) {
                console.error('Create room error:', err);
                showLobbyError('Connection error');
            }
        }

        async function joinRoom() {
            const code = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            if (!code || code.length !== 6) {
                showLobbyError('Enter a valid 6-character room code');
                return;
            }

            let playerName = document.getElementById('mpPlayerNameInput').value.trim();
            if (!playerName) {
                playerName = 'Guest' + Math.floor(Math.random() * 10000);
            }

            // Ensure player is registered first
            const registered = await ensurePlayerRegistered(playerName);
            if (!registered) {
                return; // Modal shown, user must login or pick new name
            }

            try {
                const response = await fetch(`${API_BASE}/api/rooms/join/${code}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        playerId: myPlayerId,
                        playerName: myPlayerName
                    })
                });

                const data = await response.json();
                if (data.success) {
                    currentRoomCode = code;
                    isRoomHost = false;
                    isPlayerReady = false;
                    selectedGameMode = data.room.mode;
                    showWaitingRoom(data.room);
                    startRoomPolling();
                    connectWebSocket();
                } else {
                    showLobbyError(data.error || 'Failed to join room');
                }
            } catch (err) {
                console.error('Join room error:', err);
                showLobbyError('Connection error');
            }
        }

        async function leaveRoom() {
            if (roomPollInterval) {
                clearInterval(roomPollInterval);
                roomPollInterval = null;
            }

            if (currentRoomCode) {
                try {
                    await fetch(`${API_BASE}/api/rooms/leave`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ playerId: myPlayerId })
                    });
                } catch (err) {
                    console.error('Leave room error:', err);
                }
            }

            if (mpSocket) {
                mpSocket.emit('leave_game', { roomCode: currentRoomCode, playerId: myPlayerId });
            }

            currentRoomCode = null;
            isRoomHost = false;
            isPlayerReady = false;
            document.getElementById('roomOptions').style.display = 'block';
            document.getElementById('waitingRoom').style.display = 'none';
        }

        function showWaitingRoom(room) {
            document.getElementById('roomOptions').style.display = 'none';
            document.getElementById('matchmakingQueue').style.display = 'none';
            document.getElementById('waitingRoom').style.display = 'block';
            document.getElementById('displayRoomCode').textContent = room.code;
            updatePlayerSlots(room.players);
            updateStartButton(room);
        }

        function updatePlayerSlots(players) {
            const slot1 = document.getElementById('slot1');
            const slot2 = document.getElementById('slot2');

            // Reset slots
            slot1.querySelector('.slot-name').textContent = 'Waiting...';
            slot1.querySelector('.slot-name').style.color = '#666';
            slot1.querySelector('.ready-status').textContent = '';
            slot1.classList.remove('ready');

            slot2.querySelector('.slot-name').textContent = 'Waiting for player...';
            slot2.querySelector('.slot-name').style.color = '#666';
            slot2.querySelector('.ready-status').textContent = '';
            slot2.classList.remove('ready');

            players.forEach(p => {
                const slot = p.slot === 1 ? slot1 : slot2;
                slot.querySelector('.slot-name').textContent = p.name;
                slot.querySelector('.slot-name').style.color = '#fff';
                slot.querySelector('.ready-status').textContent = p.ready ? 'Ready' : '';
                slot.querySelector('.ready-status').classList.toggle('is-ready', p.ready);
                slot.classList.toggle('ready', p.ready);
            });
        }

        function updateStartButton(room) {
            const startBtn = document.getElementById('startBtn');
            const readyBtn = document.getElementById('readyBtn');

            // Only host can see start button
            if (isRoomHost && room.players.length === 2 && room.players.every(p => p.ready)) {
                startBtn.style.display = 'block';
                readyBtn.style.flex = '1';
            } else {
                startBtn.style.display = 'none';
                readyBtn.style.flex = '1';
            }

            // Update ready button text
            readyBtn.textContent = isPlayerReady ? 'Not Ready' : 'Ready';
            readyBtn.style.background = isPlayerReady
                ? 'linear-gradient(135deg, #6b7280, #4b5563)'
                : 'linear-gradient(135deg, #fbbf24, #d97706)';
        }

        async function toggleReady() {
            isPlayerReady = !isPlayerReady;

            try {
                const response = await fetch(`${API_BASE}/api/rooms/${currentRoomCode}/ready`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        playerId: myPlayerId,
                        ready: isPlayerReady
                    })
                });

                const data = await response.json();
                if (data.success) {
                    updatePlayerSlots(data.room.players);
                    updateStartButton(data.room);

                    // Notify via WebSocket
                    if (mpSocket) {
                        mpSocket.emit('ready_status', {
                            roomCode: currentRoomCode,
                            playerId: myPlayerId,
                            ready: isPlayerReady
                        });
                    }
                }
            } catch (err) {
                console.error('Toggle ready error:', err);
            }
        }

        async function startMultiplayerGame() {
            if (!isRoomHost) return;

            try {
                const response = await fetch(`${API_BASE}/api/rooms/${currentRoomCode}/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ playerId: myPlayerId })
                });

                const data = await response.json();
                if (data.success) {
                    // Notify via WebSocket
                    if (mpSocket) {
                        mpSocket.emit('game_started', {
                            roomCode: currentRoomCode,
                            mode: selectedGameMode,
                            difficulty: selectedDifficulty
                        });
                    }

                    // Start the game locally
                    launchMultiplayerGame(data.room);
                } else {
                    showLobbyError(data.error || 'Cannot start game');
                }
            } catch (err) {
                console.error('Start game error:', err);
            }
        }

        function startRoomPolling() {
            if (roomPollInterval) clearInterval(roomPollInterval);

            roomPollInterval = setInterval(async () => {
                if (!currentRoomCode) return;

                try {
                    const response = await fetch(`${API_BASE}/api/rooms/${currentRoomCode}`);
                    const room = await response.json();

                    if (room.error) {
                        // Room was deleted
                        leaveRoom();
                        showLobbyError('Room was closed');
                        return;
                    }

                    updatePlayerSlots(room.players);
                    updateStartButton(room);

                    // Check if game started
                    if (room.status === 'playing') {
                        clearInterval(roomPollInterval);
                        launchMultiplayerGame(room);
                    }
                } catch (err) {
                    console.error('Room poll error:', err);
                }
            }, 1500);
        }

        function copyRoomCode() {
            navigator.clipboard.writeText(currentRoomCode).then(() => {
                const btn = event.target;
                btn.textContent = 'Copied!';
                setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
            });
        }

        // Matchmaking
        async function quickMatch() {
            let playerName = document.getElementById('mpPlayerNameInput').value.trim();

            // Generate random guest name if none provided
            if (!playerName) {
                playerName = 'Guest' + Math.floor(Math.random() * 10000);
            }

            // Ensure player is registered first
            const registered = await ensurePlayerRegistered(playerName);
            if (!registered) {
                return; // Modal shown, user must login or pick new name
            }

            document.getElementById('roomOptions').style.display = 'none';
            document.getElementById('matchmakingQueue').style.display = 'block';
            document.getElementById('queuePosition').textContent = 'Joining queue...';

            try {
                const response = await fetch(`${API_BASE}/api/matchmaking/join`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        playerId: myPlayerId,
                        playerName: myPlayerName,
                        mode: selectedGameMode,
                        difficulty: selectedDifficulty.toUpperCase()
                    })
                });

                const data = await response.json();

                if (data.matched) {
                    // Found a match immediately
                    currentRoomCode = data.room_code;
                    isRoomHost = data.isHost || false;
                    isPlayerReady = false;
                    const roomResponse = await fetch(`${API_BASE}/api/rooms/${data.room_code}`);
                    const room = await roomResponse.json();
                    showWaitingRoom(room);
                    startRoomPolling();
                    connectWebSocket();
                } else {
                    // In queue, start polling
                    document.getElementById('queuePosition').textContent = `Position in queue: ${data.queue_position || 1}`;
                    startMatchmakingPolling();
                }
            } catch (err) {
                console.error('Quick match error:', err);
                showLobbyError('Connection error');
                document.getElementById('roomOptions').style.display = 'block';
                document.getElementById('matchmakingQueue').style.display = 'none';
            }
        }

        function startMatchmakingPolling() {
            if (matchmakingPollInterval) clearInterval(matchmakingPollInterval);

            matchmakingPollInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE}/api/matchmaking/status?playerId=${myPlayerId}`);
                    const data = await response.json();

                    if (data.matched) {
                        clearInterval(matchmakingPollInterval);
                        currentRoomCode = data.room_code;
                        isRoomHost = data.isHost || false;
                        const roomResponse = await fetch(`${API_BASE}/api/rooms/${data.room_code}`);
                        const room = await roomResponse.json();
                        showWaitingRoom(room);
                        startRoomPolling();
                        connectWebSocket();
                    } else if (data.inQueue) {
                        document.getElementById('queuePosition').textContent = `Position in queue: ${data.queue_position || 1}`;
                    } else {
                        // No longer in queue
                        clearInterval(matchmakingPollInterval);
                        document.getElementById('roomOptions').style.display = 'block';
                        document.getElementById('matchmakingQueue').style.display = 'none';
                    }
                } catch (err) {
                    console.error('Matchmaking poll error:', err);
                }
            }, 2000);
        }

        async function cancelMatchmaking() {
            if (matchmakingPollInterval) {
                clearInterval(matchmakingPollInterval);
                matchmakingPollInterval = null;
            }

            try {
                await fetch(`${API_BASE}/api/matchmaking/leave`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ playerId: myPlayerId })
                });
            } catch (err) {
                console.error('Cancel matchmaking error:', err);
            }

            document.getElementById('roomOptions').style.display = 'block';
            document.getElementById('matchmakingQueue').style.display = 'none';
        }

        // WebSocket Connection
        function connectWebSocket() {
            // Check if Socket.IO is available
            if (typeof io === 'undefined') {
                console.warn('Socket.IO not available, using polling fallback');
                return;
            }

            try {
                // If socket already exists and is connected, just join the room
                if (mpSocket && mpSocket.connected) {
                    console.log('WebSocket already connected, joining room:', currentRoomCode, 'as', myPlayerId);
                    if (currentRoomCode) {
                        mpSocket.emit('join_game', {
                            roomCode: currentRoomCode,
                            playerId: myPlayerId,
                            playerName: myPlayerName || 'Player'
                        });
                    }
                    return;
                }

                // Disconnect existing socket if any
                if (mpSocket) {
                    mpSocket.disconnect();
                    mpSocket = null;
                }

                mpSocket = io(API_BASE, { forceNew: true });

                mpSocket.on('connect', () => {
                    console.log('WebSocket connected, socket id:', mpSocket.id);
                    if (currentRoomCode) {
                        console.log('Joining room:', currentRoomCode, 'as', myPlayerId);
                        mpSocket.emit('join_game', {
                            roomCode: currentRoomCode,
                            playerId: myPlayerId,
                            playerName: myPlayerName || 'Player'
                        });
                    }
                });

                mpSocket.on('disconnect', () => {
                    console.log('WebSocket disconnected');
                });

                mpSocket.on('joined_game', (data) => {
                    console.log('Successfully joined room:', data.roomCode, 'success:', data.success);
                    serverLog('WebSocket room joined', { roomCode: data.roomCode, success: data.success, myPlayerId: myPlayerId });
                });

                mpSocket.on('player_joined', (data) => {
                    console.log('Player joined:', data.playerName);
                });

                mpSocket.on('player_left', (data) => {
                    console.log('Player left:', data.playerId);
                });

                mpSocket.on('room_update', (data) => {
                    if (data.room) {
                        updatePlayerSlots(data.room.players);
                        updateStartButton(data.room);
                    }
                });

                mpSocket.on('game_update', (data) => {
                    // Debug: log game updates (more frequently for debugging)
                    if (data.type === 'player_state') {
                        // Log first 5 updates always, then 5% of rest
                        if (!window._pvpUpdateCount) window._pvpUpdateCount = 0;
                        window._pvpUpdateCount++;
                        if (window._pvpUpdateCount <= 5 || Math.random() < 0.05) {
                            console.log('PvP: Received player_state from', data.playerId, 'at', Math.round(data.x), Math.round(data.y),
                                        'myPlayerId:', myPlayerId, 'isMe:', data.playerId === myPlayerId);
                        }
                    } else if (data.type === 'shoot') {
                        console.log('PvP: Received shoot from', data.playerId, 'at', Math.round(data.x), Math.round(data.y));
                    }
                    handleMultiplayerGameUpdate(data);
                });

                mpSocket.on('receive_hazard', (data) => {
                    handleIncomingHazard(data);
                });

                // Direct listener for game_started (backup for non-host players)
                mpSocket.on('game_started', async (data) => {
                    console.log('Received game_started event:', data);
                    if (!isRoomHost && currentRoomCode) {
                        // Fetch room data to get opponent info
                        try {
                            const response = await fetch(`${API_BASE}/api/rooms/${currentRoomCode}`);
                            const room = await response.json();
                            launchMultiplayerGame(room);
                        } catch (err) {
                            console.error('Failed to fetch room for game start:', err);
                            launchMultiplayerGame(null);
                        }
                    }
                });

                // PvP event handlers
                mpSocket.on('pvp_hit', (data) => {
                    handlePvPHit(data);
                });

                mpSocket.on('pvp_health_update', (data) => {
                    handleOpponentHealthUpdate(data);
                });

                mpSocket.on('round_ended', (data) => {
                    // Handle round end notification from opponent
                    if (data.loser && data.loser !== myPlayerId) {
                        // Opponent lost, we won this round
                        if (!versusState.matchOver) {
                            handleVersusRoundWin();
                        }
                    }
                });

                // === PAUSE/RESUME/LEAVE NOTIFICATIONS ===
                mpSocket.on('opponent_paused', (data) => {
                    console.log('Opponent paused:', data.playerName);
                    showOpponentPausedOverlay(data.playerName);
                });

                mpSocket.on('opponent_resumed', (data) => {
                    console.log('Opponent resumed:', data.playerName);
                    hideOpponentPausedOverlay();
                });

                mpSocket.on('opponent_left', (data) => {
                    console.log('Opponent left:', data.playerName, data.reason);
                    showOpponentLeftOverlay(data.playerName);
                });

            } catch (err) {
                console.error('WebSocket connection error:', err);
            }
        }

        async function handleMultiplayerGameUpdate(data) {
            // Handle different update types
            switch (data.type) {
                case 'player_state':
                    updateOtherPlayer(data);
                    break;
                case 'shoot':
                    handleOtherPlayerShoot(data);
                    break;
                case 'countdown':
                    showCountdown(data.seconds);
                    break;
                case 'game_started':
                    if (!isRoomHost && currentRoomCode) {
                        // Fetch room data to get opponent info
                        try {
                            const response = await fetch(`${API_BASE}/api/rooms/${currentRoomCode}`);
                            const room = await response.json();
                            launchMultiplayerGame(room);
                        } catch (err) {
                            console.error('Failed to fetch room:', err);
                            launchMultiplayerGame(null);
                        }
                    }
                    break;
                case 'died':
                    handleOtherPlayerDied(data);
                    break;
                case 'respawn':
                    handleOtherPlayerRespawn(data);
                    break;
                case 'game_over':
                    handleMultiplayerGameOver(data);
                    break;
                // Versus mode specific
                case 'hit':
                case 'round_end':
                case 'match_end':
                    if (selectedGameMode === 'versus') {
                        handleVersusGameUpdate(data);
                    }
                    break;
            }
        }

        function updateOtherPlayer(data) {
            // Update the other player's state from WebSocket
            if (data.playerId === myPlayerId) return; // Ignore own updates

            // Debug: log opponent updates
            if (!otherPlayer.id) {
                console.log('PvP: First opponent update received!', data.playerId, data.x, data.y);
                serverLog('First opponent update received', { opponentId: data.playerId, x: data.x, y: data.y, myPlayerId: myPlayerId });
            }

            // Mark partner/opponent as connected
            if (selectedGameMode === 'coop') {
                coopState.partnerConnected = true;
            }

            otherPlayer.id = data.playerId;
            otherPlayer.name = data.playerName || otherPlayer.name || 'Opponent';
            otherPlayer.x = data.x;

            // In versus mode, mirror opponent's Y position so they appear at top of screen
            // (they see themselves at bottom, we see them at top - like facing each other)
            if (selectedGameMode === 'versus') {
                otherPlayer.y = logicalHeight - data.y;
            } else {
                otherPlayer.y = data.y;
            }

            otherPlayer.dx = data.dx || 0;
            otherPlayer.dy = data.dy || 0;
            otherPlayer.shieldActive = data.shieldActive || false;
            otherPlayer.ghostActive = data.ghostActive || false;
            otherPlayer.currentWeapon = data.currentWeapon || 'pistol';
            otherPlayer.lives = data.lives || 3;
            otherPlayer.isActive = data.isActive !== false;
            otherPlayer.isInvincible = data.isInvincible || false;

            // For versus mode, also track opponent health
            if (selectedGameMode === 'versus' && data.health !== null && data.health !== undefined) {
                versusState.opponentHealth = data.health;
                updateVersusHud();
            }
        }

        function handleOtherPlayerShoot(data) {
            // Create bullet for other player
            console.log('PvP: Received shot from', data.playerId, 'myPlayerId:', myPlayerId, 'at', Math.round(data.x), Math.round(data.y));
            if (data.playerId === myPlayerId) {
                console.log('PvP: Ignoring own bullet from server');
                return;
            }

            const weaponData = {
                pistol: { speed: 600, size: 4, color: '#4ade80' },
                machinegun: { speed: 700, size: 3, color: '#fbbf24' },
                bazooka: { speed: 400, size: 8, color: '#ef4444' }
            };
            const wp = weaponData[data.weapon] || weaponData.pistol;

            // Bullet movement: b.y -= b.speed * dt
            // So: positive speed = UP, negative speed = DOWN
            // In versus mode, opponent is at top, their bullets should go DOWN (negative speed)
            // In coop mode, partner bullets go UP (positive speed, same as player)
            const bulletSpeed = (selectedGameMode === 'versus') ? -wp.speed : wp.speed;

            // Transform Y position for versus mode - opponent shoots from top of screen
            // The received Y is from their perspective (bottom), we need to mirror it
            let bulletY = data.y;
            if (selectedGameMode === 'versus') {
                bulletY = logicalHeight - data.y;  // Mirror Y position
            }

            bullets.push({
                x: data.x,
                y: bulletY,
                speed: bulletSpeed,  // Use 'speed' not 'dy' - this is what bullet movement uses
                size: wp.size,
                width: wp.size * 2,
                height: wp.size * 3,
                color: wp.color,
                weapon: data.weapon,
                fromPartner: true,  // Mark as opponent's bullet for collision detection
                id: data.bulletId
            });

            console.log('PvP: Created opponent bullet at', Math.round(data.x), Math.round(bulletY), 'speed:', bulletSpeed);
        }

        function handleOtherPlayerDied(data) {
            // Handle when other player dies
            if (data.playerId === myPlayerId) return;

            otherPlayer.isActive = false;
            otherPlayer.respawnsLeft = data.respawnsLeft || 0;
            otherPlayer.respawnStartTime = Date.now();

            // Create explosion at their position
            if (typeof createExplosion === 'function') {
                createExplosion(otherPlayer.x, otherPlayer.y, jetColors[otherPlayer.color].body);
            }

            // Check if both players are permanently out
            if (otherPlayer.respawnsLeft <= 0 && coopState.myRespawnsLeft <= 0 && !coopState.amActive) {
                // Both players permanently dead - game over
                handleMultiplayerGameOver({ reason: 'All players eliminated' });
            }
        }

        function handleOtherPlayerRespawn(data) {
            // Handle when other player respawns
            if (data.playerId === myPlayerId) return;

            otherPlayer.isActive = true;
            otherPlayer.x = data.x || logicalWidth / 2;
            otherPlayer.y = data.y || logicalHeight - 80;
            otherPlayer.respawnsLeft = data.respawnsLeft;
            otherPlayer.isInvincible = true;
            otherPlayer.invincibleUntil = Date.now() + COOP_INVINCIBILITY_TIME;
        }

        function handleMultiplayerGameOver(data) {
            // Show game over screen with multiplayer results
            gameRunning = false;
            stopPositionSync();

            // Notify server
            if (mpSocket && currentRoomCode) {
                mpSocket.emit('game_over', {
                    roomCode: currentRoomCode,
                    reason: data.reason || 'Game Over',
                    finalScore: coopState.sharedScore || score,
                    level: level
                });
            }

            // Show game over screen
            gameOver(data.reason || 'Game Over');
        }

        function showCountdown(seconds) {
            // Show countdown overlay before game starts
            const overlay = document.createElement('div');
            overlay.id = 'countdownOverlay';
            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);display:flex;justify-content:center;align-items:center;z-index:9999;';
            overlay.innerHTML = `<div style="font-size:120px;color:#fff;text-shadow:0 0 30px #4ade80;">${seconds}</div>`;
            document.body.appendChild(overlay);

            let count = seconds;
            const countInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    overlay.innerHTML = `<div style="font-size:120px;color:#fff;text-shadow:0 0 30px #4ade80;">${count}</div>`;
                } else {
                    overlay.innerHTML = `<div style="font-size:80px;color:#4ade80;text-shadow:0 0 30px #4ade80;">GO!</div>`;
                    setTimeout(() => {
                        overlay.remove();
                    }, 500);
                    clearInterval(countInterval);
                }
            }, 1000);
        }

        // Start syncing position to partner
        function startPositionSync() {
            if (positionSyncInterval) clearInterval(positionSyncInterval);

            console.log('PvP: Starting position sync - playerId:', myPlayerId, 'roomCode:', currentRoomCode, 'gameMode:', selectedGameMode);
            serverLog('Position sync started', { playerId: myPlayerId, roomCode: currentRoomCode, gameMode: selectedGameMode });

            positionSyncInterval = setInterval(() => {
                if (!gameRunning || !isMultiplayer || !mpSocket || !currentRoomCode) {
                    if (Math.random() < 0.01) console.log('PvP sync skipped:', { gameRunning, isMultiplayer, hasSocket: !!mpSocket, currentRoomCode });
                    return;
                }

                // Determine isActive based on game mode
                const playerIsActive = selectedGameMode === 'versus'
                    ? (versusState.myHealth > 0 && versusState.roundActive)
                    : coopState.amActive;

                // Debug: log position sync sends
                if (Math.random() < 0.02) {
                    console.log('PvP: Sending position', player.x.toFixed(0), player.y.toFixed(0), 'to room', currentRoomCode);
                }

                mpSocket.emit('player_state', {
                    roomCode: currentRoomCode,
                    playerId: myPlayerId,
                    playerName: myPlayerName,
                    x: player.x,
                    y: player.y,
                    dx: player.dx || 0,
                    dy: player.dy || 0,
                    shieldActive: shieldActive,
                    ghostActive: ghostActive,
                    currentWeapon: currentWeapon,
                    lives: lives,
                    score: score,
                    isActive: playerIsActive,
                    isInvincible: selectedGameMode === 'versus' ? versusState.myInvulnerable : coopState.amInvincible,
                    gameMode: selectedGameMode,
                    health: selectedGameMode === 'versus' ? versusState.myHealth : null
                });
            }, POSITION_SYNC_RATE);
        }

        function stopPositionSync() {
            if (positionSyncInterval) {
                clearInterval(positionSyncInterval);
                positionSyncInterval = null;
            }
        }

        // Broadcast when we shoot
        function broadcastShoot(x, y, weapon) {
            if (!isMultiplayer || !mpSocket || !currentRoomCode) return;

            mpSocket.emit('player_shoot', {
                roomCode: currentRoomCode,
                playerId: myPlayerId,
                x: x,
                y: y,
                weapon: weapon,
                bulletId: Date.now() + '_' + Math.random().toString(36).substr(2, 9)
            });
        }

        // Broadcast when we die
        function broadcastDeath(reason) {
            if (!isMultiplayer || !mpSocket || !currentRoomCode) return;

            mpSocket.emit('player_died', {
                roomCode: currentRoomCode,
                playerId: myPlayerId,
                reason: reason,
                respawnsLeft: coopState.myRespawnsLeft
            });
        }

        // Broadcast when we respawn
        function broadcastRespawn() {
            if (!isMultiplayer || !mpSocket || !currentRoomCode) return;

            mpSocket.emit('player_respawn', {
                roomCode: currentRoomCode,
                playerId: myPlayerId,
                x: player.x,
                y: player.y,
                respawnsLeft: coopState.myRespawnsLeft
            });
        }

        function launchMultiplayerGame(room) {
            // Close lobby modal
            document.getElementById('lobbyModal').classList.remove('show');
            if (roomPollInterval) {
                clearInterval(roomPollInterval);
                roomPollInterval = null;
            }

            // Copy multiplayer name to main name input so startGame() picks it up
            const mpName = document.getElementById('mpPlayerNameInput').value.trim();
            if (mpName) {
                document.getElementById('playerNameInput').value = mpName;
            }

            console.log('Launching multiplayer game:', selectedGameMode, room);

            // Set game mode and initialize state
            isMultiplayer = true;
            if (selectedGameMode === 'coop') {
                resetCoopState();
            } else if (selectedGameMode === 'versus') {
                resetVersusState();
            }

            // Set opponent info from room data if available
            console.log('launchMultiplayerGame: room data:', room);
            if (room && room.players) {
                console.log('launchMultiplayerGame: players:', room.players, 'myPlayerId:', myPlayerId);
                const opponent = room.players.find(p => p.id !== myPlayerId);
                if (opponent) {
                    console.log('launchMultiplayerGame: found opponent:', opponent);
                    otherPlayer.id = opponent.id;
                    otherPlayer.name = opponent.name || (selectedGameMode === 'versus' ? 'Opponent' : 'Partner');
                    if (selectedGameMode === 'coop') {
                        coopState.partnerConnected = true;
                    }
                    // P2 gets green color if P1 is blue, orange if P1 is pink
                    otherPlayer.color = selectedColor === 'blue' ? 'green' : 'orange';
                } else {
                    console.log('launchMultiplayerGame: no opponent found in players array');
                }
            } else {
                console.log('launchMultiplayerGame: no room or players data');
            }

            // Start the game
            startGame();

            // Start position sync after game starts
            if (selectedGameMode === 'coop' || selectedGameMode === 'versus') {
                startPositionSync();
            }

            // For versus mode, show countdown before first round
            if (selectedGameMode === 'versus') {
                versusState.roundActive = false;
                versusState.roundStartCountdown = true;
                // Position players for head-to-head: player at bottom, opponent at top
                player.x = logicalWidth / 2;
                player.y = logicalHeight - 100;  // Bottom of screen
                otherPlayer.x = logicalWidth / 2;
                otherPlayer.y = 100;  // Top of screen
                otherPlayer.isActive = true;
                updateVersusHud();
                startPvPRoundCountdown(() => {
                    versusState.roundActive = true;
                });
            }
        }

        // Flag for multiplayer mode
        let isMultiplayer = false;

        // === COOP MULTIPLAYER STATE ===
        const COOP_MAX_RESPAWNS = 3;
        const COOP_RESPAWN_TIME = 5000; // 5 seconds
        const COOP_INVINCIBILITY_TIME = 2000; // 2 seconds after respawn

        // Other player state (partner in coop)
        let otherPlayer = {
            id: null,
            name: 'Partner',
            x: 0,
            y: 0,
            dx: 0,
            dy: 0,
            isActive: true,          // Currently alive and playing
            respawnsLeft: COOP_MAX_RESPAWNS,
            respawnTimer: 0,         // Countdown to respawn
            respawnStartTime: 0,
            isInvincible: false,
            invincibleUntil: 0,
            shieldActive: false,
            ghostActive: false,
            currentWeapon: 'pistol',
            color: 'pink',           // P2 uses pink by default
            lives: 3,
            score: 0
        };

        // Coop game state
        let coopState = {
            isHost: false,           // Host controls enemy spawning
            sharedScore: 0,
            myRespawnsLeft: COOP_MAX_RESPAWNS,
            myRespawnTimer: 0,
            myRespawnStartTime: 0,
            amActive: true,          // Am I currently alive?
            amInvincible: false,
            invincibleUntil: 0,
            partnerConnected: false,
            lastSyncTime: 0
        };

        // Position sync interval (50ms = 20 updates/sec)
        let positionSyncInterval = null;
        const POSITION_SYNC_RATE = 50;

        function resetCoopState() {
            otherPlayer = {
                id: null, name: 'Partner', x: logicalWidth / 2, y: logicalHeight - 80,
                dx: 0, dy: 0, isActive: true, respawnsLeft: COOP_MAX_RESPAWNS,
                respawnTimer: 0, respawnStartTime: 0, isInvincible: false, invincibleUntil: 0,
                shieldActive: false, ghostActive: false, currentWeapon: 'pistol',
                color: 'pink', lives: 3, score: 0
            };
            coopState = {
                isHost: isRoomHost, sharedScore: 0, myRespawnsLeft: COOP_MAX_RESPAWNS,
                myRespawnTimer: 0, myRespawnStartTime: 0, amActive: true,
                amInvincible: false, invincibleUntil: 0, partnerConnected: false, lastSyncTime: 0
            };
        }

        // Check if player can take damage (respects coop state)
        function canTakeDamage() {
            // In coop mode, check if we're active and not invincible
            if (isMultiplayer && selectedGameMode === 'coop') {
                if (!coopState.amActive) return false;  // Dead/respawning
                if (coopState.amInvincible) return false;  // Temp invincibility after respawn
            }
            return true;
        }

        // Update coop HUD display
        function updateCoopHud() {
            if (!isMultiplayer || selectedGameMode !== 'coop') return;

            // P1 (self) stats
            document.getElementById('coopP1Lives').textContent = lives;
            document.getElementById('coopP1Respawns').textContent = coopState.myRespawnsLeft;

            // P2 (partner) stats
            document.getElementById('coopP2Name').textContent = otherPlayer.name;
            document.getElementById('coopP2Lives').textContent = otherPlayer.lives;
            document.getElementById('coopP2Respawns').textContent = otherPlayer.respawnsLeft;

            // Shared score and level
            document.getElementById('coopScore').textContent = score;
            document.getElementById('coopLevelDisplay').textContent = level <= 5 ? 'Level ' + level : 'FINAL LEVEL';

            // Update P1 box style based on state
            const p1Box = document.getElementById('coopP1Stats');
            if (!coopState.amActive) {
                p1Box.style.opacity = '0.5';
                p1Box.style.borderStyle = 'dashed';
            } else {
                p1Box.style.opacity = '1';
                p1Box.style.borderStyle = 'solid';
            }

            // Update P2 box style based on state
            const p2Box = document.getElementById('coopP2Stats');
            if (!otherPlayer.isActive) {
                p2Box.style.opacity = '0.5';
                p2Box.style.borderStyle = 'dashed';
            } else {
                p2Box.style.opacity = '1';
                p2Box.style.borderStyle = 'solid';
            }
        }

        // Show/hide appropriate HUD based on game mode
        function setupGameHud() {
            const normalUi = document.getElementById('ui');
            const coopHud = document.getElementById('coopHud');

            if (isMultiplayer && selectedGameMode === 'coop') {
                normalUi.style.display = 'none';
                coopHud.style.display = 'block';
                updateCoopHud();
            } else if (isMultiplayer && selectedGameMode === 'versus') {
                normalUi.style.display = 'none';
                coopHud.style.display = 'none';
                document.getElementById('versusHud').style.display = 'block';
                updateVersusHud();
            } else {
                normalUi.style.display = 'flex';
                coopHud.style.display = 'none';
                document.getElementById('versusHud').style.display = 'none';
            }
        }

        // === VERSUS MODE STATE (True PvP) ===
        const PVP_MAX_HEALTH = 100;
        const PVP_BULLET_DAMAGE = 10;
        const PVP_INVULN_TIME = 500;      // 500ms invulnerability after hit
        const VERSUS_ROUNDS_TO_WIN = 2;   // Best of 3

        let versusState = {
            myHealth: PVP_MAX_HEALTH,
            myScore: 0,
            opponentHealth: PVP_MAX_HEALTH,
            opponentScore: 0,
            myRoundWins: 0,
            opponentRoundWins: 0,
            currentRound: 1,
            roundActive: true,
            matchOver: false,
            myInvulnerable: false,        // Invulnerability after hit
            opponentInvulnerable: false,
            roundStartCountdown: false    // For round start countdown
        };

        function resetVersusState() {
            versusState = {
                myHealth: PVP_MAX_HEALTH,
                myScore: 0,
                opponentHealth: PVP_MAX_HEALTH,
                opponentScore: 0,
                myRoundWins: 0,
                opponentRoundWins: 0,
                currentRound: 1,
                roundActive: true,
                matchOver: false,
                myInvulnerable: false,
                opponentInvulnerable: false,
                roundStartCountdown: false
            };
        }

        function resetVersusRound() {
            versusState.myHealth = PVP_MAX_HEALTH;
            versusState.opponentHealth = PVP_MAX_HEALTH;
            versusState.roundActive = true;
            versusState.myInvulnerable = false;
            versusState.opponentInvulnerable = false;
            versusState.roundStartCountdown = true;

            // Position players for head-to-head: player at bottom, opponent at top
            player.x = logicalWidth / 2;
            player.y = logicalHeight - 100;  // Bottom of screen
            otherPlayer.x = logicalWidth / 2;
            otherPlayer.y = 100;  // Top of screen
            otherPlayer.isActive = true;

            // Clear bullets and enemies for fresh round
            bullets.length = 0;
            enemies.length = 0;

            updateVersusHud();
        }

        // Award hazard points for various actions
        function awardHazardPoints(reason, amount) {
            if (!isMultiplayer || selectedGameMode !== 'versus') return;
            versusState.myHazardPoints += amount;
            updateVersusHud();
            // Show floating text
            showFloatingText('+' + amount + ' HP', player.x, player.y - 60, '#a855f7');
        }

        // Show floating text above player
        function showFloatingText(text, x, y, color) {
            const floater = document.createElement('div');
            floater.textContent = text;
            floater.style.cssText = `
                position: fixed; left: 50%; top: 40%;
                transform: translateX(-50%);
                color: ${color}; font-size: 24px; font-weight: bold;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                pointer-events: none; z-index: 1000;
                animation: floatUp 1s ease-out forwards;
            `;
            document.body.appendChild(floater);
            setTimeout(() => floater.remove(), 1000);
        }

        // Check for survival bonus (every 30 seconds)
        function checkSurvivalBonus() {
            if (!isMultiplayer || selectedGameMode !== 'versus') return;
            const now = Date.now();
            if (now - versusState.lastSurvivalBonus >= 30000) {
                versusState.lastSurvivalBonus = now;
                awardHazardPoints('survival', 2);
            }
        }

        // Track last enemy count for kill streak bonuses
        let lastEnemyKillCount = 0;

        // Check for kill streak hazard point bonuses
        function checkKillStreakBonus() {
            if (!isMultiplayer || selectedGameMode !== 'versus') return;

            const killsSinceLastCheck = totalEnemiesKilled - lastEnemyKillCount;
            if (killsSinceLastCheck >= 3) {
                // Award points for every 3 kills
                const bonusMultiplier = Math.floor(killsSinceLastCheck / 3);
                awardHazardPoints('kills', 2 * bonusMultiplier);
                lastEnemyKillCount = totalEnemiesKilled - (killsSinceLastCheck % 3);
            }
        }

        // Award hazard points for powerup collection
        function onPowerupCollected() {
            if (isMultiplayer && selectedGameMode === 'versus') {
                awardHazardPoints('powerup', 1);
            }
        }

        // Update versus HUD
        function updateVersusHud() {
            if (!isMultiplayer || selectedGameMode !== 'versus') return;

            // Update health bars
            const myHealthPercent = (versusState.myHealth / PVP_MAX_HEALTH) * 100;
            const opponentHealthPercent = (versusState.opponentHealth / PVP_MAX_HEALTH) * 100;

            document.getElementById('versusP1HealthBar').style.width = myHealthPercent + '%';
            document.getElementById('versusP1HealthText').textContent = Math.max(0, versusState.myHealth);
            document.getElementById('versusP2HealthBar').style.width = opponentHealthPercent + '%';
            document.getElementById('versusP2HealthText').textContent = Math.max(0, versusState.opponentHealth);
            document.getElementById('versusP2Name').textContent = otherPlayer.name || 'Opponent';

            // Update round info
            document.getElementById('versusRoundInfo').textContent = `Round ${versusState.currentRound}`;

            // Update win indicators (filled circle = win, empty = no win yet)
            const p1WinsStr = '‚óè'.repeat(versusState.myRoundWins) + '‚óã'.repeat(VERSUS_ROUNDS_TO_WIN - versusState.myRoundWins);
            const p2WinsStr = '‚óè'.repeat(versusState.opponentRoundWins) + '‚óã'.repeat(VERSUS_ROUNDS_TO_WIN - versusState.opponentRoundWins);
            document.getElementById('versusP1Wins').textContent = p1WinsStr;
            document.getElementById('versusP2Wins').textContent = p2WinsStr;

            // Color health bars based on health level
            const p1Bar = document.getElementById('versusP1HealthBar');
            const p2Bar = document.getElementById('versusP2HealthBar');
            if (myHealthPercent <= 25) {
                p1Bar.style.background = 'linear-gradient(90deg, #ef4444, #dc2626)';
            } else if (myHealthPercent <= 50) {
                p1Bar.style.background = 'linear-gradient(90deg, #f59e0b, #d97706)';
            } else {
                p1Bar.style.background = 'linear-gradient(90deg, #3b82f6, #60a5fa)';
            }
            if (opponentHealthPercent <= 25) {
                p2Bar.style.background = 'linear-gradient(90deg, #dc2626, #ef4444)';
            } else if (opponentHealthPercent <= 50) {
                p2Bar.style.background = 'linear-gradient(90deg, #d97706, #f59e0b)';
            } else {
                p2Bar.style.background = 'linear-gradient(90deg, #f87171, #ef4444)';
            }
        }

        // === PVP DAMAGE SYSTEM ===

        // Take PvP damage
        function takePvPDamage(damage) {
            if (!isMultiplayer || selectedGameMode !== 'versus') return;
            if (versusState.myInvulnerable || !versusState.roundActive) return;

            versusState.myHealth -= damage;
            versusState.myInvulnerable = true;

            // Flash effect
            playerHitFlash = 300;
            playOuchSound();
            createExplosion(player.x, player.y, '#ff6666');

            // Update HUD
            updateVersusHud();

            // Broadcast health update to opponent
            if (mpSocket && currentRoomCode) {
                mpSocket.emit('pvp_health_update', {
                    roomCode: currentRoomCode,
                    playerId: myPlayerId,
                    health: versusState.myHealth
                });
            }

            // End invulnerability after timer
            setTimeout(() => {
                versusState.myInvulnerable = false;
            }, PVP_INVULN_TIME);

            // Check for round loss
            if (versusState.myHealth <= 0) {
                versusState.myHealth = 0;
                updateVersusHud();
                handleVersusRoundLoss();
            }
        }

        // Deal PvP damage to opponent (when our bullet hits them)
        function dealPvPDamage(damage) {
            if (!isMultiplayer || selectedGameMode !== 'versus') return;
            if (versusState.opponentInvulnerable || !versusState.roundActive) return;

            // Broadcast hit to opponent
            if (mpSocket && currentRoomCode) {
                mpSocket.emit('pvp_hit', {
                    roomCode: currentRoomCode,
                    shooterId: myPlayerId,
                    damage: damage
                });
            }

            // Visual feedback - we hit them
            versusState.myScore += 50;
            showFloatingText('+HIT!', player.x, player.y - 60, '#4ade80');
        }

        // Handle incoming damage from opponent's bullet
        function handlePvPHit(data) {
            if (data.shooterId === myPlayerId) return;  // Ignore our own shots
            takePvPDamage(data.damage);
        }

        // Handle opponent health update
        function handleOpponentHealthUpdate(data) {
            if (data.playerId === myPlayerId) return;  // Ignore our own updates
            versusState.opponentHealth = data.health;
            versusState.opponentInvulnerable = true;
            setTimeout(() => {
                versusState.opponentInvulnerable = false;
            }, PVP_INVULN_TIME);
            updateVersusHud();

            // Check if opponent died
            if (versusState.opponentHealth <= 0) {
                handleVersusRoundWin();
            }
        }

        // PvP round countdown
        function startPvPRoundCountdown(callback) {
            const countdownEl = document.getElementById('pvpCountdown');
            countdownEl.style.display = 'block';
            versusState.roundStartCountdown = true;

            let count = 3;
            countdownEl.textContent = count;

            const countInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownEl.textContent = count;
                } else if (count === 0) {
                    countdownEl.textContent = 'FIGHT!';
                } else {
                    clearInterval(countInterval);
                    countdownEl.style.display = 'none';
                    versusState.roundStartCountdown = false;
                    if (callback) callback();
                }
            }, 1000);
        }

        // Send hazard to opponent
        function sendHazard(hazardType) {
            if (!isMultiplayer || selectedGameMode !== 'versus') return;
            const hazard = HAZARDS[hazardType];
            if (!hazard || versusState.myHazardPoints < hazard.cost) return;

            versusState.myHazardPoints -= hazard.cost;
            updateVersusHud();

            // Broadcast to opponent
            if (mpSocket && currentRoomCode) {
                mpSocket.emit('send_hazard', {
                    roomCode: currentRoomCode,
                    senderId: myPlayerId,
                    hazardType: hazardType
                });
            }
        }

        // Handle incoming hazard from opponent
        function handleIncomingHazard(data) {
            if (data.senderId === myPlayerId) return;

            const hazardType = data.hazardType;
            console.log('Received hazard:', hazardType);

            switch (hazardType) {
                case 'drones':
                    // Spawn 3 drones near player
                    for (let i = 0; i < 3; i++) {
                        const x = player.x + (Math.random() - 0.5) * 200;
                        enemies.push({
                            x: Math.max(30, Math.min(logicalWidth - 30, x)),
                            y: -50 - i * 40,
                            width: 30, height: 30,
                            weapon: 'pistol',
                            speed: 150,
                            lastShot: 0, fireRate: 2000
                        });
                    }
                    break;
                case 'bomb':
                    // Drop bomb near player
                    bombs.push({
                        x: player.x + (Math.random() - 0.5) * 100,
                        y: -30,
                        width: 30, height: 40, speed: 200
                    });
                    break;
                case 'wall':
                    // Create wall in player's path
                    walls.push({
                        x: player.x - 50,
                        y: -20,
                        width: 100, height: 20, speed: 100
                    });
                    break;
                case 'speedup':
                    // Speed up all enemies temporarily
                    enemies.forEach(e => e.speed *= 1.5);
                    setTimeout(() => {
                        enemies.forEach(e => e.speed /= 1.5);
                    }, 5000);
                    break;
                case 'mines':
                    // Spawn 5 mines near player
                    for (let i = 0; i < 5; i++) {
                        mines.push({
                            x: player.x + (Math.random() - 0.5) * 300,
                            y: player.y - 200 - Math.random() * 200,
                            width: 20, height: 20,
                            armed: true
                        });
                    }
                    break;
            }

            // Show warning
            showFloatingText(HAZARDS[hazardType].icon + ' HAZARD!', player.x, player.y - 80, '#ef4444');
        }

        // Handle losing a round in versus mode
        function handleVersusRoundLoss() {
            versusState.roundActive = false;
            versusState.opponentRoundWins++;

            // Broadcast round end
            if (mpSocket && currentRoomCode) {
                mpSocket.emit('round_end', {
                    roomCode: currentRoomCode,
                    winnerId: otherPlayer.id,
                    roundNumber: versusState.currentRound,
                    scores: {
                        [myPlayerId]: versusState.myScore,
                        [otherPlayer.id]: versusState.opponentScore
                    }
                });
            }

            // Check if match is over
            if (versusState.opponentRoundWins >= VERSUS_ROUNDS_TO_WIN) {
                handleVersusMatchEnd(otherPlayer.id);
            } else {
                // Show round lost message and prepare next round
                showVersusRoundOverlay('ROUND LOST', '#ef4444', () => {
                    versusState.currentRound++;
                    resetVersusRound();
                    updateVersusHud();
                    // Start countdown for next round
                    startPvPRoundCountdown(() => {
                        versusState.roundActive = true;
                    });
                });
            }
        }

        // Handle winning a round in versus mode
        function handleVersusRoundWin() {
            versusState.roundActive = false;
            versusState.myRoundWins++;

            // Check if match is over
            if (versusState.myRoundWins >= VERSUS_ROUNDS_TO_WIN) {
                handleVersusMatchEnd(myPlayerId);
            } else {
                // Show round won message and prepare next round
                showVersusRoundOverlay('ROUND WON!', '#4ade80', () => {
                    versusState.currentRound++;
                    resetVersusRound();
                    updateVersusHud();
                    // Start countdown for next round
                    startPvPRoundCountdown(() => {
                        versusState.roundActive = true;
                    });
                });
            }
        }

        // Handle match end
        function handleVersusMatchEnd(winnerId) {
            versusState.matchOver = true;
            gameRunning = false;
            stopPositionSync();
            stopBackgroundMusic();
            stopBossMusic();

            const isWinner = winnerId === myPlayerId;

            // Broadcast match end
            if (mpSocket && currentRoomCode) {
                mpSocket.emit('match_end', {
                    roomCode: currentRoomCode,
                    winnerId: winnerId,
                    finalScores: {
                        [myPlayerId]: versusState.myScore,
                        [otherPlayer.id]: versusState.opponentScore
                    }
                });
            }

            // Show match result
            const title = isWinner ? 'VICTORY!' : 'DEFEAT';
            const color = isWinner ? '#ffd700' : '#ef4444';
            showVersusMatchOverlay(title, color, versusState.myScore, versusState.opponentScore);
        }

        // Show round transition overlay
        function showVersusRoundOverlay(text, color, callback) {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
                justify-content: center; align-items: center; z-index: 9999;
            `;
            overlay.innerHTML = `
                <div style="font-size: 48px; color: ${color}; font-weight: bold; text-shadow: 0 0 20px ${color};">${text}</div>
                <div style="font-size: 24px; color: #fff; margin-top: 20px;">Next round starting...</div>
            `;
            document.body.appendChild(overlay);

            setTimeout(() => {
                overlay.remove();
                if (callback) callback();
            }, 3000);
        }

        // Show match end overlay
        function showVersusMatchOverlay(title, color, myScore, theirScore) {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
                justify-content: center; align-items: center; z-index: 9999;
            `;
            overlay.innerHTML = `
                <div style="font-size: 64px; color: ${color}; font-weight: bold; text-shadow: 0 0 30px ${color}; margin-bottom: 30px;">${title}</div>
                <div style="font-size: 24px; color: #fff; margin-bottom: 20px;">Final Score</div>
                <div style="display: flex; gap: 40px; font-size: 32px; color: #fff;">
                    <div style="text-align: center;">
                        <div style="color: #3b82f6;">YOU</div>
                        <div>${myScore}</div>
                        <div style="font-size: 18px; color: #888;">${versusState.myRoundWins} rounds</div>
                    </div>
                    <div style="font-size: 48px;">-</div>
                    <div style="text-align: center;">
                        <div style="color: #ef4444;">${otherPlayer.name}</div>
                        <div>${theirScore}</div>
                        <div style="font-size: 18px; color: #888;">${versusState.opponentRoundWins} rounds</div>
                    </div>
                </div>
                <button onclick="this.parentElement.remove(); backToMenu();" style="margin-top: 40px; padding: 15px 40px; font-size: 18px; background: linear-gradient(135deg, #4a6cf7, #6a4cf7); color: #fff; border: none; border-radius: 25px; cursor: pointer;">Back to Menu</button>
            `;
            document.body.appendChild(overlay);
        }

        // Handle opponent's round/match updates via WebSocket
        function handleVersusGameUpdate(data) {
            switch (data.type) {
                case 'hit':
                    // Legacy hit handler - now using health-based PvP system
                    // Hits are now handled via pvp_hit and takePvPDamage
                    break;
                case 'round_end':
                    // Round end sync - only process if we haven't already handled it locally
                    // The winner calls handleVersusRoundWin (increments myRoundWins)
                    // The loser calls handleVersusRoundLoss (increments opponentRoundWins)
                    // So we only need to sync for the winner when they receive the loser's broadcast
                    // But since winner already incremented their own wins, we skip duplicate counting
                    // This event is mainly for logging/debugging
                    console.log('Round end received:', data.winnerId === myPlayerId ? 'I won' : 'Opponent won');
                    break;
                case 'match_end':
                    if (!versusState.matchOver) {
                        handleVersusMatchEnd(data.winnerId);
                    }
                    break;
            }
        }

        // Continue Game modal
        let continueGameData = null;

        function openContinueModal() {
            continueGameData = null;
            document.getElementById('continueKeyInput').value = '';
            document.getElementById('continueKeyError').style.display = 'none';
            document.getElementById('continueKeySection').style.display = 'block';
            document.getElementById('continueDataSection').style.display = 'none';
            document.getElementById('continueModal').classList.add('show');
        }

        function closeContinueModal() {
            document.getElementById('continueModal').classList.remove('show');
            continueGameData = null;
        }

        async function validateContinueKey() {
            const key = document.getElementById('continueKeyInput').value.trim().toUpperCase();
            const errorEl = document.getElementById('continueKeyError');
            const btn = document.getElementById('validateKeyBtn');

            if (!key) {
                errorEl.textContent = 'Please enter a continue key';
                errorEl.style.display = 'block';
                return;
            }

            // Accept both old 6-char keys (FJ-XXXXXX) and new 9-char keys (FJ-XXXXXXXXX)
            if (!key.match(/^FJ-[A-Z0-9]{6,9}$/)) {
                errorEl.textContent = 'Invalid key format. Keys should be like FJ-XXXXXXXXX';
                errorEl.style.display = 'block';
                return;
            }

            errorEl.style.display = 'none';
            btn.disabled = true;
            btn.textContent = 'Validating...';

            try {
                const response = await fetch(`${API_BASE}/api/player/validate-key`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ key: key })
                });

                const data = await response.json();

                if (data.valid) {
                    // Store data for starting game
                    continueGameData = {
                        name: data.name,
                        level: data.level,
                        score: data.score,
                        difficulty: data.difficulty
                    };

                    // Display player data
                    document.getElementById('continuePlayerName').textContent = data.name;
                    document.getElementById('continueLevel').textContent = data.level;
                    document.getElementById('continueScore').textContent = data.score.toLocaleString();
                    const diffEl = document.getElementById('continueDifficulty');
                    diffEl.textContent = data.difficulty;
                    diffEl.style.color = DIFFICULTIES[data.difficulty.toLowerCase()]?.color || '#fff';

                    // Show data section, hide key section
                    document.getElementById('continueKeySection').style.display = 'none';
                    document.getElementById('continueDataSection').style.display = 'block';
                } else {
                    errorEl.textContent = data.error || 'Invalid key. Please check and try again.';
                    errorEl.style.display = 'block';
                }
            } catch (e) {
                errorEl.textContent = 'Network error. Please try again.';
                errorEl.style.display = 'block';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Validate Key';
            }
        }

        async function startContinuedGame() {
            if (!continueGameData) return;

            // Disable button to prevent double-clicks
            const btn = document.getElementById('startContinueBtn');
            if (btn.disabled) return;
            btn.disabled = true;
            btn.textContent = 'Loading...';

            if (audioContext.state === 'suspended') await audioContext.resume();
            closeContinueModal();
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('lobbySidebar').style.display = 'none';

            // Set player data from continue
            myPlayerName = continueGameData.name;
            selectedDifficulty = continueGameData.difficulty.toLowerCase();
            const diff = getDiffSettings();

            score = continueGameData.score;
            level = continueGameData.level;
            lives = diff.lives;

            // Mark previous bosses as defeated
            bossDefeated = [];
            for (let i = 1; i < level; i++) {
                bossDefeated.push(i);
            }

            totalEnemiesKilled = 0;
            killsThisLevel = 0;
            continuesUsedThisLevel = 0;
            respawnsUsedThisLevel = 0;
            savedLevelScore = score;
            bullets = []; enemies = []; particles = []; powerups = [];
            bombs = []; walls = []; weaponPickups = []; mines = []; electricFences = [];
            horizonBeams = []; magneticMines = []; mirrorDrones = [];
            player.x = logicalWidth / 2; player.y = logicalHeight - 80;
            spawnAccumulator = 0; powerupAccumulator = 0; bombAccumulator = 0;
            wallAccumulator = 0; weaponAccumulator = 0; spaceObjAccumulator = 0; mineAccumulator = 0;
            currentWeapon = 'pistol';
            unlockedWeapons = ['pistol'];
            laserActive = false;
            deactivateShield();
            ghostActive = false;
            lightningFlashAlpha = 0;
            boss = null;
            bossActive = false;
            bossDefeating = false;
            bossTauntTimer = 0;
            bossLowHealthReported = false;
            stopBossMusic();
            document.getElementById('bossHealthContainer').classList.remove('show');
            document.getElementById('bossTaunt').classList.remove('show');
            initBackground();
            gameStartTime = Date.now();
            gameDuration = 0;

            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('levelDisplay').textContent = level <= 5 ? 'Level ' + level : 'FINAL LEVEL';
            document.getElementById('difficultyDisplay').textContent = diff.name;
            document.getElementById('difficultyDisplay').style.color = diff.color;
            updateWeaponDisplay();

            gameRunning = true;
            gamePaused = false;
            lastFrameTime = performance.now();
            playGameStart();
            startBackgroundMusic(false);
            if (isMobile) {
                document.getElementById('touchControls').classList.add('show');
            }

            // Run network calls in parallel (non-blocking for game start)
            Promise.all([
                leaveAsPlayer().catch(() => {}),
                joinAsPlayer().catch(() => {}),
                startGameSession().catch(() => {})
            ]).then(() => {
                reportAction('continued_game', { level, score });
            });

            document.getElementById('onlinePlayersBar').classList.add('show');
            startPlayerPolling();
            updatePlayerStatus('playing');

            // Reset button state
            btn.disabled = false;
            btn.textContent = 'Continue Game';
        }

        function openInstructionsModal() {
            document.getElementById('instructionsModal').classList.add('show');
        }

        function closeInstructionsModal() {
            document.getElementById('instructionsModal').classList.remove('show');
        }

        // === RESPAWN MODAL FUNCTIONS ===
        function showRespawnModal() {
            // Update display
            document.getElementById('respawnLevel').textContent = level;
            document.getElementById('respawnScore').textContent = score.toLocaleString();

            // Hide all sections first
            document.getElementById('freeRespawnSection').style.display = 'none';
            document.getElementById('emailSection').style.display = 'none';
            document.getElementById('keyReceivedSection').style.display = 'none';
            document.getElementById('returningPlayerSection').style.display = 'none';
            document.getElementById('tokenRespawnSection')?.remove(); // Remove if exists

            if (isAuthenticated && currentPlayer) {
                // === AUTHENTICATED PLAYER FLOW ===
                const continuesThisLevel = currentPlayer.continuesThisLevel || 0;
                const tokens = currentPlayer.tokens || 0;

                // Update lives indicators - show continues used
                const livesContainer = document.getElementById('respawnLives');
                let livesHtml = '';
                for (let i = 0; i < MAX_CONTINUES_PER_LEVEL; i++) {
                    const used = i < continuesThisLevel;
                    livesHtml += `<div class="life ${used ? 'used' : ''}"></div>`;
                }
                livesContainer.innerHTML = livesHtml;

                // Create token respawn section
                const tokenSection = document.createElement('div');
                tokenSection.id = 'tokenRespawnSection';
                tokenSection.style.marginTop = '15px';

                if (tokens <= 0) {
                    // No tokens left
                    document.getElementById('respawnMessage').textContent = 'Out of tokens!';
                    tokenSection.innerHTML = `
                        <p class="respawn-info" style="color: #ff6b6b;">You have no tokens remaining.</p>
                        <button class="btn-respawn" onclick="hideRespawnModal(); gameOver();">Game Over</button>
                    `;
                } else if (continuesThisLevel >= MAX_CONTINUES_PER_LEVEL) {
                    // Max continues used on this level - restart at level beginning
                    document.getElementById('respawnMessage').textContent = 'Max continues reached for this level';
                    tokenSection.innerHTML = `
                        <p class="respawn-info">You've used ${MAX_CONTINUES_PER_LEVEL} continues on this level.</p>
                        <p class="respawn-info" style="color: #4ade80;">You have <strong>${tokens}</strong> tokens</p>
                        <button class="btn-respawn" onclick="restartLevelWithToken()">Restart Level (1 token)</button>
                    `;
                } else {
                    // Can continue at current position
                    const remaining = MAX_CONTINUES_PER_LEVEL - continuesThisLevel;
                    document.getElementById('respawnMessage').textContent = `${remaining} continues left for this level`;
                    tokenSection.innerHTML = `
                        <p class="respawn-info" style="color: #4ade80;">You have <strong>${tokens}</strong> tokens</p>
                        <button class="btn-respawn" onclick="continueWithToken()">Continue (1 token)</button>
                    `;
                }

                // Insert token section after respawn message
                document.getElementById('respawnMessage').after(tokenSection);
            } else {
                // === UNAUTHENTICATED PLAYER FLOW ===
                const remaining = FREE_CONTINUES - freeUsedContinues;

                // Update lives indicators
                const livesContainer = document.getElementById('respawnLives');
                let livesHtml = '';
                for (let i = 0; i < FREE_CONTINUES; i++) {
                    const used = i < freeUsedContinues;
                    livesHtml += `<div class="life ${used ? 'used' : ''}"></div>`;
                }
                livesContainer.innerHTML = livesHtml;

                if (freeUsedContinues >= FREE_CONTINUES) {
                    // Used all free continues - prompt for registration
                    document.getElementById('respawnMessage').textContent = 'Create an account to continue!';
                    hideRespawnModal();
                    showRegisterModal(true); // true = from death
                    return;
                } else {
                    // Has free continues remaining
                    document.getElementById('respawnMessage').textContent = `${remaining} free continues remaining`;
                    document.getElementById('respawnsRemaining').textContent = remaining;
                    document.getElementById('freeRespawnSection').style.display = 'block';
                }
            }

            document.getElementById('respawnModal').classList.add('show');
        }

        // Continue with token (respawn at current position)
        async function continueWithToken() {
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Using token...';

            const success = await useTokenForContinue();
            if (success) {
                hideRespawnModal();
                respawnPlayer();
                showNotification(`Token used! ${currentPlayer.tokens} remaining`);
            } else {
                showNotification('Failed to use token');
                btn.disabled = false;
                btn.textContent = 'Continue (1 token)';
            }
        }

        // Restart level with token (after 3 continues)
        async function restartLevelWithToken() {
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Using token...';

            const success = await useTokenForContinue();
            if (success) {
                // Reset continues for fresh start
                await resetLevelContinues();
                hideRespawnModal();
                restartAtLevelBeginning();
                showNotification(`Restarting Level ${level}. ${currentPlayer.tokens} tokens remaining`);
            } else {
                showNotification('Failed to use token');
                btn.disabled = false;
                btn.textContent = 'Restart Level (1 token)';
            }
        }

        // Handle free respawn for unauthenticated users
        function doFreeRespawn() {
            freeUsedContinues++;
            hideRespawnModal();
            respawnPlayer();
            const remaining = FREE_CONTINUES - freeUsedContinues;
            if (remaining > 0) {
                showNotification(`${remaining} free continues left`);
            }
        }

        // Handle registration cancel (user chose not to create account)
        function handleRegisterCancel() {
            // Reset free continues
            freeUsedContinues = 0;

            // Full game state reset (like startGame but without going to start screen)
            const diff = getDiffSettings();
            score = 0;
            level = 1;
            lives = diff.lives;
            totalEnemiesKilled = 0;
            playerHitFlash = 0;
            playerBombs = 3;
            lastPlayerBombTime = 0;
            killsThisLevel = 0;
            continuesUsedThisLevel = 0;
            respawnsUsedThisLevel = 0;
            savedLevelScore = 0;

            // Clear all game objects
            bullets = []; enemies = []; particles = []; powerups = [];
            bombs = []; walls = []; weaponPickups = []; mines = []; electricFences = [];
            horizonBeams = []; magneticMines = []; mirrorDrones = [];

            // Reset player position
            player.x = logicalWidth / 2;
            player.y = logicalHeight - 80;

            // Reset spawn accumulators
            spawnAccumulator = 0; powerupAccumulator = 0; bombAccumulator = 0;
            wallAccumulator = 0; weaponAccumulator = 0; spaceObjAccumulator = 0; mineAccumulator = 0;

            // Reset weapons to default
            currentWeapon = 'pistol';
            unlockedWeapons = ['pistol'];
            laserActive = false;
            laserAmmoTimer = 0;
            weaponAmmo = {
                pistol: Infinity,
                machinegun: 0,
                bazooka: 0,
                laser: 0,
                flak: 0,
                disc: 0,
                swarm: 0
            };

            // Reset powerups
            deactivateShield();
            ghostActive = false;
            lightningFlashAlpha = 0;

            // Reset boss state
            boss = null;
            bossActive = false;
            bossDefeating = false;
            bossDefeated = [];
            bossTauntTimer = 0;
            bossLowHealthReported = false;
            stopBossMusic();
            document.getElementById('bossHealthContainer').classList.remove('show');
            document.getElementById('bossTaunt').classList.remove('show');

            // Reset background
            initBackground();

            // Reset game timer
            gameStartTime = Date.now();
            gameDuration = 0;

            // Update UI
            document.getElementById('score').textContent = score;
            document.getElementById('levelDisplay').textContent = 'Level 1';
            document.getElementById('lives').textContent = lives;

            // Ensure game is running
            gameRunning = true;
            gamePaused = false;
            lastFrameTime = performance.now();
            startBackgroundMusic(false);

            showNotification('Starting new game from Level 1');
        }

        // Continue saved game (for authenticated users from home screen)
        function continueSavedGame() {
            if (!isAuthenticated || !currentPlayer) {
                showLoginModal();
                return;
            }

            if (currentPlayer.savedLevel <= 1) {
                showNotification('No saved game found');
                return;
            }

            // Set up game with saved progress
            myPlayerName = currentPlayer.username;
            selectedDifficulty = (currentPlayer.savedDifficulty || 'EASY').toLowerCase();
            level = currentPlayer.savedLevel || 1;
            score = currentPlayer.savedScore || 0;
            continuesUsedThisLevel = currentPlayer.continuesThisLevel || 0;
            savedLevelScore = score;

            // Start the game
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('lobbySidebar').style.display = 'none';
            initGame();
            showNotification(`Continuing from Level ${level}`);
        }

        // Reset game to Level 1
        function resetGame() {
            level = 1;
            score = 0;
            savedLevelScore = 0;
            continuesUsedThisLevel = 0;
            freeUsedContinues = 0;
            backToMenu();
        }

        function hideRespawnModal() {
            document.getElementById('respawnModal').classList.remove('show');
        }

        async function autoContinueWithKey() {
            // Use stored continue key to auto-continue
            continuesUsedThisLevel++;

            // Check if we've exceeded max continues
            if (continuesUsedThisLevel >= MAX_CONTINUES_PER_LEVEL) {
                // Restart at beginning of current level
                restartAtLevelBeginning();
                return;
            }

            // Validate key and continue
            try {
                const response = await fetch(`${API_BASE}/api/player/validate-key`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ key: currentContinueKey })
                });
                const data = await response.json();

                if (data.valid) {
                    respawnPlayer();
                } else {
                    // Key invalid or exhausted - clear it and show modal
                    clearStoredContinueKey();
                    continuesUsedThisLevel--; // Undo increment
                    showRespawnModal();
                }
            } catch (e) {
                // Network error - still respawn but don't consume key
                continuesUsedThisLevel--;
                respawnPlayer();
            }
        }

        function restartAtLevelBeginning() {
            // Reset continues for fresh start at this level
            continuesUsedThisLevel = 0;
            killsThisLevel = 0;
            score = savedLevelScore; // Restore score to level start
            document.getElementById('score').textContent = score;

            // Respawn player
            hideRespawnModal();
            respawnPlayer();

            // Show notification
            showNotification(`Restarting Level ${level}`);
        }

        function showNotification(msg) {
            // Quick notification overlay
            const notif = document.createElement('div');
            notif.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:#ffd700;padding:20px 40px;border-radius:10px;font-size:24px;z-index:9999;';
            notif.textContent = msg;
            document.body.appendChild(notif);
            setTimeout(() => notif.remove(), 2000);
        }

        async function doRespawn() {
            // Legacy function - now just calls respawnPlayer
            hideRespawnModal();
            respawnPlayer();
        }

        function respawnPlayer() {
            // Reset player position
            player.x = logicalWidth / 2;
            player.y = logicalHeight - 80;

            // Reset lives
            const diff = getDiffSettings();
            lives = diff.lives;

            // Clear hazards but keep score and level
            bullets = [];
            enemies = [];
            mines = [];
            walls = [];

            // Reset weapon to pistol
            currentWeapon = 'pistol';
            laserActive = false;
            deactivateShield();
            ghostActive = false;
            lightningFlashAlpha = 0;

            // Update display
            document.getElementById('lives').textContent = lives;

            // Resume game
            gameRunning = true;
            gamePaused = false;
            lastFrameTime = performance.now();
            startBackgroundMusic(bossActive);

            // Report respawn action
            reportAction('respawned');
        }

        async function requestContinueKey() {
            const email = document.getElementById('respawnEmail').value.trim();
            if (!email || !email.includes('@')) {
                document.getElementById('emailError').textContent = 'Please enter a valid email';
                document.getElementById('emailError').style.display = 'block';
                return;
            }

            document.getElementById('sendKeyBtn').disabled = true;
            document.getElementById('sendKeyBtn').textContent = 'Getting Key...';
            document.getElementById('emailError').style.display = 'none';

            try {
                const response = await fetch(`${API_BASE}/api/player/request-key`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: myPlayerName,
                        email: email,
                        level: level,
                        score: score,
                        difficulty: selectedDifficulty.toUpperCase()
                    })
                });

                const data = await response.json();

                if (data.success && data.key) {
                    // Display the key on screen and pre-populate the input
                    document.getElementById('emailSection').style.display = 'none';
                    document.getElementById('keyReceivedSection').style.display = 'block';
                    document.getElementById('displayedKey').textContent = data.key;
                    document.getElementById('respawnKeyInput').value = data.key;
                    document.getElementById('respawnMessage').textContent = 'Your continue key (also sent to email):';

                    // Store in sessionStorage (cleared when browser session ends)
                    sessionStorage.setItem('continueKey', data.key);
                    sessionStorage.setItem('continueKeyPlayer', myPlayerName);
                } else {
                    document.getElementById('emailError').textContent = data.error || 'Failed to get key';
                    document.getElementById('emailError').style.display = 'block';
                }
            } catch (e) {
                document.getElementById('emailError').textContent = 'Network error. Please try again.';
                document.getElementById('emailError').style.display = 'block';
                console.error('Request key error:', e);
            }

            document.getElementById('sendKeyBtn').disabled = false;
            document.getElementById('sendKeyBtn').textContent = 'Get Key';
        }

        async function validateAndContinue() {
            // Get key from input or from sessionStorage
            let key = document.getElementById('respawnKeyInput').value.trim().toUpperCase();
            if (!key) {
                key = sessionStorage.getItem('continueKey');
            }
            if (!key) {
                alert('Please enter a continue key.');
                return;
            }

            // Accept both old 6-char keys and new 12-char keys
            if (!key.match(/^FJ-[A-Z0-9]{6,12}$/)) {
                alert('Invalid key format. Keys should be like FJ-XXXXXXXXX');
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/player/validate-key`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: myPlayerName, key: key })
                });

                const data = await response.json();

                if (data.valid) {
                    // Store key for future auto-continues (in sessionStorage)
                    sessionStorage.setItem('continueKey', key);
                    sessionStorage.setItem('continueKeyPlayer', myPlayerName);
                    continuesUsedThisLevel++;

                    // Respawn
                    hideRespawnModal();
                    respawnPlayer();
                } else {
                    alert(data.error || 'Invalid key. Please check and try again.');
                }
            } catch (e) {
                alert('Network error. Please try again.');
                console.error('Validate key error:', e);
            }
        }

        async function validateReturningPlayer() {
            const key = document.getElementById('returningKeyInput').value.trim().toUpperCase();
            const errorEl = document.getElementById('keyError');

            if (!key) {
                errorEl.textContent = 'Please enter your key';
                errorEl.style.display = 'block';
                return;
            }

            // Accept both old 6-char keys and new 9-char keys
            if (!key.match(/^FJ-[A-Z0-9]{6,9}$/)) {
                errorEl.textContent = 'Invalid key format. Keys should be like FJ-XXXXXXXXX';
                errorEl.style.display = 'block';
                return;
            }

            errorEl.style.display = 'none';

            try {
                const response = await fetch(`${API_BASE}/api/player/validate-key`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: myPlayerName, key: key })
                });

                const data = await response.json();

                if (data.valid) {
                    // Restore progress
                    level = data.level;
                    score = data.score;
                    respawnsUsedThisLevel = 0;
                    playerHasKey = true;

                    // Update UI
                    document.getElementById('score').textContent = score;
                    document.getElementById('levelDisplay').textContent = `Level ${level}`;

                    // Start game
                    hideRespawnModal();
                    respawnPlayer();
                } else {
                    errorEl.textContent = data.error || 'Invalid key';
                    errorEl.style.display = 'block';
                }
            } catch (e) {
                errorEl.textContent = 'Network error. Please try again.';
                errorEl.style.display = 'block';
            }
        }

        function handlePlayerDeath(deathReason = 'unknown') {
            // COOP MODE: Use relay respawn system
            if (isMultiplayer && selectedGameMode === 'coop') {
                handleCoopDeath(deathReason);
                return;
            }

            // SOLO MODE: Original behavior
            // Pause the game but don't end it yet
            gameRunning = false;
            gamePaused = true;
            lastDeathReason = deathReason;
            stopBackgroundMusic();
            stopBossMusic();

            // Show the respawn modal
            showRespawnModal();
        }

        // Coop death handling - relay system
        function handleCoopDeath(deathReason) {
            // Decrement respawns
            coopState.myRespawnsLeft--;
            coopState.amActive = false;

            // Broadcast death to partner
            broadcastDeath(deathReason);

            // Check if permanently out
            if (coopState.myRespawnsLeft < 0) {
                coopState.myRespawnsLeft = 0;
                // Permanently dead - check if partner is also out
                if (!otherPlayer.isActive && otherPlayer.respawnsLeft <= 0) {
                    handleMultiplayerGameOver({ reason: 'All players eliminated' });
                }
                return;
            }

            // Start respawn timer
            coopState.myRespawnStartTime = Date.now();

            // Schedule respawn after 5 seconds
            setTimeout(() => {
                if (!gameRunning) return; // Game might have ended

                // Respawn at bottom center
                player.x = logicalWidth / 2;
                player.y = logicalHeight - 80;
                coopState.amActive = true;

                // Grant temporary invincibility
                coopState.amInvincible = true;
                coopState.invincibleUntil = Date.now() + COOP_INVINCIBILITY_TIME;

                // Restore 1 life
                lives = 1;
                document.getElementById('lives').textContent = lives;

                // Broadcast respawn
                broadcastRespawn();

                // Remove invincibility after time expires
                setTimeout(() => {
                    coopState.amInvincible = false;
                }, COOP_INVINCIBILITY_TIME);

            }, COOP_RESPAWN_TIME);
        }

        function quitFromRespawn() {
            hideRespawnModal();
            // Now actually end the game
            gameOver(lastDeathReason);
        }

        const player = {
            x: logicalWidth / 2, y: logicalHeight - 80,
            width: 50, height: 50, speed: 360, dx: 0, dy: 0
        };

        let bullets = [];
        let enemies = [];
        let particles = [];
        let powerups = [];
        let bombs = [];
        let walls = [];
        let weaponPickups = [];
        let mines = [];

        // Ghost mode state
        let ghostActive = false;
        let ghostStartTime = 0;
        const ghostDuration = 5000;

        const keys = {};
        let touchMove = { x: 0, y: 0 };
        let joystickActive = false;
        let autoFire = false;
        let lastFireTime = 0;

        // === SOUNDS ===
        function playSound(freq, type, duration, gain = 0.3) {
            if (isMuted) return;
            const osc = audioContext.createOscillator();
            const g = audioContext.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioContext.currentTime);
            osc.connect(g);
            g.connect(audioContext.destination);
            g.gain.setValueAtTime(gain, audioContext.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            osc.start();
            osc.stop(audioContext.currentTime + duration);
        }

        function playPlayerLaser() { playSound(800, 'square', 0.1); }
        function playMachineGun() { playSound(200, 'sawtooth', 0.05, 0.2); }
        function playBazooka() { playSound(100, 'sawtooth', 0.3, 0.4); }
        function playLaserBeam() { playSound(1200, 'sine', 0.05, 0.15); }
        function playEnemyLaser() { playSound(300, 'sawtooth', 0.15, 0.2); }
        function playEnemyMachineGun() { playSound(250, 'square', 0.08, 0.15); }
        function playEnemyBazooka() { playSound(80, 'sawtooth', 0.25, 0.3); }
        function playExplosion() {
            if (isMuted) return;
            const bufferSize = audioContext.sampleRate * 0.3;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.2));
            const source = audioContext.createBufferSource();
            const g = audioContext.createGain();
            source.buffer = buffer;
            source.connect(g);
            g.connect(audioContext.destination);
            g.gain.setValueAtTime(0.3, audioContext.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            source.start();
        }
        function playBigExplosion() {
            if (isMuted) return;
            const bufferSize = audioContext.sampleRate * 0.6;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.3));
            const source = audioContext.createBufferSource();
            const g = audioContext.createGain();
            source.buffer = buffer;
            source.connect(g);
            g.connect(audioContext.destination);
            g.gain.setValueAtTime(0.5, audioContext.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
            source.start();
        }
        function playGameStart() {
            [262, 330, 392, 523].forEach((freq, i) => setTimeout(() => playSound(freq, 'square', 0.2), i * 100));
        }
        function playGameOver() {
            [440, 392, 349, 294].forEach((freq, i) => setTimeout(() => playSound(freq, 'sine', 0.3, 0.15), i * 150));
        }
        function playPowerupCollect() {
            [523, 659, 784].forEach((freq, i) => setTimeout(() => playSound(freq, 'sine', 0.15), i * 50));
        }
        function playLevelUp() {
            [392, 523, 659, 784].forEach((freq, i) => setTimeout(() => playSound(freq, 'square', 0.15, 0.25), i * 80));
        }
        function playOuchSound() {
            if (isMuted) return;
            // Descending "ouch" sound - sawtooth wave dropping from 200 to 100 Hz
            const osc = audioContext.createOscillator();
            const g = audioContext.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, audioContext.currentTime);
            osc.frequency.linearRampToValueAtTime(100, audioContext.currentTime + 0.15);
            osc.connect(g);
            g.connect(audioContext.destination);
            g.gain.setValueAtTime(0.35, audioContext.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            osc.start();
            osc.stop(audioContext.currentTime + 0.15);
        }
        function playFlakSound() {
            if (isMuted) return;
            // Shotgun-like boom with noise burst
            const bufferSize = audioContext.sampleRate * 0.1;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.15));
            const source = audioContext.createBufferSource();
            const g = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 800;
            source.buffer = buffer;
            source.connect(filter);
            filter.connect(g);
            g.connect(audioContext.destination);
            g.gain.setValueAtTime(0.4, audioContext.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            source.start();
        }
        function playDiscSound() {
            // High-pitched disc launch sound
            [1200, 800, 1000].forEach((freq, i) => setTimeout(() => playSound(freq, 'sine', 0.08, 0.2), i * 20));
        }
        function playDiscBounceSound() {
            playSound(1200, 'sine', 0.05, 0.25);
        }
        function playSwarmSound() {
            // Rising tone for swarm missile launch
            if (isMuted) return;
            const osc = audioContext.createOscillator();
            const g = audioContext.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(400, audioContext.currentTime);
            osc.frequency.linearRampToValueAtTime(800, audioContext.currentTime + 0.3);
            osc.connect(g);
            g.connect(audioContext.destination);
            g.gain.setValueAtTime(0.2, audioContext.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            osc.start();
            osc.stop(audioContext.currentTime + 0.3);
        }

        // === BOSS EVIL LAUGHS ===
        function playBossLaugh(laughType) {
            if (isMuted) return;
            switch(laughType) {
                case 'dark':
                    // Dark Phantom: Low menacing chuckle
                    [120, 100, 80, 100, 120, 80].forEach((freq, i) =>
                        setTimeout(() => playSound(freq, 'sawtooth', 0.15, 0.3), i * 100));
                    break;
                case 'gurgle':
                    // Cyber Kraken: Bubbling gurgle laugh
                    for (let i = 0; i < 8; i++) {
                        setTimeout(() => playSound(150 + Math.random() * 100, 'sine', 0.1, 0.25), i * 80);
                    }
                    break;
                case 'roar':
                    // Inferno Titan: Deep fiery roar laugh
                    [60, 80, 60, 100, 60, 80, 120].forEach((freq, i) =>
                        setTimeout(() => playSound(freq, 'sawtooth', 0.2, 0.4), i * 120));
                    break;
                case 'glitch':
                    // Quantum Destroyer: Glitchy distorted laugh
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => playSound(200 + Math.random() * 800, 'square', 0.05, 0.2), i * 50);
                    }
                    break;
                case 'boom':
                    // Omega Overlord: Booming godlike laugh
                    [80, 100, 120, 100, 80, 60, 80, 100, 120].forEach((freq, i) =>
                        setTimeout(() => playSound(freq, 'triangle', 0.25, 0.35), i * 110));
                    break;
                case 'demonic':
                    // Legion Supreme: Demonic multi-layered laugh
                    [50, 100, 150].forEach(baseFreq => {
                        [1, 1.2, 0.8, 1.1, 0.9, 1.3, 0.7, 1].forEach((mult, i) =>
                            setTimeout(() => playSound(baseFreq * mult, 'sawtooth', 0.15, 0.2), i * 90));
                    });
                    break;
            }
        }

        function playGhostActivate() {
            [800, 600, 400, 300].forEach((freq, i) => setTimeout(() => playSound(freq, 'sine', 0.2, 0.15), i * 80));
        }

        function playLifeUp() {
            [523, 659, 784, 1047].forEach((freq, i) => setTimeout(() => playSound(freq, 'square', 0.15, 0.3), i * 60));
        }

        function playMineExplosion() {
            if (isMuted) return;
            const bufferSize = audioContext.sampleRate * 0.4;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.15));
            const source = audioContext.createBufferSource();
            const g = audioContext.createGain();
            source.buffer = buffer;
            source.connect(g);
            g.connect(audioContext.destination);
            g.gain.setValueAtTime(0.4, audioContext.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
            source.start();
        }

        // === MUSIC ===
        async function startBackgroundMusic(powerMode = false) {
            if (isMuted) return;
            stopBackgroundMusic();
            if (audioContext.state === 'suspended') await audioContext.resume();
            backgroundMusic = { active: true, intervalId: null };

            const bassNotes = powerMode ? [165, 165, 220, 165, 196, 165, 220, 262] : [110, 110, 165, 110, 147, 110, 165, 196];
            const leadNotes = powerMode ? [659, 784, 880, 988, 880, 784] : [440, 494, 523, 587, 523, 494];
            const tempo = powerMode ? 120 : 200;
            let beatCount = 0;

            function playBeat() {
                if (!backgroundMusic || !backgroundMusic.active) return;
                const now = audioContext.currentTime;
                const bass = audioContext.createOscillator();
                const bassGain = audioContext.createGain();
                bass.type = powerMode ? 'square' : 'sawtooth';
                bass.frequency.value = bassNotes[beatCount % bassNotes.length];
                bass.connect(bassGain);
                bassGain.connect(audioContext.destination);
                bassGain.gain.setValueAtTime(powerMode ? 0.25 : 0.2, now);
                bassGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                bass.start(now);
                bass.stop(now + 0.1);

                if (beatCount % 2 === 0) {
                    const lead = audioContext.createOscillator();
                    const leadGain = audioContext.createGain();
                    lead.type = powerMode ? 'sawtooth' : 'square';
                    lead.frequency.value = leadNotes[(beatCount / 2) % leadNotes.length];
                    lead.connect(leadGain);
                    leadGain.connect(audioContext.destination);
                    leadGain.gain.setValueAtTime(powerMode ? 0.12 : 0.08, now);
                    leadGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    lead.start(now);
                    lead.stop(now + 0.15);
                }
                beatCount++;
            }
            playBeat();
            backgroundMusic.intervalId = setInterval(playBeat, tempo);
        }

        function stopBackgroundMusic() {
            if (backgroundMusic) {
                backgroundMusic.active = false;
                if (backgroundMusic.intervalId) clearInterval(backgroundMusic.intervalId);
                backgroundMusic = null;
            }
        }

        function toggleMute() {
            isMuted = !isMuted;
            const btn = document.getElementById('muteButton');
            if (isMuted) { btn.textContent = 'üîá'; btn.classList.add('muted'); stopBackgroundMusic(); stopBossMusic(); }
            else { btn.textContent = 'üîä'; btn.classList.remove('muted'); if (gameRunning) { if (bossActive) startBossMusic(); else startBackgroundMusic(shieldActive); } }
        }

        // === BOSS MUSIC ===
        function startBossMusic() {
            if (isMuted) return;
            stopBackgroundMusic();
            stopBossMusic();
            bossMusic = { active: true, intervalId: null };
            const bassNotes = [82, 82, 98, 82, 110, 82, 98, 130];
            const leadNotes = [330, 392, 440, 392, 523, 440];
            let beatCount = 0;

            function playBossBeat() {
                if (!bossMusic || !bossMusic.active) return;
                const now = audioContext.currentTime;
                // Heavy bass drum
                const bass = audioContext.createOscillator();
                const bassGain = audioContext.createGain();
                bass.type = 'sawtooth';
                bass.frequency.value = bassNotes[beatCount % bassNotes.length];
                bass.connect(bassGain);
                bassGain.connect(audioContext.destination);
                bassGain.gain.setValueAtTime(0.35, now);
                bassGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                bass.start(now);
                bass.stop(now + 0.12);

                // Aggressive lead
                if (beatCount % 2 === 0) {
                    const lead = audioContext.createOscillator();
                    const leadGain = audioContext.createGain();
                    lead.type = 'square';
                    lead.frequency.value = leadNotes[(beatCount / 2) % leadNotes.length];
                    lead.connect(leadGain);
                    leadGain.connect(audioContext.destination);
                    leadGain.gain.setValueAtTime(0.15, now);
                    leadGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    lead.start(now);
                    lead.stop(now + 0.1);
                }
                // Tension synth
                if (beatCount % 4 === 0) {
                    const synth = audioContext.createOscillator();
                    const synthGain = audioContext.createGain();
                    synth.type = 'sine';
                    synth.frequency.value = 220 + Math.sin(beatCount * 0.5) * 50;
                    synth.connect(synthGain);
                    synthGain.connect(audioContext.destination);
                    synthGain.gain.setValueAtTime(0.1, now);
                    synthGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    synth.start(now);
                    synth.stop(now + 0.3);
                }
                beatCount++;
            }
            playBossBeat();
            bossMusic.intervalId = setInterval(playBossBeat, 100);
        }

        function stopBossMusic() {
            if (bossMusic) {
                bossMusic.active = false;
                if (bossMusic.intervalId) clearInterval(bossMusic.intervalId);
                bossMusic = null;
            }
        }

        function playBossDefeat() {
            if (isMuted) return;
            // Epic victory fanfare
            [262, 330, 392, 523, 659, 784].forEach((freq, i) => {
                setTimeout(() => playSound(freq, 'square', 0.3, 0.3), i * 100);
            });
        }

        function playVictoryMusic() {
            if (isMuted) return;
            // Epic victory theme - triumphant melody
            const melody = [
                { freq: 523, delay: 0 },    // C5
                { freq: 659, delay: 200 },  // E5
                { freq: 784, delay: 400 },  // G5
                { freq: 1047, delay: 600 }, // C6
                { freq: 784, delay: 900 },  // G5
                { freq: 1047, delay: 1100 }, // C6
                { freq: 1319, delay: 1400 }, // E6
                { freq: 1568, delay: 1700 }, // G6
            ];
            melody.forEach(note => {
                setTimeout(() => playSound(note.freq, 'square', 0.4, 0.5), note.delay);
            });
            // Repeat with harmony
            setTimeout(() => {
                melody.forEach(note => {
                    setTimeout(() => playSound(note.freq * 1.25, 'sine', 0.2, 0.4), note.delay);
                });
            }, 2000);
        }

        // === CONFETTI ANIMATION ===
        let confettiParticles = [];
        let confettiAnimationId = null;

        function startConfetti() {
            const canvas = document.getElementById('confettiCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const colors = ['#ffd700', '#ff6b6b', '#4ade80', '#60a5fa', '#f472b6', '#fbbf24', '#a78bfa'];

            // Create confetti particles
            for (let i = 0; i < 150; i++) {
                confettiParticles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height - canvas.height,
                    size: Math.random() * 10 + 5,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    speedY: Math.random() * 3 + 2,
                    speedX: (Math.random() - 0.5) * 4,
                    rotation: Math.random() * 360,
                    rotationSpeed: (Math.random() - 0.5) * 10
                });
            }

            function animateConfetti() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                confettiParticles.forEach(p => {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation * Math.PI / 180);
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.6);
                    ctx.restore();

                    p.y += p.speedY;
                    p.x += p.speedX;
                    p.rotation += p.rotationSpeed;

                    // Reset when off screen
                    if (p.y > canvas.height) {
                        p.y = -20;
                        p.x = Math.random() * canvas.width;
                    }
                });

                confettiAnimationId = requestAnimationFrame(animateConfetti);
            }

            animateConfetti();
        }

        function stopConfetti() {
            if (confettiAnimationId) {
                cancelAnimationFrame(confettiAnimationId);
                confettiAnimationId = null;
            }
            confettiParticles = [];
            const canvas = document.getElementById('confettiCanvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        // === VICTORY SCREEN ===
        function showVictoryScreen() {
            gameRunning = false;
            stopBackgroundMusic();
            stopBossMusic();

            // End server game session with victory flag
            endServerGameSession('victory', true);

            // Update stats
            document.getElementById('victoryScore').textContent = score.toLocaleString();
            document.getElementById('victoryTime').textContent = formatDuration(gameDuration);
            document.getElementById('victoryEnemies').textContent = totalEnemiesKilled.toLocaleString();
            document.getElementById('victoryBosses').textContent = bossDefeated.length;

            // Build boss gallery
            const gallery = document.getElementById('bossGallery');
            gallery.innerHTML = '';
            const bossIcons = ['üëª', 'üêô', 'üî•', '‚ö°', 'üëë', 'üíÄ'];
            for (let i = 1; i <= 6; i++) {
                const bossData = BOSSES[i];
                const isDefeated = bossDefeated.includes(i);
                const card = document.createElement('div');
                card.className = 'boss-card' + (isDefeated ? ' defeated' : '');
                card.innerHTML = `
                    <div class="boss-icon">${bossIcons[i-1]}</div>
                    <div class="boss-name" style="color: ${bossData.color}">${bossData.name}</div>
                `;
                gallery.appendChild(card);
            }

            // Show screen
            document.getElementById('victoryScreen').classList.add('show');

            // Start effects
            playVictoryMusic();
            startConfetti();

            // Save victory to server
            reportAction('victory', {
                score,
                gameDuration,
                enemiesKilled: totalEnemiesKilled,
                bossesDefeated: bossDefeated.length
            });
        }

        async function saveVictoryEmail() {
            const emailInput = document.getElementById('victoryEmail');
            const email = emailInput.value.trim();
            if (!email || !email.includes('@')) {
                alert('Please enter a valid email address');
                return;
            }

            try {
                await fetch(`${API_BASE}/api/victory/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        email,
                        playerName: myPlayerName,
                        score,
                        gameDuration,
                        enemiesKilled: totalEnemiesKilled,
                        difficulty: selectedDifficulty
                    })
                });
                document.getElementById('emailSavedMsg').style.display = 'block';
                emailInput.disabled = true;
            } catch (e) {
                console.error('Failed to save victory email:', e);
            }
        }

        function closeVictoryScreen() {
            stopConfetti();
            document.getElementById('victoryScreen').classList.remove('show');
            document.getElementById('emailSavedMsg').style.display = 'none';
            document.getElementById('victoryEmail').disabled = false;
            document.getElementById('victoryEmail').value = '';
            backToMenu();
        }

        // === BOSS FUNCTIONS ===
        function spawnBoss(levelNum) {
            const bossData = BOSSES[levelNum];
            if (!bossData) return;

            // Reset boss defeating flag
            bossDefeating = false;

            // Clear enemies and mines but keep powerups/weapons
            enemies = [];
            mines = [];

            const diff = getDiffSettings();
            boss = {
                ...bossData,
                x: logicalWidth / 2,
                y: -bossData.height,
                targetY: 100,
                health: Math.floor(bossData.health * (1 + (diff.speedMult - 1) * 0.5)),
                maxHealth: Math.floor(bossData.maxHealth * (1 + (diff.speedMult - 1) * 0.5)),
                shootTimer: 1,
                moveTimer: 0,
                moveDirX: 1,
                moveDirY: 0,
                phase: 0,
                entering: true,
                tauntIndex: 0,
                laughTimer: 0
            };
            bossActive = true;

            // Show boss UI
            document.getElementById('bossHealthContainer').classList.add('show');
            document.getElementById('bossName').textContent = bossData.name;
            updateBossHealthBar();

            // Start boss music and play evil laugh
            startBossMusic();
            playBossLaugh(bossData.laughType);

            // Initial taunt
            setTimeout(() => showBossTaunt(), 1000);

            // Report action
            reportAction('fighting_boss', { bossName: bossData.name, level: levelNum });
        }

        function updateBossHealthBar() {
            if (!boss) return;
            const percent = (boss.health / boss.maxHealth) * 100;
            document.getElementById('bossHealthFill').style.width = percent + '%';
        }

        function showBossTaunt() {
            if (!boss || !bossActive) return;
            const taunt = boss.taunts[boss.tauntIndex % boss.taunts.length];
            boss.tauntIndex++;
            const tauntEl = document.getElementById('bossTaunt');
            tauntEl.textContent = '"' + taunt + '"';
            tauntEl.classList.add('show');
            // Play evil laugh with taunt
            playBossLaugh(boss.laughType);
            setTimeout(() => tauntEl.classList.remove('show'), 2500);
        }

        function bossAttack() {
            if (!boss) return;
            const diff = getDiffSettings();
            const bulletSpeedY = 5 * diff.speedMult; // Positive = downward (toward player)

            switch (boss.attackPattern) {
                case 'spread':
                    // 5 bullets in a spread
                    for (let i = -2; i <= 2; i++) {
                        bullets.push({
                            x: boss.x + i * 20, y: boss.y + boss.height / 2,
                            vx: i * 0.8, vy: bulletSpeedY, isEnemy: true, type: 'boss', width: 12, height: 12
                        });
                    }
                    break;
                case 'spiral':
                    // Spiral pattern
                    for (let i = 0; i < 8; i++) {
                        const angle = (boss.phase + i * 45) * Math.PI / 180;
                        bullets.push({
                            x: boss.x, y: boss.y + boss.height / 2,
                            vx: Math.cos(angle) * 2.5, vy: Math.sin(angle) * 2.5 + bulletSpeedY * 0.6,
                            isEnemy: true, type: 'boss', width: 10, height: 10
                        });
                    }
                    boss.phase += 15;
                    break;
                case 'wave':
                    // Wave of bullets
                    for (let i = 0; i < 10; i++) {
                        bullets.push({
                            x: boss.x - 100 + i * 25, y: boss.y + boss.height / 2,
                            vx: Math.sin(i + boss.phase) * 0.5, vy: bulletSpeedY,
                            isEnemy: true, type: 'boss', width: 8, height: 8
                        });
                    }
                    boss.phase += 0.5;
                    break;
                case 'random':
                    // Random burst
                    for (let i = 0; i < 6; i++) {
                        bullets.push({
                            x: boss.x + (Math.random() - 0.5) * boss.width, y: boss.y + boss.height / 2,
                            vx: (Math.random() - 0.5) * 3, vy: bulletSpeedY * (0.8 + Math.random() * 0.4),
                            isEnemy: true, type: 'boss', width: 10, height: 10
                        });
                    }
                    break;
                case 'all':
                    // Final boss uses all patterns
                    const pattern = Math.floor(boss.phase / 3) % 4;
                    boss.attackPattern = ['spread', 'spiral', 'wave', 'random'][pattern];
                    bossAttack();
                    boss.attackPattern = 'all';
                    boss.phase++;
                    break;
                case 'ultimate':
                    // SUPER BOSS: Combines multiple patterns simultaneously!
                    const phase = boss.phase % 5;
                    // Always fire spread
                    for (let i = -3; i <= 3; i++) {
                        bullets.push({
                            x: boss.x + i * 25, y: boss.y + boss.height / 2,
                            vx: i * 1, vy: bulletSpeedY * 1.2, isEnemy: true, type: 'boss', width: 14, height: 14,
                            color: '#FF0080'
                        });
                    }
                    // Plus rotating spiral
                    for (let i = 0; i < 6; i++) {
                        const angle = (boss.phase * 20 + i * 60) * Math.PI / 180;
                        bullets.push({
                            x: boss.x, y: boss.y + boss.height / 2,
                            vx: Math.cos(angle) * 3.5, vy: Math.sin(angle) * 2 + bulletSpeedY * 0.8,
                            isEnemy: true, type: 'boss', width: 12, height: 12,
                            color: '#00FFFF'
                        });
                    }
                    // Plus random chaos
                    if (phase === 0 || phase === 2) {
                        for (let i = 0; i < 4; i++) {
                            bullets.push({
                                x: boss.x + (Math.random() - 0.5) * boss.width, y: boss.y + boss.height / 2,
                                vx: (Math.random() - 0.5) * 5, vy: bulletSpeedY * (1 + Math.random() * 0.5),
                                isEnemy: true, type: 'boss', width: 10, height: 10, color: '#FFFF00'
                            });
                        }
                    }
                    // New weapons for ultimate boss
                    if (phase === 1) bossSpawnMagneticMines(3);
                    if (phase === 3) bossFireHorizonCleaver();
                    if (phase === 4 && mirrorDrones.length < 3) bossSpawnMirrorDrones(2);
                    boss.phase++;
                    break;
            }

            // Level 4+ bosses randomly use new weapons
            if (level >= 4 && Math.random() < 0.2) {
                const newWeapon = Math.floor(Math.random() * 3);
                if (newWeapon === 0) bossSpawnMagneticMines(2 + Math.floor(level / 2));
                else if (newWeapon === 1) bossFireHorizonCleaver();
                else if (newWeapon === 2 && mirrorDrones.length < 4) bossSpawnMirrorDrones(2);
            }
            playEnemyBazooka();
        }

        // === NEW BOSS WEAPONS ===

        // Horizon Cleaver - Full-width beam with safe gaps
        function bossFireHorizonCleaver() {
            if (!boss) return;
            const beamY = 150 + Math.random() * 300;
            // Create warning first
            horizonBeams.push({
                y: beamY,
                height: 40,
                isWarning: true,
                warningTimer: 0,
                warningDuration: 1000, // 1 sec warning
                isActive: false,
                activeTimer: 0,
                activeDuration: 600, // 0.6 sec active
                gaps: generateBeamGaps(2) // 2 safe zones
            });
            playHorizonCleaverWarning();
        }

        function generateBeamGaps(count) {
            const gaps = [];
            const minGap = 80;
            const maxGap = 120;
            for (let i = 0; i < count; i++) {
                const gapWidth = minGap + Math.random() * (maxGap - minGap);
                gaps.push({
                    x: 80 + Math.random() * (logicalWidth - 160 - gapWidth),
                    width: gapWidth
                });
            }
            return gaps;
        }

        function playHorizonCleaverWarning() {
            if (isMuted) return;
            // Rising warning tone
            const osc = audioContext.createOscillator();
            const g = audioContext.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, audioContext.currentTime);
            osc.frequency.linearRampToValueAtTime(600, audioContext.currentTime + 0.8);
            osc.connect(g);
            g.connect(audioContext.destination);
            g.gain.setValueAtTime(0.15, audioContext.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
            osc.start();
            osc.stop(audioContext.currentTime + 0.8);
        }

        function playHorizonCleaverFire() {
            if (isMuted) return;
            // Deep rumbling beam sound
            const bufferSize = audioContext.sampleRate * 0.5;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.sin(i * 0.01) * Math.exp(-i / (bufferSize * 0.5));
            }
            const source = audioContext.createBufferSource();
            const g = audioContext.createGain();
            source.buffer = buffer;
            source.connect(g);
            g.connect(audioContext.destination);
            g.gain.setValueAtTime(0.3, audioContext.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            source.start();
        }

        // Magnetic Sea Mines - Float down and get attracted to player
        function bossSpawnMagneticMines(count) {
            if (!boss) return;
            for (let i = 0; i < count; i++) {
                magneticMines.push({
                    x: boss.x + (Math.random() - 0.5) * boss.width,
                    y: boss.y + boss.height / 2,
                    vx: (Math.random() - 0.5) * 50,
                    vy: 40 + Math.random() * 30,
                    width: 25,
                    height: 25,
                    magnetRadius: 150,
                    magnetStrength: 0.15,
                    timer: 0,
                    maxLife: 6000, // 6 seconds
                    explosionRadius: 80,
                    pulsePhase: Math.random() * Math.PI * 2
                });
            }
            playMineSpawn();
        }

        function playMineSpawn() {
            if (isMuted) return;
            [300, 250, 200].forEach((freq, i) => setTimeout(() => playSound(freq, 'sine', 0.1, 0.2), i * 50));
        }

        // Mirror Drone Swarm - Drones that mirror player movement
        function bossSpawnMirrorDrones(count) {
            if (!boss) return;
            for (let i = 0; i < count; i++) {
                mirrorDrones.push({
                    x: boss.x,
                    y: boss.y + 50 + i * 40,
                    width: 30,
                    height: 20,
                    health: 30,
                    mirrorOffset: (i - count / 2 + 0.5) * 120, // Spread out
                    lastShot: 0,
                    fireRate: 1500 + Math.random() * 500
                });
            }
            playDroneSpawn();
        }

        function playDroneSpawn() {
            if (isMuted) return;
            [600, 800, 1000].forEach((freq, i) => setTimeout(() => playSound(freq, 'square', 0.08, 0.15), i * 40));
        }

        // === UPDATE FUNCTIONS FOR NEW BOSS WEAPONS ===

        function updateHorizonBeams(dt) {
            const dtMs = dt * 1000;
            for (let i = horizonBeams.length - 1; i >= 0; i--) {
                const beam = horizonBeams[i];

                if (beam.isWarning) {
                    beam.warningTimer += dtMs;
                    if (beam.warningTimer >= beam.warningDuration) {
                        beam.isWarning = false;
                        beam.isActive = true;
                        playHorizonCleaverFire();
                    }
                } else if (beam.isActive) {
                    beam.activeTimer += dtMs;
                    if (beam.activeTimer >= beam.activeDuration) {
                        horizonBeams.splice(i, 1);
                        continue;
                    }

                    // Check collision with player
                    if (!ghostActive && !isInvincible && canTakeDamage()) {
                        const playerTop = player.y - 25;
                        const playerBottom = player.y + 25;
                        const playerLeft = player.x - 20;
                        const playerRight = player.x + 20;

                        // Check if player is in beam area
                        if (playerBottom > beam.y && playerTop < beam.y + beam.height) {
                            // Check if player is in a gap
                            let inGap = false;
                            for (const gap of beam.gaps) {
                                if (playerLeft > gap.x && playerRight < gap.x + gap.width) {
                                    inGap = true;
                                    break;
                                }
                            }

                            if (!inGap) {
                                // Player hit by beam!
                                if (shieldActive) {
                                    shieldHits = 0;
                                    deactivateShield();
                                    createExplosion(player.x, player.y, '#ff0000', 30);
                                } else {
                                    lives--;
                                    playerHitFlash = 200;
                                    playOuchSound();
                                    createExplosion(player.x, player.y, '#ff0000', 25);
                                    reportAction('hit_by_beam');
                                }
                            }
                        }
                    }
                }
            }
        }

        function updateMagneticMines(dt) {
            const dtMs = dt * 1000;
            for (let i = magneticMines.length - 1; i >= 0; i--) {
                const mine = magneticMines[i];

                mine.timer += dtMs;
                mine.pulsePhase += dt * 5;

                // Magnetic attraction to player
                const dx = player.x - mine.x;
                const dy = player.y - mine.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < mine.magnetRadius && dist > 0) {
                    // Attracted to player
                    const force = mine.magnetStrength * (1 - dist / mine.magnetRadius);
                    mine.vx += (dx / dist) * force * 60 * dt;
                    mine.vy += (dy / dist) * force * 60 * dt;
                }

                // Apply velocity
                mine.x += mine.vx * dt;
                mine.y += mine.vy * dt;

                // Bounce off walls
                if (mine.x < 20 || mine.x > logicalWidth - 20) {
                    mine.vx *= -0.8;
                    mine.x = Math.max(20, Math.min(logicalWidth - 20, mine.x));
                }

                // Remove if expired or off screen
                if (mine.timer >= mine.maxLife || mine.y > logicalHeight + 50) {
                    // Explode on timeout
                    if (mine.timer >= mine.maxLife) {
                        explodeMagneticMine(mine);
                    }
                    magneticMines.splice(i, 1);
                    continue;
                }

                // Check collision with player
                if (!ghostActive && !isInvincible) {
                    const playerDist = Math.sqrt(
                        Math.pow(player.x - mine.x, 2) + Math.pow(player.y - mine.y, 2)
                    );
                    if (playerDist < 30) {
                        explodeMagneticMine(mine);
                        magneticMines.splice(i, 1);
                        continue;
                    }
                }

                // Check collision with player bullets
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const b = bullets[j];
                    if (b.isEnemy) continue;
                    const bulletDist = Math.sqrt(
                        Math.pow(b.x - mine.x, 2) + Math.pow(b.y - mine.y, 2)
                    );
                    if (bulletDist < 20) {
                        explodeMagneticMine(mine);
                        magneticMines.splice(i, 1);
                        bullets.splice(j, 1);
                        break;
                    }
                }
            }
        }

        function explodeMagneticMine(mine) {
            createExplosion(mine.x, mine.y, '#ff6600', 40);
            playExplosion();

            // Damage player if close
            if (!ghostActive && !isInvincible && canTakeDamage()) {
                const playerDist = Math.sqrt(
                    Math.pow(player.x - mine.x, 2) + Math.pow(player.y - mine.y, 2)
                );
                if (playerDist < mine.explosionRadius) {
                    if (shieldActive) {
                        shieldHits = 0;
                        deactivateShield();
                    } else {
                        lives--;
                        playerHitFlash = 200;
                        playOuchSound();
                        reportAction('mine_explosion');
                    }
                }
            }
        }

        function updateMirrorDrones(dt) {
            const dtMs = dt * 1000;
            const now = Date.now();

            for (let i = mirrorDrones.length - 1; i >= 0; i--) {
                const drone = mirrorDrones[i];

                // Mirror player X position with offset
                const targetX = player.x + drone.mirrorOffset;
                drone.x += (targetX - drone.x) * 5 * dt; // Smooth following
                drone.x = Math.max(20, Math.min(logicalWidth - 20, drone.x));

                // Periodic shooting
                if (now - drone.lastShot > drone.fireRate) {
                    bullets.push({
                        x: drone.x,
                        y: drone.y + 15,
                        vx: 0,
                        vy: 300,
                        isEnemy: true,
                        color: '#ff00ff'
                    });
                    drone.lastShot = now;
                    playSound(500, 'sine', 0.05, 0.1);
                }

                // Check if drone is hit by player bullets
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const b = bullets[j];
                    if (b.isEnemy) continue;

                    const dx = b.x - drone.x;
                    const dy = b.y - drone.y;
                    if (Math.abs(dx) < drone.width / 2 + 5 && Math.abs(dy) < drone.height / 2 + 5) {
                        drone.health -= b.damage || 10;
                        createExplosion(b.x, b.y, '#ff00ff', 10);
                        bullets.splice(j, 1);

                        if (drone.health <= 0) {
                            createExplosion(drone.x, drone.y, '#ff00ff', 25);
                            playExplosion();
                            score += 50;
                            mirrorDrones.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }

        function updateBoss(dt) {
            if (!boss) return;

            const diff = getDiffSettings();

            // Entry animation
            if (boss.entering) {
                boss.y += 100 * dt;
                if (boss.y >= boss.targetY) {
                    boss.y = boss.targetY;
                    boss.entering = false;
                    // Initialize random movement pattern
                    boss.movementMode = 'random_waypoint';
                    boss.waypoint = { x: logicalWidth / 2, y: boss.targetY };
                    boss.patternTimer = 0;
                    boss.patternDuration = 3 + Math.random() * 3;
                    boss.orbitAngle = 0;
                    boss.zigzagPhase = 0;
                }
                return;
            }

            // Randomized movement patterns
            boss.moveTimer += dt;
            boss.patternTimer += dt;
            const moveSpeed = boss.speed * diff.speedMult;

            // Change movement pattern randomly every 3-6 seconds
            if (boss.patternTimer > boss.patternDuration) {
                const patterns = ['random_waypoint', 'chase', 'zigzag', 'orbit', 'strafe', 'dive', 'advance'];
                boss.movementMode = patterns[Math.floor(Math.random() * patterns.length)];
                boss.patternDuration = 3 + Math.random() * 3;
                boss.patternTimer = 0;
                // Set new waypoint - can go further down the screen now
                boss.waypoint = {
                    x: 100 + Math.random() * (logicalWidth - 200),
                    y: 80 + Math.random() * 250  // Can go down to Y=330
                };
            }

            // Execute movement based on current pattern
            switch (boss.movementMode) {
                case 'random_waypoint':
                    // Move toward waypoint
                    const dx = boss.waypoint.x - boss.x;
                    const dy = boss.waypoint.y - boss.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 10) {
                        boss.x += (dx / dist) * moveSpeed * dt;
                        boss.y += (dy / dist) * moveSpeed * dt * 0.5;
                    } else {
                        // Reached waypoint, set new one
                        boss.waypoint = {
                            x: 100 + Math.random() * (logicalWidth - 200),
                            y: 80 + Math.random() * 150
                        };
                    }
                    break;

                case 'chase':
                    // Slowly follow player horizontally
                    const chaseX = player.x - boss.x;
                    boss.x += Math.sign(chaseX) * moveSpeed * dt * 0.5;
                    // Bob up and down
                    boss.y = boss.targetY + Math.sin(boss.moveTimer * 3) * 40;
                    break;

                case 'zigzag':
                    // Quick zigzag pattern
                    boss.zigzagPhase += dt * 4;
                    boss.x += Math.sin(boss.zigzagPhase) * moveSpeed * dt * 2;
                    boss.y = boss.targetY + Math.cos(boss.zigzagPhase * 0.5) * 30;
                    break;

                case 'orbit':
                    // Circular orbit around center
                    boss.orbitAngle += dt * 1.5;
                    const orbitRadius = 150;
                    boss.x = logicalWidth / 2 + Math.cos(boss.orbitAngle) * orbitRadius;
                    boss.y = boss.targetY + Math.sin(boss.orbitAngle) * 50;
                    break;

                case 'strafe':
                    // Fast horizontal strafe
                    boss.x += boss.moveDirX * moveSpeed * dt * 1.5;
                    if (boss.x < boss.width / 2 + 20) {
                        boss.x = boss.width / 2 + 20;
                        boss.moveDirX = 1;
                    }
                    if (boss.x > logicalWidth - boss.width / 2 - 20) {
                        boss.x = logicalWidth - boss.width / 2 - 20;
                        boss.moveDirX = -1;
                    }
                    boss.y = boss.targetY + Math.sin(boss.moveTimer * 2) * 20;
                    break;

                case 'dive':
                    // Aggressive dive toward player then retreat
                    if (!boss.divePhase) boss.divePhase = 0;
                    boss.divePhase += dt;
                    if (boss.divePhase < 1.5) {
                        // Dive down toward player
                        boss.y += moveSpeed * dt * 1.2;
                        boss.x += (player.x - boss.x) * dt * 0.8;
                    } else if (boss.divePhase < 3) {
                        // Retreat back up
                        boss.y -= moveSpeed * dt * 0.8;
                    } else {
                        boss.divePhase = 0;
                    }
                    break;

                case 'advance':
                    // Slowly advance toward player, maintaining pressure
                    const targetY = Math.min(player.y - 150, 350); // Stay above player
                    const advanceDy = targetY - boss.y;
                    boss.y += Math.sign(advanceDy) * Math.min(Math.abs(advanceDy), moveSpeed * dt * 0.5);
                    // Sway side to side while advancing
                    boss.x += Math.sin(boss.moveTimer * 2) * moveSpeed * dt * 0.5;
                    break;
            }

            // Keep boss in bounds - expanded vertical range
            boss.x = Math.max(boss.width / 2 + 20, Math.min(logicalWidth - boss.width / 2 - 20, boss.x));
            boss.y = Math.max(60, Math.min(380, boss.y)); // Can go further down (up to Y=380)

            // Shooting
            boss.shootTimer -= dt;
            if (boss.shootTimer <= 0) {
                bossAttack();
                boss.shootTimer = boss.fireRate / diff.enemyFireMult;
            }

            // Taunt timer
            bossTauntTimer += dt;
            if (bossTauntTimer > 8) {
                showBossTaunt();
                bossTauntTimer = 0;
            }
        }

        function drawBoss() {
            if (!boss) return;

            ctx.save();
            ctx.translate(boss.x, boss.y);

            // Glow effect
            ctx.fillStyle = boss.color + '33';
            ctx.beginPath();
            ctx.ellipse(0, 0, boss.width / 2 + 20, boss.height / 2 + 20, 0, 0, Math.PI * 2);
            ctx.fill();

            if (boss.type === 'aircraft') {
                // Large aircraft boss
                ctx.fillStyle = boss.color;
                // Main body
                ctx.beginPath();
                ctx.moveTo(0, -boss.height / 2);
                ctx.lineTo(-boss.width / 2, boss.height / 2);
                ctx.lineTo(-boss.width / 4, boss.height / 3);
                ctx.lineTo(boss.width / 4, boss.height / 3);
                ctx.lineTo(boss.width / 2, boss.height / 2);
                ctx.closePath();
                ctx.fill();

                // Wings
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(-boss.width / 4, 0);
                ctx.lineTo(-boss.width / 2 - 30, boss.height / 4);
                ctx.lineTo(-boss.width / 4, boss.height / 4);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(boss.width / 4, 0);
                ctx.lineTo(boss.width / 2 + 30, boss.height / 4);
                ctx.lineTo(boss.width / 4, boss.height / 4);
                ctx.closePath();
                ctx.fill();

                // Cockpit
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.ellipse(0, -boss.height / 4, 15, 20, 0, 0, Math.PI * 2);
                ctx.fill();

                // Engine glow
                ctx.fillStyle = '#ff6600';
                const flicker = Math.sin(Date.now() / 50) * 5;
                ctx.beginPath();
                ctx.moveTo(-20, boss.height / 3);
                ctx.lineTo(-10, boss.height / 2 + 15 + flicker);
                ctx.lineTo(0, boss.height / 3);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(0, boss.height / 3);
                ctx.lineTo(10, boss.height / 2 + 15 + flicker);
                ctx.lineTo(20, boss.height / 3);
                ctx.closePath();
                ctx.fill();

            } else {
                // Monster boss
                ctx.fillStyle = boss.color;

                // Body
                ctx.beginPath();
                ctx.ellipse(0, 0, boss.width / 2, boss.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Tentacles/appendages
                const time = Date.now() / 200;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI + Math.PI / 2;
                    const wave = Math.sin(time + i) * 10;
                    ctx.strokeStyle = boss.color;
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * boss.width / 3, Math.sin(angle) * boss.height / 3);
                    ctx.quadraticCurveTo(
                        Math.cos(angle) * boss.width / 2 + wave,
                        Math.sin(angle) * boss.height / 2 + wave,
                        Math.cos(angle) * (boss.width / 2 + 30),
                        Math.sin(angle) * (boss.height / 2 + 20)
                    );
                    ctx.stroke();
                }

                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(-25, -15, 20, 15, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(25, -15, 20, 15, 0, 0, Math.PI * 2);
                ctx.fill();

                // Pupils (follow player)
                const dx = player.x - boss.x;
                const dy = player.y - boss.y;
                const dist = Math.hypot(dx, dy);
                const px = (dx / dist) * 8 || 0;
                const py = (dy / dist) * 5 || 0;
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.ellipse(-25 + px, -15 + py, 10, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(25 + px, -15 + py, 10, 10, 0, 0, Math.PI * 2);
                ctx.fill();

                // Mouth
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(0, 20, 30, 15, 0, 0, Math.PI);
                ctx.fill();
                // Teeth
                ctx.fillStyle = '#fff';
                for (let i = -3; i <= 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * 8 - 4, 20);
                    ctx.lineTo(i * 8, 30);
                    ctx.lineTo(i * 8 + 4, 20);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            ctx.restore();

            // Health indicator flash when hit
            if (boss.hitFlash) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.ellipse(boss.x, boss.y, boss.width / 2, boss.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                boss.hitFlash = false;
            }
        }

        let bossLowHealthReported = false;

        function damageBoss(damage) {
            if (!boss) return;
            boss.health -= damage;
            boss.hitFlash = true;
            updateBossHealthBar();
            createExplosion(boss.x + (Math.random() - 0.5) * boss.width, boss.y + (Math.random() - 0.5) * boss.height, '#ffff00', 10);

            // Report boss low health once
            const healthPercent = (boss.health / boss.maxHealth) * 100;
            if (healthPercent <= 25 && !bossLowHealthReported) {
                bossLowHealthReported = true;
                reportAction('boss_low_health', { healthPercent: Math.floor(healthPercent) });
            }

            if (boss.health <= 0) {
                bossLowHealthReported = false;
                defeatBoss();
            }
        }

        let bossDefeating = false; // Flag to prevent multiple defeatBoss calls

        function defeatBoss() {
            if (!boss || bossDefeating) return;
            bossDefeating = true; // Prevent re-entry during animation

            // Capture boss reference before it gets nulled
            const defeatedBoss = {
                x: boss.x,
                y: boss.y,
                width: boss.width,
                height: boss.height,
                isSuper: boss.isSuper
            };

            // Epic explosion
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    createBigExplosion(
                        defeatedBoss.x + (Math.random() - 0.5) * defeatedBoss.width,
                        defeatedBoss.y + (Math.random() - 0.5) * defeatedBoss.height
                    );
                    playBigExplosion();
                }, i * 150);
            }

            // Final explosion and cleanup
            setTimeout(() => {
                createBigExplosion(defeatedBoss.x, defeatedBoss.y);
                for (let i = 0; i < 100; i++) {
                    particles.push({
                        x: defeatedBoss.x, y: defeatedBoss.y,
                        vx: (Math.random() - 0.5) * 600,
                        vy: (Math.random() - 0.5) * 600,
                        size: Math.random() * 8 + 4,
                        color: ['#ff0000', '#ff6600', '#ffff00', '#ffffff'][Math.floor(Math.random() * 4)],
                        life: 1.5
                    });
                }

                // Award points - fixed 1000 per boss
                score += 1000;
                document.getElementById('score').textContent = score;

                // Report boss defeat action
                const defeatedLevel = level;
                const wasSuper = defeatedBoss.isSuper;
                reportAction('defeated_boss', { bossLevel: defeatedLevel, isSuper: wasSuper });
                // Report game event for server score validation
                reportGameEvent('boss_defeated', { bossLevel: defeatedLevel, isSuper: wasSuper });

                // Mark boss as defeated and advance level
                bossDefeated.push(level);
                killsThisLevel = 0; // Reset kills for next level's boss

                // Cleanup boss
                boss = null;
                bossActive = false;
                document.getElementById('bossHealthContainer').classList.remove('show');
                document.getElementById('bossTaunt').classList.remove('show');
                stopBossMusic();

                // Check if Super Boss was defeated - VICTORY!
                if (wasSuper) {
                    playBossDefeat();
                    setTimeout(() => {
                        showVictoryScreen();
                    }, 2000);
                    return;
                }

                // Advance level
                level++;
                if (level > 6) level = 6;
                document.getElementById('levelDisplay').textContent = level <= 5 ? 'Level ' + level : 'FINAL LEVEL';

                // Reset respawns/continues for new level
                respawnsUsedThisLevel = 0;
                continuesUsedThisLevel = 0;
                savedLevelScore = score;

                // Save progress for authenticated users
                saveGameProgress();

                // Report level up action
                reportAction('level_up', { newLevel: level });

                // Play victory, resume normal music
                playBossDefeat();
                bossDefeating = false; // Reset flag after defeat complete
                setTimeout(() => {
                    if (gameRunning && !bossActive) startBackgroundMusic(shieldActive);
                }, 1500);

            }, 1500);
        }

        // === BACKGROUND INITIALIZATION ===
        function initBackground() {
            stars = [];
            nebulae = [];
            spaceObjects = [];

            // Stars - 3 layers for parallax
            for (let i = 0; i < 60; i++) {
                stars.push({
                    x: Math.random() * logicalWidth, y: Math.random() * logicalHeight,
                    size: Math.random() * 1.5 + 0.5, speed: 30 + Math.random() * 30,
                    layer: 0, phase: Math.random() * Math.PI * 2
                });
            }
            for (let i = 0; i < 40; i++) {
                stars.push({
                    x: Math.random() * logicalWidth, y: Math.random() * logicalHeight,
                    size: Math.random() * 2 + 1, speed: 60 + Math.random() * 40,
                    layer: 1, phase: Math.random() * Math.PI * 2
                });
            }
            for (let i = 0; i < 20; i++) {
                stars.push({
                    x: Math.random() * logicalWidth, y: Math.random() * logicalHeight,
                    size: Math.random() * 2.5 + 1.5, speed: 100 + Math.random() * 50,
                    layer: 2, phase: Math.random() * Math.PI * 2
                });
            }

            // Nebulae (colored gas clouds)
            for (let i = 0; i < 3; i++) {
                nebulae.push({
                    x: Math.random() * logicalWidth, y: Math.random() * logicalHeight - 200,
                    width: 200 + Math.random() * 300, height: 150 + Math.random() * 200,
                    color: ['#4a0080', '#800040', '#004080', '#008040'][Math.floor(Math.random() * 4)],
                    speed: 15 + Math.random() * 10, alpha: 0.1 + Math.random() * 0.15
                });
            }
        }

        function spawnSpaceObject() {
            const types = ['station', 'planet', 'asteroid', 'satellite', 'comet'];
            // More variety at higher levels
            const availableTypes = types.slice(0, Math.min(level + 2, types.length));
            const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];

            const obj = {
                type, x: Math.random() * (logicalWidth - 100) + 50, y: -150,
                speed: 20 + Math.random() * 30, rotation: 0, rotSpeed: (Math.random() - 0.5) * 0.5
            };

            if (type === 'planet') {
                obj.radius = 40 + Math.random() * 60;
                obj.color = ['#c0a080', '#80a0c0', '#a0c080', '#c08080', '#8080c0'][Math.floor(Math.random() * 5)];
                obj.rings = Math.random() > 0.6;
            } else if (type === 'station') {
                obj.width = 80 + Math.random() * 60;
                obj.height = 40 + Math.random() * 30;
            } else if (type === 'asteroid') {
                obj.radius = 15 + Math.random() * 25;
                obj.points = [];
                for (let i = 0; i < 8; i++) {
                    obj.points.push(0.7 + Math.random() * 0.6);
                }
            } else if (type === 'satellite') {
                obj.size = 20 + Math.random() * 15;
            } else if (type === 'comet') {
                obj.radius = 8 + Math.random() * 12;
                obj.tailLength = 80 + Math.random() * 60;
            }

            spaceObjects.push(obj);
        }

        // === SPAWN FUNCTIONS ===
        function getDiffSettings() { return DIFFICULTIES[selectedDifficulty]; }
        function getSpeedMultiplier() {
            const baseSpeed = levelSpeeds[Math.min(level, 5)] || 2.0;
            return baseSpeed * getDiffSettings().speedMult;
        }

        // Enemy weapon types available by level
        const ENEMY_WEAPONS_BY_LEVEL = {
            1: ['pistol'],
            2: ['pistol', 'spread'],
            3: ['pistol', 'spread', 'aimed'],
            4: ['pistol', 'spread', 'aimed', 'burst'],
            5: ['pistol', 'spread', 'aimed', 'burst', 'machinegun'],
            6: ['pistol', 'spread', 'aimed', 'burst', 'machinegun', 'bazooka']
        };

        function getEnemyWeapon() {
            // Enemies get more weapon types at higher levels
            const availableWeapons = ENEMY_WEAPONS_BY_LEVEL[Math.min(level, 6)];
            // Weight toward basic weapons but allow advanced ones
            const rand = Math.random();
            if (rand < 0.4) {
                return 'pistol'; // 40% basic
            } else if (rand < 0.7) {
                // 30% - pick from first half of available weapons
                const halfIdx = Math.floor(availableWeapons.length / 2);
                return availableWeapons[Math.floor(Math.random() * Math.max(1, halfIdx))];
            } else {
                // 30% - pick from any available weapon
                return availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
            }
        }

        function spawnEnemy() {
            const mult = getSpeedMultiplier();
            const weapon = getEnemyWeapon();
            enemies.push({
                x: Math.random() * (logicalWidth - 60) + 30, y: -30,
                width: 40, height: 40, speed: (100 + Math.random() * 100) * mult,
                shootTimer: Math.random() * 0.5 + 0.5, weapon: weapon
            });
        }

        function spawnPowerup() {
            // Powerup types: shield, fullLife, ghost, life1, life2, life3, lightning
            const rand = Math.random();
            let type;
            if (rand < 0.30) type = 'shield';           // 30% shield
            else if (rand < 0.38) type = 'fullLife';    // 8% full life restore
            else if (rand < 0.46) type = 'ghost';       // 8% ghost mode
            else if (rand < 0.54) type = 'lightning';   // 8% lightning bolt
            else if (rand < 0.72) type = 'life1';       // 18% +1 life
            else if (rand < 0.88) type = 'life2';       // 16% +2 lives
            else type = 'life3';                         // 12% +3 lives

            powerups.push({
                x: Math.random() * (logicalWidth - 60) + 30, y: -30,
                width: 30, height: 30, speed: 80 * getSpeedMultiplier(), rotation: 0, type: type
            });
        }

        function spawnBomb() {
            bombs.push({
                x: Math.random() * (logicalWidth - 60) + 30, y: -30,
                width: 25, height: 25, speed: 60 * getSpeedMultiplier(), rotation: 0
            });
        }

        function spawnMine() {
            mines.push({
                x: Math.random() * (logicalWidth - 60) + 30, y: -30,
                width: 28, height: 28, speed: 40 * getSpeedMultiplier(), rotation: 0,
                vx: (Math.random() - 0.5) * 60, // Float randomly left/right
                pulsePhase: Math.random() * Math.PI * 2
            });
        }

        function spawnWall() {
            const width = 80 + Math.random() * 120;
            walls.push({
                x: Math.random() * (logicalWidth - width), y: -40,
                width: width, height: 20, speed: 50 * getSpeedMultiplier()
            });
        }

        // === ELECTRIC FENCES ===
        function spawnElectricFence() {
            // Only spawn fences in level 3+
            if (level < 3) return;

            const isVertical = Math.random() < 0.5;
            let fence;

            if (isVertical) {
                // Vertical fence on left or right side
                const onLeft = Math.random() < 0.5;
                fence = {
                    x: onLeft ? 30 : logicalWidth - 50,
                    y: 100 + Math.random() * 200,
                    width: 20,
                    height: 150 + Math.random() * 100,
                    isActive: true,
                    flickerTimer: 0,
                    nextToggle: 2000 + Math.random() * 3000,
                    warningTimer: 0,
                    isWarning: false,
                    stationary: true
                };
            } else {
                // Horizontal fence that scrolls down
                const width = 100 + Math.random() * 150;
                fence = {
                    x: Math.random() * (logicalWidth - width - 100) + 50,
                    y: -30,
                    width: width,
                    height: 15,
                    isActive: true,
                    flickerTimer: 0,
                    nextToggle: 2000 + Math.random() * 3000,
                    warningTimer: 0,
                    isWarning: false,
                    stationary: false,
                    speed: 40 * getSpeedMultiplier()
                };
            }

            electricFences.push(fence);
        }

        function updateElectricFences(dt) {
            electricFences.forEach(fence => {
                // Move non-stationary fences
                if (!fence.stationary) {
                    fence.y += fence.speed * dt;
                }

                // Toggle timer
                fence.flickerTimer += dt * 1000;

                // Warning phase before toggling on
                if (!fence.isActive && fence.flickerTimer >= fence.nextToggle - 500) {
                    fence.isWarning = true;
                }

                // Toggle state
                if (fence.flickerTimer >= fence.nextToggle) {
                    fence.isActive = !fence.isActive;
                    fence.flickerTimer = 0;
                    fence.nextToggle = 2000 + Math.random() * 3000;
                    fence.isWarning = false;
                    if (fence.isActive) {
                        playElectricSound();
                    }
                }
            });

            // Remove fences that have scrolled off screen
            electricFences = electricFences.filter(f => f.stationary || f.y < logicalHeight + 50);

            // Remove old stationary fences randomly (max 4 at a time)
            while (electricFences.filter(f => f.stationary).length > 4) {
                const stationaryIdx = electricFences.findIndex(f => f.stationary);
                if (stationaryIdx >= 0) electricFences.splice(stationaryIdx, 1);
            }
        }

        function drawElectricFence(fence) {
            ctx.save();

            if (fence.isActive) {
                // Active fence - bright blue electric effect
                const flicker = Math.sin(Date.now() * 0.02) * 0.3 + 0.7;

                // Glow effect
                ctx.fillStyle = `rgba(100, 200, 255, ${flicker * 0.3})`;
                ctx.fillRect(fence.x - 5, fence.y - 5, fence.width + 10, fence.height + 10);

                // Main fence body
                ctx.fillStyle = `rgba(150, 220, 255, ${flicker})`;
                ctx.fillRect(fence.x, fence.y, fence.width, fence.height);

                // Electric sparks
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                for (let i = 0; i < 5; i++) {
                    const sparkX = fence.x + Math.random() * fence.width;
                    const sparkY = fence.y + Math.random() * fence.height;
                    ctx.beginPath();
                    ctx.moveTo(sparkX, sparkY);
                    ctx.lineTo(sparkX + (Math.random() - 0.5) * 20, sparkY + (Math.random() - 0.5) * 20);
                    ctx.stroke();
                }

                // Edge glow
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 3;
                ctx.strokeRect(fence.x, fence.y, fence.width, fence.height);
            } else if (fence.isWarning) {
                // Warning phase - flashing
                const flash = Math.sin(Date.now() * 0.015) > 0;
                if (flash) {
                    ctx.fillStyle = 'rgba(255, 100, 100, 0.5)';
                    ctx.fillRect(fence.x, fence.y, fence.width, fence.height);
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(fence.x, fence.y, fence.width, fence.height);
                }
            } else {
                // Inactive - dim outline
                ctx.strokeStyle = 'rgba(100, 150, 200, 0.3)';
                ctx.lineWidth = 1;
                ctx.strokeRect(fence.x, fence.y, fence.width, fence.height);
            }

            ctx.restore();
        }

        // === DRAW FUNCTIONS FOR NEW BOSS WEAPONS ===

        function drawHorizonBeam(beam) {
            ctx.save();

            if (beam.isWarning) {
                // Warning phase - flashing red line showing where beam will appear
                const flash = Math.sin(Date.now() * 0.02) > 0;
                if (flash) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([20, 10]);
                    ctx.beginPath();
                    ctx.moveTo(0, beam.y + beam.height / 2);
                    ctx.lineTo(logicalWidth, beam.y + beam.height / 2);
                    ctx.stroke();

                    // Draw gap indicators (safe zones)
                    ctx.setLineDash([]);
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                    for (const gap of beam.gaps) {
                        ctx.fillRect(gap.x, beam.y - 10, gap.width, beam.height + 20);
                    }
                }
            } else if (beam.isActive) {
                // Active beam - deadly laser across screen
                const intensity = Math.sin(Date.now() * 0.03) * 0.2 + 0.8;

                // Outer glow
                ctx.fillStyle = `rgba(255, 50, 50, ${intensity * 0.3})`;
                ctx.fillRect(0, beam.y - 15, logicalWidth, beam.height + 30);

                // Inner beam
                ctx.fillStyle = `rgba(255, 150, 100, ${intensity * 0.8})`;
                ctx.fillRect(0, beam.y, logicalWidth, beam.height);

                // Core
                ctx.fillStyle = `rgba(255, 255, 200, ${intensity})`;
                ctx.fillRect(0, beam.y + beam.height * 0.3, logicalWidth, beam.height * 0.4);

                // Draw gaps (safe zones) as dark areas
                ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                for (const gap of beam.gaps) {
                    ctx.fillRect(gap.x, beam.y - 15, gap.width, beam.height + 30);
                    // Green border around safe zone
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(gap.x, beam.y - 15, gap.width, beam.height + 30);
                }
            }

            ctx.restore();
        }

        function drawMagneticMine(mine) {
            ctx.save();
            ctx.translate(mine.x, mine.y);

            // Pulsing glow showing magnetic field
            const pulseRadius = 20 + Math.sin(mine.pulsePhase) * 5;
            const gradient = ctx.createRadialGradient(0, 0, 5, 0, 0, pulseRadius);
            gradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 50, 0, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, pulseRadius, 0, Math.PI * 2);
            ctx.fill();

            // Mine body
            ctx.fillStyle = '#ff6600';
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.fill();

            // Spikes
            ctx.fillStyle = '#ff3300';
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + mine.pulsePhase * 0.2;
                const spikeX = Math.cos(angle) * 15;
                const spikeY = Math.sin(angle) * 15;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * 8, Math.sin(angle) * 8);
                ctx.lineTo(spikeX, spikeY);
                ctx.lineTo(Math.cos(angle + 0.2) * 8, Math.sin(angle + 0.2) * 8);
                ctx.fill();
            }

            // Center light
            const blinkIntensity = Math.sin(mine.pulsePhase * 2) > 0 ? 1 : 0.3;
            ctx.fillStyle = `rgba(255, 255, 0, ${blinkIntensity})`;
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2);
            ctx.fill();

            // Show magnet radius when close to player
            const playerDist = Math.sqrt(Math.pow(player.x - mine.x, 2) + Math.pow(player.y - mine.y, 2));
            if (playerDist < mine.magnetRadius * 1.2) {
                ctx.strokeStyle = `rgba(255, 100, 0, ${0.2 * (1 - playerDist / mine.magnetRadius)})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(0, 0, mine.magnetRadius, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawMirrorDrone(drone) {
            ctx.save();
            ctx.translate(drone.x, drone.y);

            // Drone body
            ctx.fillStyle = '#8800ff';
            ctx.beginPath();
            ctx.moveTo(-15, 10);
            ctx.lineTo(0, -10);
            ctx.lineTo(15, 10);
            ctx.lineTo(0, 5);
            ctx.closePath();
            ctx.fill();

            // Engine glow
            ctx.fillStyle = '#ff00ff';
            ctx.beginPath();
            ctx.arc(0, 8, 4 + Math.sin(Date.now() * 0.01) * 2, 0, Math.PI * 2);
            ctx.fill();

            // Wings
            ctx.fillStyle = '#aa44ff';
            ctx.fillRect(-20, 0, 8, 6);
            ctx.fillRect(12, 0, 8, 6);

            // Health indicator
            const healthPercent = drone.health / 30;
            ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffff00' : '#ff0000';
            ctx.fillRect(-10, -15, 20 * healthPercent, 3);

            ctx.restore();
        }

        function playElectricSound() {
            if (isMuted) return;
            // Electric zap sound - white noise with oscillator
            const bufferSize = audioContext.sampleRate * 0.2;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.3)) * Math.sin(i * 0.1);
            }
            const source = audioContext.createBufferSource();
            const g = audioContext.createGain();
            source.buffer = buffer;
            source.connect(g);
            g.connect(audioContext.destination);
            g.gain.setValueAtTime(0.2, audioContext.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            source.start();
        }

        function spawnWeaponPickup() {
            // All weapons that can spawn as pickups (new weapons unlock in later levels)
            let available = ['machinegun', 'bazooka', 'laser'];
            if (level >= 2) available.push('flak');
            if (level >= 3) available.push('disc');
            if (level >= 4) available.push('swarm');

            // Prefer weapons not unlocked yet, but also spawn ammo for unlocked ones
            const notUnlocked = available.filter(w => !unlockedWeapons.includes(w));
            let type;
            if (notUnlocked.length > 0 && Math.random() < 0.6) {
                // 60% chance to spawn a new weapon
                type = notUnlocked[Math.floor(Math.random() * notUnlocked.length)];
            } else {
                // 40% chance to spawn ammo for any weapon
                type = available[Math.floor(Math.random() * available.length)];
            }

            weaponPickups.push({
                x: Math.random() * (logicalWidth - 60) + 30, y: -30,
                width: 30, height: 30, speed: 70 * getSpeedMultiplier(), rotation: 0, type: type
            });
        }

        // === BACKGROUND DRAWING ===
        function getBackgroundGradient() {
            // Background changes based on level - going deeper into space
            const gradients = [
                ['#0a0a1a', '#1a1a3e', '#2d2d5a'], // Level 1: Near Earth
                ['#0a0a20', '#151540', '#252570'], // Level 2: Deep space
                ['#100520', '#200840', '#351060'], // Level 3: Nebula region
                ['#150505', '#300a10', '#501020'], // Level 4: Red giant region
                ['#000010', '#000030', '#100050']  // Level 5: Edge of galaxy
            ];
            return gradients[Math.min(level - 1, 4)];
        }

        function drawBackground() {
            const colors = getBackgroundGradient();
            const gradient = ctx.createLinearGradient(0, 0, 0, logicalHeight);
            gradient.addColorStop(0, colors[0]);
            gradient.addColorStop(0.5, colors[1]);
            gradient.addColorStop(1, colors[2]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, logicalWidth, logicalHeight);

            // Draw nebulae
            nebulae.forEach(n => {
                const grad = ctx.createRadialGradient(n.x + n.width/2, n.y + n.height/2, 0,
                    n.x + n.width/2, n.y + n.height/2, n.width/2);
                grad.addColorStop(0, n.color + '40');
                grad.addColorStop(0.5, n.color + '20');
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.fillRect(n.x, n.y, n.width, n.height);
            });

            // Draw stars with parallax
            const time = Date.now() / 1000;
            stars.forEach(star => {
                const twinkle = 0.5 + Math.sin(time * 2 + star.phase) * 0.3;
                ctx.globalAlpha = twinkle * (0.4 + star.layer * 0.2);
                ctx.fillStyle = star.layer === 2 ? '#ffffcc' : '#ffffff';
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Draw space objects
            spaceObjects.forEach(obj => {
                ctx.save();
                ctx.translate(obj.x, obj.y);
                ctx.rotate(obj.rotation);

                if (obj.type === 'planet') {
                    // Planet with optional rings
                    ctx.fillStyle = obj.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, obj.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // Shading
                    const shadeGrad = ctx.createLinearGradient(-obj.radius, -obj.radius, obj.radius, obj.radius);
                    shadeGrad.addColorStop(0, 'rgba(255,255,255,0.2)');
                    shadeGrad.addColorStop(1, 'rgba(0,0,0,0.4)');
                    ctx.fillStyle = shadeGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, obj.radius, 0, Math.PI * 2);
                    ctx.fill();
                    if (obj.rings) {
                        ctx.strokeStyle = 'rgba(200,180,150,0.5)';
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, obj.radius * 1.8, obj.radius * 0.3, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                } else if (obj.type === 'station') {
                    // Space station
                    ctx.fillStyle = '#666';
                    ctx.fillRect(-obj.width/2, -obj.height/2, obj.width, obj.height);
                    ctx.fillStyle = '#888';
                    ctx.fillRect(-obj.width/2 + 10, -obj.height/2 - 15, 20, 15);
                    ctx.fillRect(obj.width/2 - 30, -obj.height/2 - 15, 20, 15);
                    // Solar panels
                    ctx.fillStyle = '#334';
                    ctx.fillRect(-obj.width/2 - 30, -5, 30, 10);
                    ctx.fillRect(obj.width/2, -5, 30, 10);
                    // Lights
                    ctx.fillStyle = Math.sin(Date.now() / 200) > 0 ? '#ff0000' : '#660000';
                    ctx.beginPath();
                    ctx.arc(0, -obj.height/2, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obj.type === 'asteroid') {
                    ctx.fillStyle = '#665544';
                    ctx.beginPath();
                    for (let i = 0; i < obj.points.length; i++) {
                        const angle = (i / obj.points.length) * Math.PI * 2;
                        const r = obj.radius * obj.points[i];
                        if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                        else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#554433';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else if (obj.type === 'satellite') {
                    ctx.fillStyle = '#aaa';
                    ctx.fillRect(-obj.size/4, -obj.size/4, obj.size/2, obj.size/2);
                    ctx.fillStyle = '#336';
                    ctx.fillRect(-obj.size, -obj.size/8, obj.size * 2, obj.size/4);
                } else if (obj.type === 'comet') {
                    // Comet tail
                    const tailGrad = ctx.createLinearGradient(0, 0, obj.tailLength, obj.tailLength/2);
                    tailGrad.addColorStop(0, 'rgba(150,200,255,0.8)');
                    tailGrad.addColorStop(1, 'transparent');
                    ctx.fillStyle = tailGrad;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(obj.tailLength, obj.tailLength/3);
                    ctx.lineTo(obj.tailLength, -obj.tailLength/3);
                    ctx.closePath();
                    ctx.fill();
                    // Comet head
                    ctx.fillStyle = '#aaddff';
                    ctx.beginPath();
                    ctx.arc(0, 0, obj.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            });
        }

        function updateBackground(dt) {
            // Background speed scales with difficulty (faster = feels like moving faster)
            const bgSpeedMult = getDiffSettings().speedMult * 0.7; // Scale background speed

            // Update stars
            stars.forEach(s => {
                s.y += s.speed * bgSpeedMult * dt;
                if (s.y > logicalHeight) { s.y = -5; s.x = Math.random() * logicalWidth; }
            });

            // Update nebulae
            nebulae.forEach(n => {
                n.y += n.speed * bgSpeedMult * dt;
                if (n.y > logicalHeight + 100) {
                    n.y = -n.height - 100;
                    n.x = Math.random() * logicalWidth;
                    n.color = ['#4a0080', '#800040', '#004080', '#008040'][Math.floor(Math.random() * 4)];
                }
            });

            // Update space objects
            spaceObjects.forEach(obj => {
                obj.y += obj.speed * bgSpeedMult * dt;
                obj.rotation += obj.rotSpeed * dt;
            });
            spaceObjects = spaceObjects.filter(obj => obj.y < logicalHeight + 200);
        }

        // === DRAWING ===
        function drawPlayer() {
            const colors = jetColors[selectedColor];
            ctx.save();
            ctx.translate(player.x, player.y);

            // Player hit flash effect (red overlay when damaged)
            if (playerHitFlash > 0) {
                ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.03) * 0.3;
            }

            // Coop mode: if dead/respawning, draw as ghost with timer
            if (isMultiplayer && selectedGameMode === 'coop' && !coopState.amActive) {
                ctx.globalAlpha = 0.3;
                // Draw respawn timer above player
                const timeLeft = Math.ceil((COOP_RESPAWN_TIME - (Date.now() - coopState.myRespawnStartTime)) / 1000);
                if (timeLeft > 0 && timeLeft <= 5) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(timeLeft + 's', 0, -40);
                }
            }

            // Coop mode: invincibility flash after respawn
            if (isMultiplayer && selectedGameMode === 'coop' && coopState.amInvincible) {
                const flash = Math.sin(Date.now() / 50) > 0;
                if (!flash) {
                    ctx.globalAlpha *= 0.5;
                }
            }

            // Flashing shield
            if (shieldActive) {
                const flash = Math.sin(Date.now() / 80) > 0;
                const pulse = 0.4 + Math.sin(Date.now() / 100) * 0.4;
                if (flash) {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${pulse})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, 42, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.strokeStyle = `rgba(100, 255, 255, ${pulse * 0.7})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 38, 0, Math.PI * 2);
                ctx.stroke();
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse * 0.5})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(0, 0, 45, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.fillStyle = colors.body;
            ctx.beginPath();
            ctx.moveTo(0, -25); ctx.lineTo(-20, 25); ctx.lineTo(-8, 20);
            ctx.lineTo(-8, 25); ctx.lineTo(8, 25); ctx.lineTo(8, 20); ctx.lineTo(20, 25);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = colors.cockpit;
            ctx.beginPath();
            ctx.ellipse(0, -5, 6, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = colors.wings;
            ctx.beginPath();
            ctx.moveTo(-8, 5); ctx.lineTo(-30, 20); ctx.lineTo(-8, 15);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(8, 5); ctx.lineTo(30, 20); ctx.lineTo(8, 15);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#ff6b35';
            ctx.beginPath();
            ctx.moveTo(-5, 25);
            ctx.lineTo(0, 35 + Math.sin(Date.now() / 50) * 2.5 + 2.5);
            ctx.lineTo(5, 25);
            ctx.closePath();
            ctx.fill();

            // Red overlay when hit
            if (playerHitFlash > 0) {
                ctx.globalAlpha = 0.4 + Math.sin(Date.now() * 0.02) * 0.2;
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.moveTo(0, -25); ctx.lineTo(-20, 25); ctx.lineTo(-8, 20);
                ctx.lineTo(-8, 25); ctx.lineTo(8, 25); ctx.lineTo(8, 20); ctx.lineTo(20, 25);
                ctx.closePath();
                ctx.fill();
            }

            ctx.restore();
        }

        // Draw the other player in multiplayer modes (coop or versus)
        function drawOtherPlayer() {
            if (!isMultiplayer) return;
            if (selectedGameMode === 'coop' && !coopState.partnerConnected) return;
            if (selectedGameMode === 'versus' && !otherPlayer.id) {
                // Debug: log why we're not drawing
                if (Math.random() < 0.01) console.log('PvP: Not drawing opponent - no otherPlayer.id yet');
                return;
            }

            const colors = jetColors[otherPlayer.color] || jetColors.green;
            ctx.save();
            ctx.translate(otherPlayer.x, otherPlayer.y);

            // In versus mode, rotate opponent to face downward (toward player)
            if (selectedGameMode === 'versus') {
                ctx.rotate(Math.PI);  // 180 degree rotation
            }

            // If player is dead/respawning, draw as ghost
            if (!otherPlayer.isActive) {
                ctx.globalAlpha = 0.3;
                // Draw respawn timer
                const timeLeft = Math.ceil((COOP_RESPAWN_TIME - (Date.now() - otherPlayer.respawnStartTime)) / 1000);
                if (timeLeft > 0) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(timeLeft + 's', 0, -40);
                }
            }

            // Invincibility flash
            if (otherPlayer.isInvincible) {
                const flash = Math.sin(Date.now() / 50) > 0;
                if (!flash) {
                    ctx.globalAlpha *= 0.5;
                }
            }

            // Shield effect
            if (otherPlayer.shieldActive) {
                const pulse = 0.4 + Math.sin(Date.now() / 100) * 0.4;
                ctx.strokeStyle = `rgba(0, 255, 255, ${pulse})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, 40, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw jet body
            ctx.fillStyle = colors.body;
            ctx.beginPath();
            ctx.moveTo(0, -25); ctx.lineTo(-20, 25); ctx.lineTo(-8, 20);
            ctx.lineTo(-8, 25); ctx.lineTo(8, 25); ctx.lineTo(8, 20); ctx.lineTo(20, 25);
            ctx.closePath();
            ctx.fill();

            // Cockpit
            ctx.fillStyle = colors.cockpit;
            ctx.beginPath();
            ctx.ellipse(0, -5, 6, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wings
            ctx.fillStyle = colors.wings;
            ctx.beginPath();
            ctx.moveTo(-8, 5); ctx.lineTo(-30, 20); ctx.lineTo(-8, 15);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(8, 5); ctx.lineTo(30, 20); ctx.lineTo(8, 15);
            ctx.closePath();
            ctx.fill();

            // Engine flame
            if (otherPlayer.isActive) {
                ctx.fillStyle = '#ff6b35';
                ctx.beginPath();
                ctx.moveTo(-5, 25);
                ctx.lineTo(0, 35 + Math.sin(Date.now() / 50) * 2.5 + 2.5);
                ctx.lineTo(5, 25);
                ctx.closePath();
                ctx.fill();
            }

            // Player name label (restore rotation for text in versus mode)
            ctx.globalAlpha = 1;
            ctx.fillStyle = colors.body;
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            if (selectedGameMode === 'versus') {
                ctx.rotate(Math.PI);  // Un-rotate for readable text
                ctx.fillText(otherPlayer.name, 0, -45);  // Adjust position
            } else {
                ctx.fillText(otherPlayer.name, 0, 45);
            }

            ctx.restore();
        }

        function drawEnemy(enemy) {
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            ctx.rotate(Math.PI);

            // Color based on weapon
            const weaponColors = { pistol: '#e74c3c', machinegun: '#f1c40f', bazooka: '#e67e22' };
            ctx.fillStyle = weaponColors[enemy.weapon] || '#e74c3c';

            ctx.beginPath();
            ctx.moveTo(0, -20); ctx.lineTo(-15, 20); ctx.lineTo(-5, 15);
            ctx.lineTo(5, 15); ctx.lineTo(15, 20);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#c0392b';
            ctx.beginPath();
            ctx.moveTo(-5, 0); ctx.lineTo(-25, 15); ctx.lineTo(-5, 10);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(5, 0); ctx.lineTo(25, 15); ctx.lineTo(5, 10);
            ctx.closePath();
            ctx.fill();

            // Weapon indicator
            if (enemy.weapon === 'machinegun') {
                ctx.fillStyle = '#fff';
                ctx.fillRect(-8, 15, 4, 8);
                ctx.fillRect(4, 15, 4, 8);
            } else if (enemy.weapon === 'bazooka') {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, 18, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawBullet(bullet) {
            if (bullet.type === 'bazooka') {
                ctx.fillStyle = 'rgba(255, 100, 0, 0.4)';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffcc00';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
                ctx.fill();
            } else if (bullet.type === 'machinegun') {
                const col = bullet.isEnemy ? '#ffaa00' : '#ffff00';
                ctx.fillStyle = col + '4d';
                ctx.fillRect(bullet.x - 3, bullet.y - 6, 6, 12);
                ctx.fillStyle = col;
                ctx.fillRect(bullet.x - 2, bullet.y - 5, 4, 10);
            } else if (bullet.type === 'flak') {
                // Small orange pellets
                ctx.fillStyle = 'rgba(255, 136, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff8800';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                ctx.fill();
            } else if (bullet.type === 'disc') {
                // Spinning green disc
                ctx.save();
                ctx.translate(bullet.x, bullet.y);
                ctx.rotate(Date.now() * 0.01);
                ctx.fillStyle = 'rgba(0, 255, 136, 0.4)';
                ctx.beginPath();
                ctx.arc(0, 0, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#00ff88';
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-6, 0);
                ctx.lineTo(6, 0);
                ctx.moveTo(0, -6);
                ctx.lineTo(0, 6);
                ctx.stroke();
                ctx.restore();
            } else if (bullet.type === 'swarm') {
                // Small homing missiles
                ctx.save();
                ctx.translate(bullet.x, bullet.y);
                // Rotate based on velocity
                const angle = Math.atan2(bullet.vy, bullet.vx);
                ctx.rotate(angle + Math.PI / 2);
                // Missile body
                ctx.fillStyle = '#ff00ff';
                ctx.beginPath();
                ctx.moveTo(0, -6);
                ctx.lineTo(-3, 4);
                ctx.lineTo(3, 4);
                ctx.closePath();
                ctx.fill();
                // Exhaust
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.moveTo(-2, 4);
                ctx.lineTo(0, 8 + Math.random() * 4);
                ctx.lineTo(2, 4);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            } else {
                const color = bullet.isEnemy ? '#ff4444' : '#00ffff';
                const glow = bullet.isEnemy ? 'rgba(255, 68, 68, 0.3)' : 'rgba(0, 255, 255, 0.3)';
                ctx.fillStyle = glow;
                ctx.fillRect(bullet.x - 4, bullet.y - 10, 8, 20);
                ctx.fillStyle = color;
                ctx.fillRect(bullet.x - 2, bullet.y - 8, 4, 16);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(bullet.x - 1, bullet.y - 6, 2, 12);
            }
        }

        function getLaserEndY() {
            // Find the lowest wall that blocks the laser (closest to player)
            let endY = 0; // Top of screen by default
            const laserLeft = player.x - 15;
            const laserRight = player.x + 15;

            for (const wall of walls) {
                // Check if wall is in the laser's horizontal path
                if (wall.x < laserRight && wall.x + wall.width > laserLeft) {
                    // Check if wall is above the player
                    if (wall.y + wall.height < player.y - 25) {
                        // Find the bottom of this wall (where laser would hit)
                        const wallBottom = wall.y + wall.height;
                        if (wallBottom > endY) {
                            endY = wallBottom; // Laser stops at bottom of wall
                        }
                    }
                }
            }
            return endY;
        }

        function drawLaser() {
            if (!laserActive || currentWeapon !== 'laser') return;
            const laserEndY = getLaserEndY();
            const gradient = ctx.createLinearGradient(player.x, laserEndY, player.x, player.y);
            gradient.addColorStop(0, 'rgba(255, 0, 255, 0)');
            gradient.addColorStop(0.5, 'rgba(255, 0, 255, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 100, 255, 1)');
            ctx.fillStyle = 'rgba(255, 0, 255, 0.2)';
            ctx.fillRect(player.x - 15, laserEndY, 30, player.y - 25 - laserEndY);
            ctx.fillStyle = gradient;
            ctx.fillRect(player.x - 8, laserEndY, 16, player.y - 25 - laserEndY);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(player.x - 3, laserEndY, 6, player.y - 25 - laserEndY);
            // Draw impact spark at wall
            if (laserEndY > 0) {
                createExplosion(player.x, laserEndY, '#ff00ff', 2);
            }
        }

        function drawBomb(bomb) {
            ctx.save();
            ctx.translate(bomb.x, bomb.y);
            ctx.rotate(bomb.rotation);

            // Player bombs are cyan/blue, enemy bombs are orange/red
            if (bomb.isPlayerBomb) {
                // Player bomb - cyan glow
                ctx.fillStyle = 'rgba(0, 200, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#00aaff';
                ctx.beginPath();
                ctx.arc(0, 0, 14, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#003366';
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                // Timer indicator - pulsing based on time remaining
                const timerRatio = bomb.timer / bomb.fuseTime;
                const flash = Math.sin(Date.now() * 0.02 * (1 + timerRatio * 5)) > 0;
                ctx.fillStyle = flash ? '#ffffff' : '#00ffff';
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Enemy bomb - orange/red
                ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(0, 0, 18, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(0, 0, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff4400';
                ctx.fillRect(-3, -15, 6, 6);
                const flicker = Math.sin(Date.now() / 50) > 0;
                ctx.fillStyle = flicker ? '#ffff00' : '#ff8800';
                ctx.beginPath();
                ctx.arc(0, -18, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawWall(wall) {
            ctx.fillStyle = '#555';
            ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            ctx.fillStyle = '#ff0000';
            for (let i = 0; i < wall.width; i += 20) {
                ctx.fillRect(wall.x + i, wall.y, 10, wall.height);
            }
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            ctx.strokeRect(wall.x, wall.y, wall.width, wall.height);
        }

        function drawPowerup(powerup) {
            ctx.save();
            ctx.translate(powerup.x, powerup.y);
            ctx.rotate(powerup.rotation);

            switch(powerup.type) {
                case 'shield':
                    // Green shield icon
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(0, -15);
                    ctx.lineTo(15, -5);
                    ctx.lineTo(15, 8);
                    ctx.lineTo(0, 18);
                    ctx.lineTo(-15, 8);
                    ctx.lineTo(-15, -5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(10, -2);
                    ctx.lineTo(10, 5);
                    ctx.lineTo(0, 12);
                    ctx.lineTo(-10, 5);
                    ctx.lineTo(-10, -2);
                    ctx.closePath();
                    ctx.fill();
                    break;

                case 'fullLife':
                    // Red heart - full life restore
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(-7, -5, 10, 0, Math.PI * 2);
                    ctx.arc(7, -5, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.moveTo(0, 15);
                    ctx.bezierCurveTo(-15, 0, -15, -10, 0, -10);
                    ctx.bezierCurveTo(15, -10, 15, 0, 0, 15);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('MAX', 0, 3);
                    break;

                case 'ghost':
                    // Ghost icon - transparent blue
                    ctx.fillStyle = 'rgba(100, 200, 255, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(0, -5, 12, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(100, 200, 255, 0.6)';
                    ctx.beginPath();
                    ctx.moveTo(-12, 0);
                    ctx.lineTo(-12, 12);
                    ctx.lineTo(-6, 8);
                    ctx.lineTo(0, 12);
                    ctx.lineTo(6, 8);
                    ctx.lineTo(12, 12);
                    ctx.lineTo(12, 0);
                    ctx.closePath();
                    ctx.fill();
                    // Ghost eyes
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(-5, -5, 3, 0, Math.PI * 2);
                    ctx.arc(5, -5, 3, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'lightning':
                    // Lightning bolt icon - electric yellow/blue
                    ctx.fillStyle = 'rgba(255, 255, 100, 0.4)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 18, 0, Math.PI * 2);
                    ctx.fill();
                    // Lightning bolt shape
                    ctx.fillStyle = '#ffff00';
                    ctx.strokeStyle = '#0088ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(3, -14);
                    ctx.lineTo(-8, 0);
                    ctx.lineTo(-2, 0);
                    ctx.lineTo(-5, 14);
                    ctx.lineTo(8, 0);
                    ctx.lineTo(2, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;

                case 'life1':
                case 'life2':
                case 'life3':
                    // +1, +2, +3 life icons - yellow/gold
                    const lifeAmount = powerup.type === 'life1' ? 1 : (powerup.type === 'life2' ? 2 : 3);
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 18, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(0, 0, 14, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000000';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('+' + lifeAmount, 0, 0);
                    break;
            }
            ctx.restore();
        }

        function drawWeaponPickup(wp) {
            ctx.save();
            ctx.translate(wp.x, wp.y);
            ctx.rotate(wp.rotation);
            const colors = {
                machinegun: '#ffff00', bazooka: '#ff6600', laser: '#ff00ff',
                flak: '#ff8800', disc: '#00ff88', swarm: '#ff00ff'
            };
            ctx.fillStyle = (colors[wp.type] || '#ffffff') + '33';
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = colors[wp.type] || '#ffffff';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const labels = {
                machinegun: 'MG', bazooka: 'BZ', laser: 'LS',
                flak: 'FK', disc: 'DC', swarm: 'SW'
            };
            ctx.fillText(labels[wp.type] || '?', 0, 0);
            ctx.restore();
        }

        function drawMine(mine) {
            ctx.save();
            ctx.translate(mine.x, mine.y);
            ctx.rotate(mine.rotation);
            // Pulsing effect
            const pulse = 0.8 + Math.sin(mine.pulsePhase) * 0.2;
            // Outer danger ring
            ctx.fillStyle = 'rgba(255, 50, 50, 0.3)';
            ctx.beginPath();
            ctx.arc(0, 0, 18 * pulse, 0, Math.PI * 2);
            ctx.fill();
            // Mine body - dark with spikes
            ctx.fillStyle = '#333333';
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.fill();
            // Spikes
            ctx.fillStyle = '#666666';
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.save();
                ctx.rotate(angle);
                ctx.fillRect(-3, -16, 6, 8);
                ctx.restore();
            }
            // Red warning light
            ctx.fillStyle = pulse > 1 ? '#ff0000' : '#aa0000';
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function createExplosion(x, y, color, count = 20) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y, vx: (Math.random() - 0.5) * 480, vy: (Math.random() - 0.5) * 480,
                    size: Math.random() * 4 + 2, color, life: 1
                });
            }
        }

        function createBigExplosion(x, y) {
            for (let i = 0; i < 50; i++) {
                const angle = (i / 50) * Math.PI * 2;
                const speed = 200 + Math.random() * 300;
                particles.push({
                    x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                    size: Math.random() * 6 + 3,
                    color: ['#ff4400', '#ffaa00', '#ffff00', '#ffffff'][Math.floor(Math.random() * 4)],
                    life: 1
                });
            }
        }

        // === SHOOTING ===
        // Switch to next weapon that has ammo
        function switchToNextAvailableWeapon() {
            // Try to find a weapon with ammo
            for (const w of unlockedWeapons) {
                if (w === 'pistol' || weaponAmmo[w] > 0) {
                    currentWeapon = w;
                    laserActive = false;
                    updateWeaponDisplay();
                    return;
                }
            }
            // Fallback to pistol (always available)
            currentWeapon = 'pistol';
            laserActive = false;
            updateWeaponDisplay();
        }

        function shoot() {
            // Ghost mode allows shooting now

            const now = Date.now();
            const weapon = WEAPONS[currentWeapon];
            if (now - lastFireTime < weapon.fireRate) return;

            // Check if we have ammo (pistol has infinite)
            if (currentWeapon !== 'pistol' && weaponAmmo[currentWeapon] <= 0) {
                switchToNextAvailableWeapon();
                return;
            }

            lastFireTime = now;

            // Deduct ammo (except pistol and laser which uses time-based consumption)
            if (currentWeapon !== 'pistol' && currentWeapon !== 'laser') {
                weaponAmmo[currentWeapon]--;
                if (weaponAmmo[currentWeapon] <= 0) {
                    // Will auto-switch on next shot attempt
                }
            }

            const bulletMult = getSpeedMultiplier();
            if (currentWeapon === 'pistol') {
                bullets.push({ x: player.x, y: player.y - 25, speed: 600 * bulletMult, isEnemy: false, type: 'pistol', width: 10, height: 20 });
                playPlayerLaser();
            } else if (currentWeapon === 'machinegun') {
                bullets.push({ x: player.x - 8, y: player.y - 20, speed: 800 * bulletMult, isEnemy: false, type: 'machinegun', width: 8, height: 12 });
                bullets.push({ x: player.x + 8, y: player.y - 20, speed: 800 * bulletMult, isEnemy: false, type: 'machinegun', width: 8, height: 12 });
                playMachineGun();
            } else if (currentWeapon === 'bazooka') {
                bullets.push({ x: player.x, y: player.y - 25, speed: 400 * bulletMult, isEnemy: false, type: 'bazooka', width: 20, height: 20, explosive: true });
                playBazooka();
            } else if (currentWeapon === 'laser') {
                laserActive = true;
                playLaserBeam();
            } else if (currentWeapon === 'flak') {
                // Flak cannon - fires 8 pellets in a spread
                playFlakSound();
                for (let i = 0; i < 8; i++) {
                    const baseAngle = -90; // up
                    const angle = baseAngle + (i - 3.5) * 4 + (Math.random() - 0.5) * 10;
                    const rad = angle * Math.PI / 180;
                    bullets.push({
                        x: player.x,
                        y: player.y - 20,
                        vx: Math.cos(rad) * 12 * bulletMult,
                        vy: Math.sin(rad) * 12 * bulletMult,
                        speed: 0, // uses vx/vy instead
                        isEnemy: false,
                        type: 'flak',
                        width: 6,
                        height: 6,
                        damage: 15,
                        maxDistance: 300,
                        startY: player.y
                    });
                }
            } else if (currentWeapon === 'disc') {
                // Disc launcher - bounces off walls
                playDiscSound();
                bullets.push({
                    x: player.x,
                    y: player.y - 20,
                    vx: 0,
                    vy: -10 * bulletMult,
                    speed: 0,
                    isEnemy: false,
                    type: 'disc',
                    width: 20,
                    height: 20,
                    damage: 40,
                    bouncesLeft: 3,
                    hitEnemies: []
                });
            } else if (currentWeapon === 'swarm') {
                // Swarm missiles - 5 homing missiles
                playSwarmSound();
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        if (!gameRunning) return;
                        bullets.push({
                            x: player.x + (i - 2) * 10,
                            y: player.y - 20,
                            vx: (Math.random() - 0.5) * 4,
                            vy: -6 * bulletMult,
                            speed: 0,
                            isEnemy: false,
                            type: 'swarm',
                            width: 8,
                            height: 12,
                            damage: 25,
                            target: null,
                            homingStrength: 0.15
                        });
                    }, i * 50);
                }
            }

            updateWeaponDisplay();

            // Broadcast to partner/opponent in multiplayer modes
            if (isMultiplayer && (selectedGameMode === 'coop' || selectedGameMode === 'versus')) {
                console.log('PvP: I shot at', Math.round(player.x), Math.round(player.y - 25), 'myPlayerId:', myPlayerId);
                broadcastShoot(player.x, player.y - 25, currentWeapon);
            }
        }

        function enemyShoot(enemy) {
            const diff = getDiffSettings();
            const speed = -200 * getSpeedMultiplier();

            if (enemy.weapon === 'machinegun') {
                bullets.push({ x: enemy.x - 6, y: enemy.y + 20, speed: speed * 1.2, isEnemy: true, type: 'machinegun', width: 8, height: 12 });
                bullets.push({ x: enemy.x + 6, y: enemy.y + 20, speed: speed * 1.2, isEnemy: true, type: 'machinegun', width: 8, height: 12 });
                playEnemyMachineGun();
            } else if (enemy.weapon === 'bazooka') {
                bullets.push({ x: enemy.x, y: enemy.y + 20, speed: speed * 0.7, isEnemy: true, type: 'bazooka', width: 20, height: 20, explosive: true });
                playEnemyBazooka();
            } else if (enemy.weapon === 'spread') {
                // 3 bullets in a spread pattern
                for (let i = -1; i <= 1; i++) {
                    const angle = i * 15 * Math.PI / 180;
                    bullets.push({
                        x: enemy.x,
                        y: enemy.y + 20,
                        vx: Math.sin(angle) * Math.abs(speed) * 0.3,
                        vy: -Math.abs(speed) * 0.8,
                        speed: 0,
                        isEnemy: true,
                        type: 'pistol',
                        width: 10,
                        height: 20
                    });
                }
                playEnemyLaser();
            } else if (enemy.weapon === 'aimed') {
                // Aimed at player
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const bulletSpeed = Math.abs(speed);
                bullets.push({
                    x: enemy.x,
                    y: enemy.y + 20,
                    vx: (dx / dist) * bulletSpeed * 0.6,
                    vy: (dy / dist) * bulletSpeed * 0.6,
                    speed: 0,
                    isEnemy: true,
                    type: 'pistol',
                    width: 10,
                    height: 20
                });
                playEnemyLaser();
            } else if (enemy.weapon === 'burst') {
                // 3 shots in quick succession
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        if (!enemy || !gameRunning) return;
                        bullets.push({
                            x: enemy.x,
                            y: enemy.y + 20,
                            speed: speed,
                            isEnemy: true,
                            type: 'pistol',
                            width: 10,
                            height: 20
                        });
                    }, i * 100);
                }
                playEnemyLaser();
            } else {
                bullets.push({ x: enemy.x, y: enemy.y + 20, speed: speed, isEnemy: true, type: 'pistol', width: 10, height: 20 });
                playEnemyLaser();
            }
        }

        function switchWeapon() {
            if (unlockedWeapons.length <= 1) return;
            const idx = unlockedWeapons.indexOf(currentWeapon);
            currentWeapon = unlockedWeapons[(idx + 1) % unlockedWeapons.length];
            laserActive = false;
            updateWeaponDisplay();
        }

        // Player drops a bomb (B key)
        function dropPlayerBomb() {
            const now = Date.now();
            if (playerBombs <= 0) return;
            if (now - lastPlayerBombTime < PLAYER_BOMB_COOLDOWN) return;

            playerBombs--;
            lastPlayerBombTime = now;

            // Create player bomb - drops upward into enemies
            bombs.push({
                x: player.x,
                y: player.y - 30,
                width: 30,
                height: 30,
                speed: -150 * getSpeedMultiplier(), // Goes up
                rotation: 0,
                isPlayerBomb: true,
                timer: 0,
                fuseTime: 1500 // 1.5 seconds until explosion
            });

            playBazooka();
        }

        function updateWeaponDisplay() {
            const wpnList = unlockedWeapons.map(w => {
                const ammo = w === 'pistol' ? '‚àû' : weaponAmmo[w];
                if (w === currentWeapon) {
                    return `[${WEAPONS[w].name}:${ammo}]`;
                }
                return `${WEAPONS[w].name.charAt(0)}:${ammo}`;
            }).join(' ');
            document.getElementById('weaponDisplay').textContent = wpnList + ' [Q]';

            // Update weapon panel
            updateWeaponPanel();
        }

        function updateWeaponPanel() {
            const panel = document.getElementById('weaponPanel');
            if (!panel) return;

            // Weapon icons for compact display
            const weaponIcons = {
                pistol: 'üî´',
                machinegun: 'üî•',
                bazooka: 'üöÄ',
                laser: '‚ö°',
                flak: 'üí•',
                disc: 'üíø',
                swarm: 'üéØ'
            };

            // All possible weapons in order
            const allWeapons = ['pistol', 'machinegun', 'bazooka', 'laser', 'flak', 'disc', 'swarm'];

            // Filter to only show weapons the player has unlocked AND has ammo for
            const availableWeapons = allWeapons.filter(weaponKey => {
                if (!unlockedWeapons.includes(weaponKey)) return false;
                if (weaponKey === 'pistol') return true; // Always show pistol
                return weaponAmmo[weaponKey] > 0; // Only show if has ammo
            });

            panel.innerHTML = availableWeapons.map((weaponKey) => {
                const weapon = WEAPONS[weaponKey];
                const ammo = weaponKey === 'pistol' ? Infinity : weaponAmmo[weaponKey];
                const isActive = currentWeapon === weaponKey;
                const ammoDisplay = ammo === Infinity ? '‚àû' : ammo;
                const icon = weaponIcons[weaponKey] || '?';

                // Determine slot classes
                let classes = 'weapon-slot';
                if (isActive) classes += ' active';
                if (ammo !== Infinity && ammo <= 10) classes += ' low-ammo';

                return `
                    <div class="${classes}" data-weapon="${weaponKey}" title="${weapon.name}">
                        <div class="weapon-icon">${icon}</div>
                        <div class="weapon-ammo">${ammoDisplay}</div>
                    </div>
                `;
            }).join('');

            // Add touch/click event listeners (using event delegation)
            panel.onclick = panel.ontouchend = function(e) {
                e.preventDefault();
                const slot = e.target.closest('.weapon-slot[data-weapon]');
                if (slot) {
                    const weaponKey = slot.dataset.weapon;
                    switchToWeapon(weaponKey);
                }
            };
        }

        function switchToWeapon(weaponKey) {
            if (!unlockedWeapons.includes(weaponKey)) return;
            if (weaponKey !== 'pistol' && weaponAmmo[weaponKey] <= 0) return;

            currentWeapon = weaponKey;
            laserActive = (weaponKey === 'laser');
            updateWeaponDisplay();
            playSound(800, 'sine', 0.05, 0.1); // Click sound
        }

        function checkCollision(a, b) {
            return Math.abs(a.x - b.x) < ((a.width || 10) + (b.width || 10)) / 2 &&
                   Math.abs(a.y - b.y) < ((a.height || 10) + (b.height || 10)) / 2;
        }

        function checkWallCollision(obj, wall) {
            return obj.x > wall.x && obj.x < wall.x + wall.width &&
                   obj.y > wall.y && obj.y < wall.y + wall.height;
        }

        // === UPDATE ===
        function updateParticles(dt) {
            particles = particles.filter(p => {
                p.x += p.vx * dt; p.y += p.vy * dt;
                p.life -= 1.5 * dt; p.size *= Math.pow(0.1, dt);
                return p.life > 0;
            });
        }

        function activateShield() {
            const wasActive = shieldActive;
            shieldActive = true;
            shieldHits = shieldMaxHits;
            shieldStartTime = Date.now();
            if (!wasActive && !isMuted) startBackgroundMusic(true);
        }

        function deactivateShield() {
            shieldActive = false;
            shieldHits = 0;
            if (!isMuted && gameRunning) startBackgroundMusic(false);
        }

        function activateGhost() {
            ghostActive = true;
            ghostStartTime = Date.now();
        }

        function deactivateGhost() {
            ghostActive = false;
        }

        // Lightning state
        let lightningFlashAlpha = 0;

        function activateLightning() {
            // Flash screen white
            lightningFlashAlpha = 1.0;

            // Kill all enemies on screen
            const killedCount = enemies.length;
            enemies.forEach(e => {
                createExplosion(e.x, e.y, '#ffff00');
                score += 100;
            });
            enemies = [];
            totalEnemiesKilled += killedCount;
            killsThisLevel += killedCount;
            document.getElementById('score').textContent = score;

            // 3x damage to boss (equivalent to 3 regular bullets worth of damage)
            if (boss) {
                const lightningDamage = 3; // 3x a regular hit
                damageBoss(lightningDamage);
                createExplosion(boss.x, boss.y, '#ffff00');
                createExplosion(boss.x - 30, boss.y + 20, '#00aaff');
                createExplosion(boss.x + 30, boss.y + 20, '#00aaff');
            }

            // Play thunder sound (reuse explosion with higher pitch feel)
            playExplosion();

            // Check level up after killing enemies
            checkLevelUp();
        }

        function updateLightningFlash(dt) {
            if (lightningFlashAlpha > 0) {
                lightningFlashAlpha -= dt * 3; // Fade out over ~0.33 seconds
                if (lightningFlashAlpha < 0) lightningFlashAlpha = 0;
            }
        }

        function drawLightningFlash() {
            if (lightningFlashAlpha > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${lightningFlashAlpha})`;
                ctx.fillRect(0, 0, logicalWidth, logicalHeight);
            }
        }

        function checkLevelUp() {
            // Boss spawns after 25 kills in current level
            if (!bossActive && killsThisLevel >= KILLS_FOR_BOSS) {
                // Check if boss for current level has been defeated
                if (!bossDefeated.includes(level)) {
                    // Spawn boss for current level
                    spawnBoss(level);
                } else if (level < 6) {
                    // Boss already defeated, advance to next level
                    level++;
                    killsThisLevel = 0; // Reset kills for new level
                    continuesUsedThisLevel = 0; // Reset continues for new level
                    savedLevelScore = score; // Save score at level start
                    saveGameProgress(); // Save progress for authenticated users
                    document.getElementById('levelDisplay').textContent = level <= 5 ? 'Level ' + level : 'FINAL LEVEL';
                    playLevelUp();
                    createExplosion(logicalWidth / 2, logicalHeight / 2, '#ffd700', 40);
                }
            }
        }

        function update(dt) {
            if (!gameRunning || gamePaused) return;

            // Decrement player hit flash timer
            if (playerHitFlash > 0) {
                playerHitFlash -= dt * 1000; // dt is in seconds, convert to ms
                if (playerHitFlash < 0) playerHitFlash = 0;
            }

            const diff = getDiffSettings();

            // Update boss if active
            if (bossActive && boss) {
                updateBoss(dt);
            }

            // Player movement
            let pdx = 0, pdy = 0;
            if (keys['ArrowLeft'] || keys['KeyA']) pdx = -1;
            else if (keys['ArrowRight'] || keys['KeyD']) pdx = 1;
            if (keys['ArrowUp'] || keys['KeyW']) pdy = -1;
            else if (keys['ArrowDown'] || keys['KeyS']) pdy = 1;

            if (joystickActive) { pdx = touchMove.x; pdy = touchMove.y; }

            const playerSpeedMult = getSpeedMultiplier();
            player.x += pdx * player.speed * playerSpeedMult * dt;
            // During boss fight, limit vertical movement to bottom half
            if (bossActive) {
                player.y += pdy * player.speed * playerSpeedMult * dt * 0.5; // Slower vertical
                player.y = Math.max(logicalHeight / 2 + 50, Math.min(logicalHeight - 30, player.y));
            } else {
                player.y += pdy * player.speed * playerSpeedMult * dt;
                player.y = Math.max(30, Math.min(logicalHeight - 30, player.y));
            }
            player.x = Math.max(30, Math.min(logicalWidth - 30, player.x));

            // Removed: autoFire for continuous shooting - now tap-only

            // Laser damage (blocked by walls)
            if (laserActive && currentWeapon === 'laser') {
                // Consume laser ammo (1 per second)
                laserAmmoTimer += dt * 1000;
                if (laserAmmoTimer >= 1000) {
                    laserAmmoTimer = 0;
                    weaponAmmo.laser--;
                    updateWeaponDisplay();
                    if (weaponAmmo.laser <= 0) {
                        laserActive = false;
                        switchToNextAvailableWeapon();
                    }
                }

                const laserEndY = getLaserEndY();
                // Damage enemies (only those below wall blocking point)
                enemies = enemies.filter(enemy => {
                    if (enemy.x > player.x - 15 && enemy.x < player.x + 15 && enemy.y < player.y && enemy.y > laserEndY) {
                        score += 100;
                        totalEnemiesKilled++;
                        killsThisLevel++;
                        document.getElementById('score').textContent = score;
                        createExplosion(enemy.x, enemy.y, '#ff00ff');
                        playExplosion();
                        checkLevelUp();
                        return false;
                    }
                    return true;
                });
                // Damage boss (only if not blocked by wall)
                if (boss && boss.x > player.x - 15 && boss.x < player.x + 15 && boss.y < player.y && boss.y > laserEndY) {
                    damageBoss(0.5 * dt * 60); // Continuous damage
                }
            }

            // Update bullets
            bullets = bullets.filter(b => {
                // Handle bullets with vx/vy (flak, disc, swarm) vs speed-based
                if (b.vx !== undefined || b.vy !== undefined) {
                    b.x += (b.vx || 0) * dt * 60;
                    b.y += (b.vy || 0) * dt * 60;
                } else {
                    b.y -= b.speed * dt;
                }

                // Disc bouncing logic
                if (b.type === 'disc') {
                    if (b.x < 10 || b.x > logicalWidth - 10) {
                        b.vx *= -1;
                        b.bouncesLeft--;
                        b.hitEnemies = []; // Can re-hit enemies after bounce
                        playDiscBounceSound();
                        if (b.bouncesLeft < 0) return false;
                    }
                    // Also bounce off top
                    if (b.y < 10) {
                        b.vy *= -1;
                        b.bouncesLeft--;
                        b.hitEnemies = [];
                        playDiscBounceSound();
                        if (b.bouncesLeft < 0) return false;
                    }
                }

                // Swarm homing logic
                if (b.type === 'swarm' && !b.isEnemy) {
                    // Find nearest enemy or boss
                    let nearestTarget = null;
                    let nearestDist = Infinity;

                    enemies.forEach(e => {
                        const dist = Math.hypot(e.x - b.x, e.y - b.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestTarget = e;
                        }
                    });

                    // Also target boss
                    if (boss) {
                        const dist = Math.hypot(boss.x - b.x, boss.y - b.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestTarget = boss;
                        }
                    }

                    if (nearestTarget) {
                        const dx = nearestTarget.x - b.x;
                        const dy = nearestTarget.y - b.y;
                        b.vx += Math.sign(dx) * b.homingStrength;
                        b.vy += Math.sign(dy) * b.homingStrength;
                        // Normalize speed
                        const speed = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
                        if (speed > 0) {
                            b.vx = (b.vx / speed) * 8;
                            b.vy = (b.vy / speed) * 8;
                        }
                    }
                }

                // Flak range limit
                if (b.type === 'flak' && b.startY !== undefined) {
                    if (Math.abs(b.y - b.startY) > b.maxDistance) return false;
                }

                return b.y > -20 && b.y < logicalHeight + 20 && b.x > -20 && b.x < logicalWidth + 20;
            });

            // Update enemies
            enemies.forEach(e => {
                e.y += e.speed * dt;
                e.shootTimer -= dt;
                const fireRate = e.weapon === 'machinegun' ? 0.3 : (e.weapon === 'bazooka' ? 1.5 : 0.8);
                if (e.shootTimer <= 0) {
                    enemyShoot(e);
                    e.shootTimer = fireRate / diff.enemyFireMult + Math.random() * 0.5;
                }
            });
            // Enemy-wall collision: enemies explode when hitting walls
            enemies = enemies.filter(e => {
                for (const wall of walls) {
                    const eLeft = e.x - e.width / 2;
                    const eRight = e.x + e.width / 2;
                    const eTop = e.y - e.height / 2;
                    const eBottom = e.y + e.height / 2;
                    if (eRight > wall.x && eLeft < wall.x + wall.width &&
                        eBottom > wall.y && eTop < wall.y + wall.height) {
                        // Enemy hit wall - explode!
                        createExplosion(e.x, e.y, '#ff6600', 25);
                        playExplosion();
                        return false;
                    }
                }
                return true;
            });
            enemies = enemies.filter(e => e.y < logicalHeight + 50);

            // Update walls
            walls.forEach(w => w.y += w.speed * dt);
            walls = walls.filter(w => w.y < logicalHeight + 50);

            // Update powerups
            powerups.forEach(p => { p.y += p.speed * dt; p.rotation += 3 * dt; });
            powerups = powerups.filter(p => p.y < logicalHeight + 50);

            // Update bombs
            bombs = bombs.filter(b => {
                b.y += b.speed * dt;
                b.rotation += 2 * dt;

                // Player bombs have timer and explode
                if (b.isPlayerBomb) {
                    b.timer += dt * 1000;
                    // Explode on timer or if goes off top
                    if (b.timer >= b.fuseTime || b.y < -30) {
                        // Big explosion that damages enemies
                        createBigExplosion(b.x, b.y);
                        playBigExplosion();
                        // Damage enemies in radius
                        enemies = enemies.filter(e => {
                            const dist = Math.hypot(e.x - b.x, e.y - b.y);
                            if (dist < 120) {
                                score += 100;
                                totalEnemiesKilled++;
                                killsThisLevel++;
                                createExplosion(e.x, e.y, '#ff6600');
                                return false;
                            }
                            return true;
                        });
                        // Damage boss if nearby
                        if (boss) {
                            const dist = Math.hypot(boss.x - b.x, boss.y - b.y);
                            if (dist < 150) {
                                damageBoss(10);
                            }
                        }
                        document.getElementById('score').textContent = score;
                        checkLevelUp();
                        return false; // Remove bomb
                    }
                    // Player bombs go up and off screen
                    return b.y > -50;
                }

                // Enemy bombs fall down
                return b.y < logicalHeight + 50;
            });

            // Update mines (float left/right as they descend)
            mines.forEach(m => {
                m.y += m.speed * dt;
                m.x += m.vx * dt;
                m.rotation += 1 * dt;
                m.pulsePhase += 5 * dt;
                // Bounce off edges
                if (m.x < 20 || m.x > logicalWidth - 20) m.vx *= -1;
            });
            mines = mines.filter(m => m.y < logicalHeight + 50);

            // Update weapon pickups
            weaponPickups.forEach(w => { w.y += w.speed * dt; w.rotation += 2 * dt; });
            weaponPickups = weaponPickups.filter(w => w.y < logicalHeight + 50);

            // Bullet-wall collisions - walls block ALL bullets
            bullets = bullets.filter(bullet => {
                for (const wall of walls) {
                    if (bullet.x > wall.x && bullet.x < wall.x + wall.width &&
                        bullet.y > wall.y && bullet.y < wall.y + wall.height) {
                        createExplosion(bullet.x, bullet.y, '#888888', 5);
                        return false; // Remove bullet
                    }
                }
                return true; // Keep bullet
            });

            // Bullet-enemy collisions
            bullets.forEach((bullet, bi) => {
                if (bullet.isEnemy) {
                    // Ghost mode: enemy bullets pass through player
                    if (ghostActive) return;

                    if (checkCollision(bullet, player)) {
                        bullets.splice(bi, 1);
                        if (bullet.explosive) {
                            createBigExplosion(bullet.x, bullet.y);
                            playBigExplosion();
                        }
                        if (shieldActive) {
                            shieldHits--; createExplosion(player.x, player.y, '#00ffff');
                            if (shieldHits <= 0) deactivateShield();
                        } else if (!isInvincible && canTakeDamage()) {
                            if (isMultiplayer && selectedGameMode === 'versus') {
                                // PvP mode - take damage from enemy bullets
                                takePvPDamage(PVP_BULLET_DAMAGE);
                            } else {
                                lives--;
                                playerHitFlash = 200; // Flash for 200ms
                                playOuchSound();
                                document.getElementById('lives').textContent = lives;
                                createExplosion(player.x, player.y, jetColors[selectedColor].body);
                                playExplosion();
                                if (lives <= 0) {
                                    const deathReason = bullet.type === 'boss' ? 'killed_by_boss' : 'killed_by_drone';
                                    reportAction(deathReason);
                                    handlePlayerDeath(deathReason);
                                }
                            }
                        }
                    }
                } else {
                    enemies.forEach((enemy, ei) => {
                        if (checkCollision(bullet, enemy)) {
                            if (bullet.explosive) {
                                createBigExplosion(bullet.x, bullet.y);
                                playBigExplosion();
                                enemies = enemies.filter(e => {
                                    const dist = Math.hypot(e.x - bullet.x, e.y - bullet.y);
                                    if (dist < 100) { score += 100; totalEnemiesKilled++; killsThisLevel++; createExplosion(e.x, e.y, '#e74c3c'); return false; }
                                    return true;
                                });
                                bullets.splice(bi, 1);
                            } else {
                                bullets.splice(bi, 1);
                                enemies.splice(ei, 1);
                                score += 100;
                                totalEnemiesKilled++;
                                killsThisLevel++;
                                createExplosion(enemy.x, enemy.y, '#e74c3c');
                                playExplosion();
                            }
                            document.getElementById('score').textContent = score;
                            checkLevelUp();
                        }
                    });

                    bombs.forEach((bomb, bmi) => {
                        if (checkCollision(bullet, bomb)) {
                            bullets.splice(bi, 1);
                            bombs.splice(bmi, 1);
                            createBigExplosion(bomb.x, bomb.y);
                            playBigExplosion();
                            enemies = enemies.filter(e => {
                                const dist = Math.hypot(e.x - bomb.x, e.y - bomb.y);
                                if (dist < 120) { score += 100; totalEnemiesKilled++; killsThisLevel++; createExplosion(e.x, e.y, '#ff6600'); return false; }
                                return true;
                            });
                            document.getElementById('score').textContent = score;
                            checkLevelUp();
                        }
                    });

                    // Boss collision
                    if (boss && !bullet.isEnemy) {
                        const bossCollision = Math.abs(bullet.x - boss.x) < boss.width / 2 &&
                                              Math.abs(bullet.y - boss.y) < boss.height / 2;
                        if (bossCollision) {
                            bullets.splice(bi, 1);
                            const damage = bullet.explosive ? 5 : (bullet.type === 'bazooka' ? 3 : 1);
                            damageBoss(damage);
                            if (bullet.explosive) {
                                createBigExplosion(bullet.x, bullet.y);
                                playBigExplosion();
                            }
                        }
                    }
                }
            });

            // Player-enemy collision (ghost mode: pass through enemies)
            if (!ghostActive) {
                enemies.forEach((enemy, ei) => {
                    if (checkCollision(enemy, player)) {
                        enemies.splice(ei, 1);
                        createExplosion(enemy.x, enemy.y, '#e74c3c');
                        if (shieldActive) {
                            shieldHits--; createExplosion(player.x, player.y, '#00ffff');
                            if (shieldHits <= 0) deactivateShield();
                        } else if (!isInvincible && canTakeDamage()) {
                            if (isMultiplayer && selectedGameMode === 'versus') {
                                // PvP mode - take damage from enemy collision
                                takePvPDamage(PVP_BULLET_DAMAGE);
                            } else {
                                lives--;
                                playerHitFlash = 200; // Flash for 200ms
                                playOuchSound();
                                document.getElementById('lives').textContent = lives;
                                createExplosion(player.x, player.y, jetColors[selectedColor].body);
                                playExplosion();
                                if (lives <= 0) {
                                    reportAction('killed_by_drone');
                                    handlePlayerDeath('killed_by_drone');
                                }
                            }
                        }
                    }
                });
            }

            // === PVP COLLISIONS (True PvP - Health Based) ===
            if (isMultiplayer && selectedGameMode === 'versus' && versusState.roundActive && !versusState.roundStartCountdown) {
                // Check if our bullets hit opponent (deal damage to them)
                for (let bi = bullets.length - 1; bi >= 0; bi--) {
                    const bullet = bullets[bi];
                    if (bullet.isEnemy || bullet.fromPartner) continue;  // Only our bullets

                    // Create hitbox for opponent
                    const opponentHitbox = {
                        x: otherPlayer.x - 25,
                        y: otherPlayer.y - 25,
                        width: 50,
                        height: 50
                    };

                    if (checkCollision(bullet, opponentHitbox) && otherPlayer.isActive && !versusState.opponentInvulnerable) {
                        bullets.splice(bi, 1);
                        createExplosion(otherPlayer.x, otherPlayer.y, jetColors[otherPlayer.color || 'blue'].body);
                        playExplosion();

                        // Deal PvP damage to opponent
                        dealPvPDamage(PVP_BULLET_DAMAGE);
                    }
                }

                // Check if opponent's bullets hit us (we take damage)
                for (let bi = bullets.length - 1; bi >= 0; bi--) {
                    const bullet = bullets[bi];
                    if (!bullet.fromPartner) continue;  // Only opponent's bullets

                    if (checkCollision(bullet, player) && !ghostActive && !versusState.myInvulnerable) {
                        bullets.splice(bi, 1);

                        if (shieldActive) {
                            shieldHits--;
                            createExplosion(player.x, player.y, '#00ffff');
                            if (shieldHits <= 0) deactivateShield();
                        } else if (!isInvincible) {
                            // Take PvP damage
                            takePvPDamage(PVP_BULLET_DAMAGE);
                        }
                    }
                }

                // Check player-to-player collision (both take damage when crashing into each other)
                if (otherPlayer.isActive && !ghostActive && !otherPlayer.ghostActive &&
                    !versusState.myInvulnerable && !versusState.opponentInvulnerable) {
                    const opponentHitbox = {
                        x: otherPlayer.x - 25,
                        y: otherPlayer.y - 25,
                        width: 50,
                        height: 50
                    };

                    if (checkCollision(player, opponentHitbox)) {
                        // Collision! Both players take damage
                        console.log('PvP: Player collision detected!');
                        createExplosion((player.x + otherPlayer.x) / 2, (player.y + otherPlayer.y) / 2, '#ff6600');
                        playExplosion();

                        // We take damage
                        if (shieldActive) {
                            shieldHits--;
                            createExplosion(player.x, player.y, '#00ffff');
                            if (shieldHits <= 0) deactivateShield();
                        } else if (!isInvincible) {
                            takePvPDamage(PVP_BULLET_DAMAGE);
                        }

                        // Deal damage to opponent (if they don't have shield - their client handles shield)
                        dealPvPDamage(PVP_BULLET_DAMAGE);
                    }
                }
            }

            // Player-wall collision (ghost mode: pass through walls)
            if (!ghostActive) {
                walls.forEach(wall => {
                    if (checkWallCollision(player, wall)) {
                        if (shieldActive) {
                            shieldHits--; createExplosion(player.x, player.y, '#00ffff');
                            if (shieldHits <= 0) deactivateShield();
                        } else if (!isInvincible && canTakeDamage()) {
                            if (isMultiplayer && selectedGameMode === 'versus') {
                                // PvP wall collision - take damage
                                takePvPDamage(PVP_BULLET_DAMAGE);
                            } else {
                                lives--;
                                playerHitFlash = 200; // Flash for 200ms
                                playOuchSound();
                                document.getElementById('lives').textContent = lives;
                                createExplosion(player.x, player.y, jetColors[selectedColor].body);
                                playExplosion();
                                if (lives <= 0) {
                                    reportAction('crashed_wall');
                                    handlePlayerDeath('crashed_wall');
                                }
                            }
                        }
                        player.y = wall.y + wall.height + 30;
                    }
                });
            }

            // Powerup collection (can collect while ghost)
            powerups.forEach((p, pi) => {
                if (checkCollision(p, player)) {
                    powerups.splice(pi, 1);
                    const diff = getDiffSettings();
                    switch(p.type) {
                        case 'shield':
                            createExplosion(p.x, p.y, '#00ff00');
                            playPowerupCollect();
                            activateShield();
                            reportAction('got_shield');
                            break;
                        case 'fullLife':
                            createExplosion(p.x, p.y, '#ff0000');
                            playLifeUp();
                            lives = diff.lives; // Restore to max lives
                            document.getElementById('lives').textContent = lives;
                            reportAction('got_powerup');
                            break;
                        case 'ghost':
                            createExplosion(p.x, p.y, '#64c8ff');
                            playGhostActivate();
                            activateGhost();
                            reportAction('got_powerup');
                            break;
                        case 'lightning':
                            createExplosion(p.x, p.y, '#ffff00');
                            activateLightning();
                            reportAction('got_powerup');
                            break;
                        case 'life1':
                            createExplosion(p.x, p.y, '#ffd700');
                            playLifeUp();
                            lives += 1;
                            document.getElementById('lives').textContent = lives;
                            reportAction('got_powerup');
                            break;
                        case 'life2':
                            createExplosion(p.x, p.y, '#ffd700');
                            playLifeUp();
                            lives += 2;
                            document.getElementById('lives').textContent = lives;
                            reportAction('got_powerup');
                            break;
                        case 'life3':
                            createExplosion(p.x, p.y, '#ffd700');
                            playLifeUp();
                            lives += 3;
                            document.getElementById('lives').textContent = lives;
                            reportAction('got_powerup');
                            break;
                    }
                    // Award hazard points for powerup collection in versus mode
                    onPowerupCollected();
                }
            });

            // Weapon pickup collection (can collect while ghost)
            weaponPickups.forEach((w, wi) => {
                if (checkCollision(w, player)) {
                    weaponPickups.splice(wi, 1);
                    if (!unlockedWeapons.includes(w.type)) {
                        unlockedWeapons.push(w.type);
                    }
                    // Add ammo for the weapon (stackable)
                    if (w.type !== 'pistol') {
                        weaponAmmo[w.type] += AMMO_PER_PICKUP;
                    }
                    currentWeapon = w.type;
                    updateWeaponDisplay();
                    reportAction('got_' + w.type);
                    createExplosion(w.x, w.y, WEAPONS[w.type].color);
                    playPowerupCollect();
                    // Award hazard points for weapon pickup in versus mode
                    onPowerupCollected();
                }
            });

            // Mine collision - only if not ghost
            if (!ghostActive) {
                mines.forEach((m, mi) => {
                    if (checkCollision(m, player)) {
                        mines.splice(mi, 1);
                        createBigExplosion(m.x, m.y);
                        playMineExplosion();
                        if (shieldActive) {
                            shieldHits--;
                            createExplosion(player.x, player.y, '#00ffff');
                            if (shieldHits <= 0) deactivateShield();
                        } else if (!isInvincible && canTakeDamage()) {
                            if (isMultiplayer && selectedGameMode === 'versus') {
                                // PvP mode - take damage from mine
                                takePvPDamage(PVP_BULLET_DAMAGE * 2);  // Mines do 20 damage
                            } else {
                                lives--;
                                playerHitFlash = 200; // Flash for 200ms
                                playOuchSound();
                                document.getElementById('lives').textContent = lives;
                                createExplosion(player.x, player.y, jetColors[selectedColor].body);
                                if (lives <= 0) {
                                    reportAction('hit_bomb');
                                    handlePlayerDeath('hit_bomb');
                                }
                            }
                        }
                    }
                });
            }

            // Shield timer
            if (shieldActive && (Date.now() - shieldStartTime) >= shieldDuration) deactivateShield();

            // Ghost timer
            if (ghostActive && (Date.now() - ghostStartTime) >= ghostDuration) deactivateGhost();

            // Update electric fences
            updateElectricFences(dt);

            // Electric fence collision - instant death if active!
            if (!ghostActive && !isInvincible) {
                for (const fence of electricFences) {
                    if (fence.isActive) {
                        // Check collision with player
                        const playerLeft = player.x - 20;
                        const playerRight = player.x + 20;
                        const playerTop = player.y - 25;
                        const playerBottom = player.y + 25;

                        if (playerRight > fence.x && playerLeft < fence.x + fence.width &&
                            playerBottom > fence.y && playerTop < fence.y + fence.height) {
                            // Instant death from electric fence!
                            if (shieldActive) {
                                // Shield absorbs electric hit
                                shieldHits = 0;
                                deactivateShield();
                                createExplosion(player.x, player.y, '#00ffff', 30);
                                playElectricSound();
                            } else if (canTakeDamage()) {
                                lives = 0;
                                playerHitFlash = 300;
                                playElectricSound();
                                createBigExplosion(player.x, player.y);
                                reportAction('electrocuted');
                                handlePlayerDeath('electrocuted');
                                break;
                            }
                        }
                    }
                }
            }

            // Update new boss weapons
            updateHorizonBeams(dt);
            updateMagneticMines(dt);
            updateMirrorDrones(dt);

            updateBackground(dt);
            updateParticles(dt);
            updateLightningFlash(dt);
        }

        function draw() {
            drawBackground();
            walls.forEach(drawWall);
            bombs.forEach(drawBomb);
            mines.forEach(drawMine);
            electricFences.forEach(drawElectricFence);
            // Draw new boss weapons
            horizonBeams.forEach(drawHorizonBeam);
            magneticMines.forEach(drawMagneticMine);
            mirrorDrones.forEach(drawMirrorDrone);
            bullets.forEach(drawBullet);
            enemies.forEach(drawEnemy);
            powerups.forEach(drawPowerup);
            weaponPickups.forEach(drawWeaponPickup);
            if (bossActive) drawBoss();
            drawParticles();
            if (gameRunning && lives > 0) {
                drawLaser();
                // Ghost mode: draw player semi-transparent
                if (ghostActive) {
                    ctx.globalAlpha = 0.4 + Math.sin(Date.now() / 100) * 0.2;
                }
                drawPlayer();
                ctx.globalAlpha = 1;
                // Draw other player in multiplayer mode
                drawOtherPlayer();
            }
            // Lightning flash overlay (drawn last)
            drawLightningFlash();
        }

        let spawnAccumulator = 0;
        let powerupAccumulator = 0;
        let bombAccumulator = 0;
        let wallAccumulator = 0;
        let weaponAccumulator = 0;
        let spaceObjAccumulator = 0;
        let mineAccumulator = 0;

        function gameLoop(currentTime) {
            const dt = Math.min((currentTime - lastFrameTime) / 1000, 0.1);
            lastFrameTime = currentTime;

            update(dt);
            draw();

            // Update coop HUD if in coop mode
            if (isMultiplayer && selectedGameMode === 'coop') {
                updateCoopHud();
            }

            // Update versus HUD and check hazard bonuses
            if (isMultiplayer && selectedGameMode === 'versus' && versusState.roundActive) {
                updateVersusHud();
                checkKillStreakBonus();
                checkSurvivalBonus();
            }

            // Broadcast game state to spectators (throttled)
            broadcastGameState();

            if (gameRunning) {
                const diff = getDiffSettings();

                // In versus mode (1v1), NO NPCs or obstacles spawn - just players vs players
                const isPvPMode = isMultiplayer && selectedGameMode === 'versus';

                // Spawn powerups in versus mode (both players can grab them)
                powerupAccumulator += dt;
                if (powerupAccumulator >= 6 && Math.random() < 0.4) { spawnPowerup(); powerupAccumulator = 0; }

                weaponAccumulator += dt;
                if (weaponAccumulator >= 10 && Math.random() < 0.4) { spawnWeaponPickup(); weaponAccumulator = 0; }

                // Skip all enemy/obstacle spawning in PvP versus mode
                if (!isPvPMode) {
                    // Walls spawn after 5 kills
                    const wallSpawnTime = Math.max(1.5, 4 - level * 0.5);
                    const wallChance = 0.2 + level * 0.1 + (selectedDifficulty === 'hard' ? 0.15 : 0) + (selectedDifficulty === 'expert' ? 0.25 : 0);
                    wallAccumulator += dt;
                    if (wallAccumulator >= wallSpawnTime && totalEnemiesKilled >= 5 && Math.random() < wallChance) { spawnWall(); wallAccumulator = 0; }

                    // Mines spawn after a few kills
                    mineAccumulator += dt;
                    if (mineAccumulator >= 4 && totalEnemiesKilled >= 3 && Math.random() < 0.3) { spawnMine(); mineAccumulator = 0; }

                    // Electric fences spawn in level 3+ (not during boss fight)
                    if (!bossActive && level >= 3) {
                        fenceSpawnAccumulator += dt;
                        if (fenceSpawnAccumulator >= 8 && Math.random() < 0.25) {
                            spawnElectricFence();
                            fenceSpawnAccumulator = 0;
                        }
                    }

                    // Only spawn enemies and bombs when NOT fighting a boss
                    if (!bossActive) {
                        // Spawn rate decreases (faster spawning) with level and difficulty
                        const baseSpawnRate = Math.max(0.2, (0.8 - level * 0.1) * diff.spawnMult);
                        // Spawn multiple enemies at higher difficulties
                        const enemiesPerSpawn = selectedDifficulty === 'expert' ? 2 : (selectedDifficulty === 'hard' ? (Math.random() < 0.3 ? 2 : 1) : 1);

                        spawnAccumulator += dt;
                        if (spawnAccumulator >= baseSpawnRate) {
                            for (let i = 0; i < enemiesPerSpawn; i++) spawnEnemy();
                            spawnAccumulator = 0;
                        }

                        bombAccumulator += dt;
                        if (bombAccumulator >= 5 && Math.random() < 0.35) { spawnBomb(); bombAccumulator = 0; }

                        spaceObjAccumulator += dt;
                        if (spaceObjAccumulator >= 6 && Math.random() < 0.5) { spawnSpaceObject(); spaceObjAccumulator = 0; }
                    }
                }
            }

            requestAnimationFrame(gameLoop);
        }

        async function startGame() {
            if (audioContext.state === 'suspended') await audioContext.resume();

            // In multiplayer mode, player is already registered when creating/joining room
            // Skip joinAsPlayer to avoid changing myPlayerId which would break WebSocket room sync
            if (!isMultiplayer) {
                // Check username availability BEFORE starting the game (single player only)
                await leaveAsPlayer(); // Leave any old session first
                const joined = await joinAsPlayer();
                if (!joined) {
                    // Username taken or other error - modal already shown, don't start game
                    return;
                }
            } else {
                console.log('Multiplayer mode: skipping joinAsPlayer, using existing playerId:', myPlayerId);
            }

            closeSetupModal();
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('lobbySidebar').style.display = 'none';
            // Also hide multiplayer lobby modal
            document.getElementById('lobbyModal').classList.remove('show');
            document.getElementById('modeSelectModal').classList.remove('show');

            const diff = getDiffSettings();
            score = 0;
            level = 1;
            lives = diff.lives;
            totalEnemiesKilled = 0;
            playerHitFlash = 0;
            playerBombs = 3; // Start with 3 bombs
            lastPlayerBombTime = 0;
            killsThisLevel = 0;
            continuesUsedThisLevel = 0;
            respawnsUsedThisLevel = 0;
            savedLevelScore = 0;
            // Load any stored continue key
            loadStoredContinueKey();
            bullets = []; enemies = []; particles = []; powerups = [];
            bombs = []; walls = []; weaponPickups = []; mines = []; electricFences = [];
            horizonBeams = []; magneticMines = []; mirrorDrones = [];
            player.x = logicalWidth / 2; player.y = logicalHeight - 80;
            spawnAccumulator = 0; powerupAccumulator = 0; bombAccumulator = 0;
            wallAccumulator = 0; weaponAccumulator = 0; spaceObjAccumulator = 0; mineAccumulator = 0;
            currentWeapon = 'pistol';
            unlockedWeapons = ['pistol'];
            laserActive = false;
            laserAmmoTimer = 0;
            // Reset all weapon ammo
            weaponAmmo = {
                pistol: Infinity,
                machinegun: 0,
                bazooka: 0,
                laser: 0,
                flak: 0,
                disc: 0,
                swarm: 0
            };
            deactivateShield();
            ghostActive = false;
            lightningFlashAlpha = 0;
            // Reset boss state
            boss = null;
            bossActive = false;
            bossDefeating = false;
            bossDefeated = [];
            bossTauntTimer = 0;
            bossLowHealthReported = false;
            stopBossMusic();
            document.getElementById('bossHealthContainer').classList.remove('show');
            document.getElementById('bossTaunt').classList.remove('show');
            initBackground();
            // Initialize game timer
            gameStartTime = Date.now();
            gameDuration = 0;

            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('levelDisplay').textContent = level <= 5 ? 'Level ' + level : 'FINAL LEVEL';
            document.getElementById('difficultyDisplay').textContent = diff.name;
            document.getElementById('difficultyDisplay').style.color = diff.color;
            updateWeaponDisplay();

            // Setup appropriate HUD for game mode
            setupGameHud();

            gameRunning = true;
            gamePaused = false;
            lastFrameTime = performance.now();
            playGameStart();
            startBackgroundMusic(false);
            // Show touch controls on mobile
            if (isMobile) {
                document.getElementById('touchControls').classList.add('show');
            }
            // Start server-side game session for score validation
            await startServerGameSession();

            // Debug mode: 'ending123' shows victory screen immediately
            if (myPlayerName && myPlayerName.toLowerCase() === 'ending123') {
                // Simulate beating all bosses
                bossDefeated = [1, 2, 3, 4, 5, 6];
                score = 15000;
                totalEnemiesKilled = 150;
                gameDuration = 600; // 10 minutes
                showVictoryScreen();
                return;
            }

            // Debug mode: 'invincible' gives unlimited lives
            if (myPlayerName && myPlayerName.toLowerCase() === 'invincible') {
                isInvincible = true;
                console.log('INVINCIBLE MODE ACTIVATED!');
            } else {
                isInvincible = false;
            }

            await startGameSession();
            // Show online players bar and chat for single player only
            // Multiplayer has its own UI and doesn't use the spectate system
            if (!isMultiplayer) {
                document.getElementById('onlinePlayersBar').classList.add('show');
                startPlayerPolling();
                updatePlayerStatus('playing');
            }
            reportAction('started_game');
        }

        let lastDeathReason = 'unknown';

        async function gameOver(deathReason = 'unknown') {
            gameRunning = false;
            gamePaused = false;
            laserActive = false;
            lastDeathReason = deathReason;
            // Update final game duration
            if (gameStartTime) {
                gameDuration = Math.floor((Date.now() - gameStartTime) / 1000);
            }
            // End server game session
            endServerGameSession(deathReason, false);
            // Clean up boss state
            const wasBossActive = bossActive;
            boss = null;
            bossActive = false;
            stopBossMusic();
            document.getElementById('bossHealthContainer').classList.remove('show');
            document.getElementById('bossTaunt').classList.remove('show');
            document.getElementById('touchControls').classList.remove('show');

            // Reset HUD to normal (hide coop/versus HUD)
            document.getElementById('ui').style.display = 'flex';
            document.getElementById('coopHud').style.display = 'none';
            document.getElementById('versusHud').style.display = 'none';

            // Stop position sync if in multiplayer
            if (isMultiplayer) {
                stopPositionSync();
                isMultiplayer = false;
            }

            // Report death action
            reportAction('game_over', { deathReason, score, level, duration: gameDuration });
            // End session
            await endGameSession(deathReason);
            // Keep bars visible so player can continue watching others
            // Don't stop polling or leave - do that when going back to menu

            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('finalDifficulty').textContent = getDiffSettings().name;

            // Auto-save high score using player's name from start
            const scoreSavedMsg = document.getElementById('scoreSavedMsg');
            await fetchLeaderboard();
            if (isHighScore(score) && score > 0) {
                const playerName = myPlayerName || 'Anonymous';
                await addHighScore(playerName, score, selectedDifficulty.toUpperCase(), level, gameDuration);
                scoreSavedMsg.textContent = `üéâ High Score saved as "${playerName}"!`;
                scoreSavedMsg.style.display = 'block';
            } else {
                scoreSavedMsg.style.display = 'none';
            }
            renderAllLeaderboards();

            document.getElementById('gameOverScreen').classList.remove('hidden');
            playGameOver();
            stopBackgroundMusic();
        }

        async function backToMenu() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
            document.getElementById('lobbySidebar').style.display = 'block';
            // Clean up when going back to menu
            stopPlayerPolling();
            document.getElementById('onlinePlayersBar').classList.remove('show');
            await leaveAsPlayer();
            await renderLeaderboard('startLeaderboardList');
        }

        async function quitGame() {
            if (!gameRunning) return;

            // Notify opponent in multiplayer before cleanup
            if (isMultiplayer && mpSocket && currentRoomCode) {
                mpSocket.emit('player_quit', {
                    roomCode: currentRoomCode,
                    playerId: myPlayerId,
                    playerName: myPlayerName,
                    reason: 'quit'
                });
            }

            gameRunning = false;
            gamePaused = false;
            laserActive = false;

            // Clean up multiplayer state
            if (isMultiplayer) {
                stopPositionSync();
                isMultiplayer = false;
                currentRoomCode = null;
            }

            // End server game session
            endServerGameSession('quit', false);
            // Clean up boss state
            boss = null;
            bossActive = false;
            stopBossMusic();
            document.getElementById('bossHealthContainer').classList.remove('show');
            document.getElementById('bossTaunt').classList.remove('show');
            document.getElementById('pauseOverlay').classList.remove('show');
            document.getElementById('touchControls').classList.remove('show');
            // Hide multiplayer overlays
            const opponentPausedOverlay = document.getElementById('opponentPausedOverlay');
            if (opponentPausedOverlay) opponentPausedOverlay.classList.remove('show');
            const opponentLeftOverlay = document.getElementById('opponentLeftOverlay');
            if (opponentLeftOverlay) opponentLeftOverlay.classList.remove('show');
            // Clean up live players
            stopPlayerPolling();
            document.getElementById('onlinePlayersBar').classList.remove('show');
            await leaveAsPlayer();
            stopBackgroundMusic();
            document.getElementById('startScreen').classList.remove('hidden');
            document.getElementById('lobbySidebar').style.display = 'block';
            await renderLeaderboard('startLeaderboardList');
        }

        // === PAUSE FUNCTIONS ===
        function togglePause() {
            if (!gameRunning) return;
            if (gamePaused) {
                resumeGame();
            } else {
                pauseGame();
            }
        }

        function pauseGame() {
            if (!gameRunning || gamePaused) return;
            gamePaused = true;
            document.getElementById('pauseOverlay').classList.add('show');
            stopBackgroundMusic();
            stopBossMusic();

            // Notify opponent in multiplayer
            if (isMultiplayer && mpSocket && currentRoomCode) {
                mpSocket.emit('player_paused', {
                    roomCode: currentRoomCode,
                    playerId: myPlayerId,
                    playerName: myPlayerName
                });
            }
        }

        function resumeGame() {
            if (!gamePaused) return;
            gamePaused = false;
            document.getElementById('pauseOverlay').classList.remove('show');

            // Hide opponent paused overlay if showing
            const opponentPausedOverlay = document.getElementById('opponentPausedOverlay');
            if (opponentPausedOverlay) {
                opponentPausedOverlay.classList.remove('show');
            }

            lastFrameTime = performance.now();
            if (bossActive) {
                startBossMusic();
            } else {
                startBackgroundMusic(shieldActive);
            }

            // Notify opponent in multiplayer
            if (isMultiplayer && mpSocket && currentRoomCode) {
                mpSocket.emit('player_resumed', {
                    roomCode: currentRoomCode,
                    playerId: myPlayerId,
                    playerName: myPlayerName
                });
            }
        }

        // === OPPONENT STATUS OVERLAYS ===
        function showOpponentPausedOverlay(opponentName) {
            if (!isMultiplayer) return;
            // Pause our game when opponent pauses
            if (!gamePaused) {
                gamePaused = true;
                stopBackgroundMusic();
                stopBossMusic();
            }
            document.getElementById('opponentPausedMessage').textContent = `${opponentName} paused the game`;
            document.getElementById('opponentPausedOverlay').classList.add('show');
        }

        function hideOpponentPausedOverlay() {
            document.getElementById('opponentPausedOverlay').classList.remove('show');
            // Auto-resume if we weren't the ones who paused
            if (gamePaused && !document.getElementById('pauseOverlay').classList.contains('show')) {
                gamePaused = false;
                lastFrameTime = performance.now();
                if (bossActive) {
                    startBossMusic();
                } else {
                    startBackgroundMusic(shieldActive);
                }
            }
        }

        function showOpponentLeftOverlay(opponentName) {
            if (!isMultiplayer) return;
            // Stop the game
            gameRunning = false;
            gamePaused = true;
            stopBackgroundMusic();
            stopBossMusic();
            stopPositionSync();
            document.getElementById('opponentLeftMessage').textContent = `${opponentName} has left the game`;
            document.getElementById('opponentLeftOverlay').classList.add('show');
        }

        async function quitFromOpponentLeft() {
            document.getElementById('opponentLeftOverlay').classList.remove('show');

            // Clean up multiplayer state
            isMultiplayer = false;
            currentRoomCode = null;
            stopPositionSync();

            // Clean up game state (quitGame would return early since gameRunning is already false)
            gamePaused = false;
            laserActive = false;

            // Clean up boss state
            boss = null;
            bossActive = false;
            stopBossMusic();
            document.getElementById('bossHealthContainer').classList.remove('show');
            document.getElementById('bossTaunt').classList.remove('show');
            document.getElementById('pauseOverlay').classList.remove('show');
            document.getElementById('touchControls').classList.remove('show');

            // Clean up live players
            stopPlayerPolling();
            document.getElementById('onlinePlayersBar').classList.remove('show');
            await leaveAsPlayer();
            stopBackgroundMusic();

            // Show start screen
            document.getElementById('startScreen').classList.remove('hidden');
            document.getElementById('lobbySidebar').style.display = 'block';
            await renderLeaderboard('startLeaderboardList');
        }

        async function quitFromPause() {
            document.getElementById('pauseOverlay').classList.remove('show');
            await quitGame();
        }

        // === CONTROLS ===
        const WEAPON_KEYS = ['pistol', 'machinegun', 'bazooka', 'laser', 'flak', 'disc', 'swarm'];
        document.addEventListener('keydown', (e) => {
            // Prevent key repeat for shooting - only fire on initial press
            if (e.code === 'Space' && !e.repeat && gameRunning && !gamePaused) { shoot(); e.preventDefault(); }
            keys[e.code] = true;
            if (e.code === 'KeyQ' && gameRunning && !gamePaused) { switchWeapon(); e.preventDefault(); }
            if (e.code === 'KeyB' && !e.repeat && gameRunning && !gamePaused) { dropPlayerBomb(); e.preventDefault(); }
            if (e.code === 'KeyP' && gameRunning) { togglePause(); e.preventDefault(); }
            if (e.code === 'Escape' && gameRunning) {
                if (gamePaused) resumeGame();
                else pauseGame();
                e.preventDefault();
            }
            // Number keys 1-7 to switch weapons directly
            if (gameRunning && !gamePaused) {
                const num = parseInt(e.key);
                if (num >= 1 && num <= 7) {
                    const weaponKey = WEAPON_KEYS[num - 1];
                    if (weaponKey) switchToWeapon(weaponKey);
                    e.preventDefault();
                }
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            if (e.code === 'Space') laserActive = false;
        });

        const joystickArea = document.getElementById('joystickArea');
        const joystickKnob = document.getElementById('joystickKnob');
        const fireButton = document.getElementById('fireButton');
        const switchBtn = document.getElementById('switchWeaponBtn');

        function handleJoystickMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = joystickArea.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let dx = touch.clientX - centerX, dy = touch.clientY - centerY;
            const maxRadius = rect.width / 2 - 30;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > maxRadius) { dx = (dx / dist) * maxRadius; dy = (dy / dist) * maxRadius; }
            joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            touchMove.x = dx / maxRadius; touchMove.y = dy / maxRadius;
        }

        joystickArea.addEventListener('touchstart', (e) => { e.preventDefault(); joystickActive = true; handleJoystickMove(e); });
        joystickArea.addEventListener('touchmove', handleJoystickMove);
        joystickArea.addEventListener('touchend', (e) => { e.preventDefault(); joystickActive = false; touchMove.x = 0; touchMove.y = 0; joystickKnob.style.transform = 'translate(-50%, -50%)'; });

        // Tap-to-fire only - no hold-to-fire (autoFire disabled)
        fireButton.addEventListener('touchstart', (e) => { e.preventDefault(); if (gameRunning) shoot(); });
        fireButton.addEventListener('touchend', (e) => { e.preventDefault(); laserActive = false; });

        switchBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if (gameRunning) switchWeapon(); });

        document.body.addEventListener('touchmove', (e) => {
            if (e.target.closest('#joystickArea') || e.target.closest('#fireButton') || e.target.closest('#switchWeaponBtn')) e.preventDefault();
        }, { passive: false });

        initBackground();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
